# N8N 配置文件详解

## 📋 目录

- [Docker Compose 配置](#docker-compose-配置)
- [环境变量配置](#环境变量配置)
- [部署脚本配置](#部署脚本配置)
- [安全配置](#安全配置)
- [性能优化配置](#性能优化配置)
- [监控配置](#监控配置)
- [备份配置](#备份配置)

---

## 🐳 Docker Compose 配置

### 主配置文件：docker-compose.yml

#### 服务架构说明

```yaml
version: '3.8'  # Docker Compose 版本

# 网络配置
networks:
  n8n-network:
    driver: bridge  # 使用桥接网络模式
    ipam:
      config:
        - subnet: 172.20.0.0/16  # 自定义子网，避免IP冲突

# 数据卷配置
volumes:
  n8n_data:        # N8N 应用数据
  postgres_data:   # PostgreSQL 数据库数据
  redis_data:      # Redis 缓存数据
```

#### N8N 主服务配置

```yaml
services:
  n8n:
    image: n8nio/n8n:latest
    container_name: n8n-main
    restart: unless-stopped  # 容器异常退出时自动重启
    
    # 端口映射
    ports:
      - "${N8N_PORT:-5678}:5678"  # 使用环境变量，默认5678
    
    # 环境变量
    environment:
      # 基础配置
      - N8N_PROTOCOL=${N8N_PROTOCOL:-http}
      - N8N_HOST=${DOMAIN_NAME:-localhost}
      - N8N_PORT=5678
      
      # 数据库配置
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_PASSWORD}
      
      # 执行配置
      - EXECUTIONS_MODE=queue  # 使用队列模式提高性能
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_PASSWORD=${REDIS_PASSWORD}
    
    # 数据卷挂载
    volumes:
      - n8n_data:/home/node/.n8n  # N8N 数据目录
      - /var/run/docker.sock:/var/run/docker.sock:ro  # Docker socket（可选）
    
    # 服务依赖
    depends_on:
      postgres:
        condition: service_healthy  # 等待数据库健康检查通过
      redis:
        condition: service_started
    
    # 健康检查
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:5678/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    
    networks:
      - n8n-network
```

#### PostgreSQL 数据库配置

```yaml
  postgres:
    image: postgres:15-alpine  # 使用轻量级Alpine版本
    container_name: n8n-postgres
    restart: unless-stopped
    
    # 环境变量
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
    
    # 数据卷
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql:ro
    
    # 端口映射（仅开发环境）
    ports:
      - "5432:5432"  # 生产环境建议移除
    
    # 健康检查
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
    
    # 性能优化
    command: >
      postgres
      -c shared_preload_libraries=pg_stat_statements
      -c pg_stat_statements.track=all
      -c max_connections=200
      -c shared_buffers=256MB
      -c effective_cache_size=1GB
      -c work_mem=4MB
      -c maintenance_work_mem=64MB
    
    networks:
      - n8n-network
```

#### Redis 缓存配置

```yaml
  redis:
    image: redis:7-alpine
    container_name: n8n-redis
    restart: unless-stopped
    
    # 启动命令
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --appendonly yes
      --appendfsync everysec
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
    
    # 数据卷
    volumes:
      - redis_data:/data
      - ./config/redis.conf:/usr/local/etc/redis/redis.conf:ro
    
    # 健康检查
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    
    networks:
      - n8n-network
```

#### Nginx 反向代理配置（可选）

```yaml
  nginx:
    image: nginx:alpine
    container_name: n8n-nginx
    restart: unless-stopped
    
    ports:
      - "80:80"
      - "443:443"
    
    volumes:
      - ./config/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
      - ./logs/nginx:/var/log/nginx
    
    depends_on:
      - n8n
    
    networks:
      - n8n-network
```

---

## 🔧 环境变量配置

### .env 文件详解

#### 基础网络配置

```bash
# ===========================================
# 基础网络配置
# ===========================================

# 主域名配置
DOMAIN_NAME=your-domain.com
# 说明：生产环境使用实际域名，开发环境可使用 localhost

# 子域名配置
SUBDOMAIN=n8n
# 说明：完整访问地址为 https://n8n.your-domain.com

# 协议配置
N8N_PROTOCOL=https
# 选项：http（开发环境）/ https（生产环境）

# 端口配置
N8N_PORT=5678
# 说明：N8N Web界面访问端口，默认5678

# 编辑器基础URL
N8N_EDITOR_BASE_URL=https://${SUBDOMAIN}.${DOMAIN_NAME}
# 说明：用于生成工作流分享链接和Webhook URL
```

#### 用户认证配置

```bash
# ===========================================
# 用户认证配置
# ===========================================

# 基础认证开关
N8N_BASIC_AUTH_ACTIVE=true
# 说明：启用后需要用户名密码才能访问N8N界面

# 基础认证用户名
N8N_BASIC_AUTH_USER=admin
# 说明：管理员用户名，建议使用复杂用户名

# 基础认证密码
N8N_BASIC_AUTH_PASSWORD=your_secure_password_here
# 安全要求：至少12位，包含大小写字母、数字、特殊字符

# 用户管理JWT密钥
N8N_USER_MANAGEMENT_JWT_SECRET=your_jwt_secret_key_here
# 安全要求：至少32位随机字符串，用于JWT令牌签名

# JWT令牌过期时间
N8N_USER_MANAGEMENT_JWT_DURATION_HOURS=168
# 说明：JWT令牌有效期，单位小时，默认7天（168小时）

# 用户管理功能开关
N8N_USER_MANAGEMENT_DISABLED=false
# 说明：是否禁用用户管理功能，true=禁用，false=启用
```

#### 安全加密配置

```bash
# ===========================================
# 安全加密配置
# ===========================================

# 数据加密密钥
N8N_ENCRYPTION_KEY=your_encryption_key_here
# 安全要求：至少32位随机字符串，用于敏感数据加密
# 重要：此密钥丢失将导致已保存的凭据无法解密

# 工作流加密开关
N8N_WORKFLOWS_ENCRYPTION_ENABLED=true
# 说明：是否加密存储工作流数据

# 凭据加密开关
N8N_CREDENTIALS_ENCRYPTION_ENABLED=true
# 说明：是否加密存储API密钥等敏感凭据

# 安全头配置
N8N_SECURE_COOKIE=true
# 说明：HTTPS环境下启用安全Cookie

# CORS配置
N8N_CORS_ORIGIN=https://${SUBDOMAIN}.${DOMAIN_NAME}
# 说明：跨域请求允许的源地址
```

#### 数据库配置

```bash
# ===========================================
# PostgreSQL 数据库配置
# ===========================================

# 数据库类型
DB_TYPE=postgresdb
# 选项：sqlite（开发）/ postgresdb（生产推荐）/ mysql

# 数据库主机
DB_POSTGRESDB_HOST=postgres
# 说明：Docker环境使用服务名，独立部署使用IP地址

# 数据库端口
DB_POSTGRESDB_PORT=5432
# 说明：PostgreSQL默认端口

# 数据库名称
DB_POSTGRESDB_DATABASE=n8n
# 说明：N8N专用数据库名称

# 数据库用户
DB_POSTGRESDB_USER=n8n
# 说明：数据库用户名，建议使用专用用户

# 数据库密码
DB_POSTGRESDB_PASSWORD=your_db_password_here
# 安全要求：至少16位强密码

# 连接池配置
DB_POSTGRESDB_POOL_SIZE=10
# 说明：数据库连接池大小，根据并发需求调整

# 连接超时配置
DB_POSTGRESDB_CONNECTION_TIMEOUT=30000
# 说明：数据库连接超时时间，单位毫秒

# PostgreSQL 系统配置
POSTGRES_DB=${DB_POSTGRESDB_DATABASE}
POSTGRES_USER=${DB_POSTGRESDB_USER}
POSTGRES_PASSWORD=${DB_POSTGRESDB_PASSWORD}
```

#### Redis 缓存配置

```bash
# ===========================================
# Redis 缓存配置
# ===========================================

# Redis主机
REDIS_HOST=redis
# 说明：Docker环境使用服务名

# Redis端口
REDIS_PORT=6379
# 说明：Redis默认端口

# Redis密码
REDIS_PASSWORD=your_redis_password_here
# 安全要求：至少12位密码

# Redis数据库索引
REDIS_DB=0
# 说明：使用的Redis数据库索引，0-15

# 连接超时
REDIS_CONNECTION_TIMEOUT=5000
# 说明：Redis连接超时时间，单位毫秒

# 命令超时
REDIS_COMMAND_TIMEOUT=5000
# 说明：Redis命令执行超时时间，单位毫秒
```

#### 执行配置

```bash
# ===========================================
# 工作流执行配置
# ===========================================

# 执行模式
EXECUTIONS_MODE=queue
# 选项：main（主进程执行）/ queue（队列模式，推荐）

# 队列配置
QUEUE_BULL_REDIS_HOST=${REDIS_HOST}
QUEUE_BULL_REDIS_PORT=${REDIS_PORT}
QUEUE_BULL_REDIS_PASSWORD=${REDIS_PASSWORD}
QUEUE_BULL_REDIS_DB=1
# 说明：使用独立的Redis数据库索引存储队列数据

# 并发执行数量
N8N_CONCURRENCY=10
# 说明：同时执行的工作流数量，根据服务器性能调整

# 最大负载大小
N8N_PAYLOAD_SIZE_MAX=16
# 说明：单个工作流最大数据负载，单位MB

# 执行超时时间
N8N_EXECUTION_TIMEOUT=3600
# 说明：单个工作流最大执行时间，单位秒

# 数据保存策略
EXECUTIONS_DATA_SAVE_ON_ERROR=all
# 选项：all（保存所有）/ none（不保存）

EXECUTIONS_DATA_SAVE_ON_SUCCESS=all
# 选项：all（保存所有）/ none（不保存）

# 执行数据保留时间
EXECUTIONS_DATA_MAX_AGE=168
# 说明：执行历史数据保留时间，单位小时
```

#### AI智能体配置

```bash
# ===========================================
# AI智能体配置
# ===========================================

# OpenAI API配置
OPENAI_API_KEY=your_openai_api_key_here
# 说明：OpenAI API密钥，用于AI节点功能

# OpenAI API基础URL
OPENAI_API_BASE_URL=https://api.openai.com/v1
# 说明：OpenAI API基础地址，可配置代理地址

# 默认AI模型
OPENAI_DEFAULT_MODEL=gpt-3.5-turbo
# 选项：gpt-3.5-turbo / gpt-4 / gpt-4-turbo

# AI请求超时时间
OPENAI_REQUEST_TIMEOUT=60000
# 说明：AI API请求超时时间，单位毫秒

# 最大tokens数量
OPENAI_MAX_TOKENS=2000
# 说明：单次AI请求最大token数量

# AI功能开关
N8N_AI_ENABLED=true
# 说明：是否启用AI相关功能
```

#### 日志配置

```bash
# ===========================================
# 日志配置
# ===========================================

# 日志级别
N8N_LOG_LEVEL=info
# 选项：error / warn / info / debug / trace

# 日志输出方式
N8N_LOG_OUTPUT=console,file
# 选项：console（控制台）/ file（文件）/ console,file（同时输出）

# 日志文件位置
N8N_LOG_FILE_LOCATION=/var/log/n8n/
# 说明：日志文件存储目录

# 日志文件大小限制
N8N_LOG_FILE_SIZE_MAX=10
# 说明：单个日志文件最大大小，单位MB

# 日志文件数量限制
N8N_LOG_FILE_COUNT_MAX=10
# 说明：保留的日志文件数量

# 访问日志开关
N8N_ACCESS_LOG_ENABLED=true
# 说明：是否记录HTTP访问日志
```

#### 监控配置

```bash
# ===========================================
# 监控配置
# ===========================================

# 健康检查端点
N8N_METRICS_ENABLED=true
# 说明：启用Prometheus指标收集

# 指标端口
N8N_METRICS_PORT=9090
# 说明：Prometheus指标暴露端口

# 健康检查路径
N8N_HEALTH_CHECK_PATH=/healthz
# 说明：健康检查API路径

# 性能监控开关
N8N_DIAGNOSTICS_ENABLED=true
# 说明：启用性能诊断数据收集

# 错误追踪配置
SENTRY_DSN=your_sentry_dsn_here
# 说明：Sentry错误追踪服务DSN（可选）
```

#### 备份恢复配置

```bash
# ===========================================
# 备份恢复配置
# ===========================================

# 自动备份开关
N8N_AUTO_BACKUP_ENABLED=true
# 说明：是否启用自动备份功能

# 备份频率
N8N_BACKUP_SCHEDULE=0 2 * * *
# 说明：Cron表达式，默认每天凌晨2点备份

# 备份保留天数
N8N_BACKUP_RETENTION_DAYS=30
# 说明：备份文件保留天数

# 备份存储路径
N8N_BACKUP_PATH=/var/backups/n8n/
# 说明：备份文件存储目录

# 远程备份配置（可选）
AWS_ACCESS_KEY_ID=your_aws_access_key
AWS_SECRET_ACCESS_KEY=your_aws_secret_key
AWS_S3_BUCKET=your-backup-bucket
AWS_S3_REGION=us-east-1
```

---

## 🚀 部署脚本配置

### deploy_n8n.sh 脚本详解

#### 脚本功能说明

```bash
#!/bin/bash
# ===========================================
# N8N 自动化部署脚本
# 功能：一键部署N8N系统，包含环境检查、依赖安装、配置生成等
# 作者：系统管理员
# 版本：v2.0
# 更新时间：2024-01-01
# ===========================================

# 脚本安全设置
set -euo pipefail  # 遇到错误立即退出，未定义变量报错，管道错误传播
IFS=$'\n\t'        # 设置内部字段分隔符，防止空格问题

# 颜色定义（用于美化输出）
readonly RED='\033[0;31m'      # 红色（错误信息）
readonly GREEN='\033[0;32m'    # 绿色（成功信息）
readonly YELLOW='\033[1;33m'   # 黄色（警告信息）
readonly BLUE='\033[0;34m'     # 蓝色（信息提示）
readonly PURPLE='\033[0;35m'   # 紫色（重要信息）
readonly CYAN='\033[0;36m'     # 青色（步骤提示）
readonly NC='\033[0m'          # 无颜色（重置）
```

#### 全局配置变量

```bash
# ===========================================
# 全局配置变量
# ===========================================

# 项目信息
readonly SCRIPT_NAME="N8N部署脚本"
readonly SCRIPT_VERSION="2.0"
readonly PROJECT_NAME="N8N-自动化"

# 系统要求
readonly MIN_DOCKER_VERSION="20.10.0"
readonly MIN_COMPOSE_VERSION="2.0.0"
readonly MIN_MEMORY_GB=4
readonly MIN_DISK_GB=20

# 默认配置
readonly DEFAULT_N8N_PORT=5678
readonly DEFAULT_POSTGRES_PORT=5432
readonly DEFAULT_REDIS_PORT=6379

# 文件路径
readonly ENV_FILE=".env"
readonly COMPOSE_FILE="docker-compose.yml"
readonly BACKUP_DIR="backups"
readonly LOG_DIR="logs"

# 网络配置
readonly DOCKER_NETWORK="n8n-network"
readonly SUBNET="172.20.0.0/16"
```

#### 日志记录函数

```bash
# ===========================================
# 日志记录函数
# ===========================================

# 创建日志目录
setup_logging() {
    local log_dir="${LOG_DIR}"
    local log_file="${log_dir}/deploy_$(date +%Y%m%d_%H%M%S).log"
    
    # 创建日志目录
    mkdir -p "${log_dir}"
    
    # 设置日志文件
    exec 1> >(tee -a "${log_file}")
    exec 2> >(tee -a "${log_file}" >&2)
    
    log_info "日志文件：${log_file}"
}

# 信息日志
log_info() {
    echo -e "${BLUE}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

# 成功日志
log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

# 警告日志
log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

# 错误日志
log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
}

# 步骤日志
log_step() {
    echo -e "${CYAN}[STEP]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}
```

#### 错误处理函数

```bash
# ===========================================
# 错误处理函数
# ===========================================

# 错误处理器
error_handler() {
    local line_number=$1
    local error_code=$2
    local command="$3"
    
    log_error "脚本执行失败！"
    log_error "错误位置：第 ${line_number} 行"
    log_error "错误代码：${error_code}"
    log_error "失败命令：${command}"
    
    # 显示调用栈
    log_error "调用栈："
    local frame=0
    while caller $frame; do
        ((frame++))
    done
    
    # 清理临时文件
    cleanup_on_error
    
    exit "${error_code}"
}

# 设置错误处理器
trap 'error_handler ${LINENO} $? "$BASH_COMMAND"' ERR

# 清理函数
cleanup_on_error() {
    log_warning "正在清理临时文件..."
    
    # 停止可能启动的容器
    if docker-compose ps -q > /dev/null 2>&1; then
        docker-compose down --remove-orphans
    fi
    
    # 清理临时文件
    rm -f .env.tmp docker-compose.yml.tmp
    
    log_info "清理完成"
}

# 脚本退出时清理
trap cleanup_on_error EXIT
```

#### 系统检测函数

```bash
# ===========================================
# 系统检测函数
# ===========================================

# 检查系统要求
check_system_requirements() {
    log_step "检查系统要求..."
    
    # 检查操作系统
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        log_info "操作系统：Linux"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        log_info "操作系统：macOS"
    else
        log_error "不支持的操作系统：$OSTYPE"
        return 1
    fi
    
    # 检查内存
    local memory_gb
    if command -v free >/dev/null 2>&1; then
        memory_gb=$(free -g | awk '/^Mem:/{print $2}')
    elif command -v vm_stat >/dev/null 2>&1; then
        local pages=$(vm_stat | grep "Pages free" | awk '{print $3}' | sed 's/\.//')
        memory_gb=$((pages * 4096 / 1024 / 1024 / 1024))
    else
        log_warning "无法检测内存大小"
        memory_gb=${MIN_MEMORY_GB}
    fi
    
    if [[ ${memory_gb} -lt ${MIN_MEMORY_GB} ]]; then
        log_warning "内存不足：${memory_gb}GB < ${MIN_MEMORY_GB}GB"
    else
        log_success "内存检查通过：${memory_gb}GB"
    fi
    
    # 检查磁盘空间
    local disk_gb=$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
    if [[ ${disk_gb} -lt ${MIN_DISK_GB} ]]; then
        log_warning "磁盘空间不足：${disk_gb}GB < ${MIN_DISK_GB}GB"
    else
        log_success "磁盘空间检查通过：${disk_gb}GB"
    fi
}

# 检查Docker安装
check_docker() {
    log_step "检查Docker环境..."
    
    # 检查Docker是否安装
    if ! command -v docker >/dev/null 2>&1; then
        log_error "Docker未安装，请先安装Docker"
        return 1
    fi
    
    # 检查Docker版本
    local docker_version=$(docker --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    if ! version_compare "${docker_version}" "${MIN_DOCKER_VERSION}"; then
        log_error "Docker版本过低：${docker_version} < ${MIN_DOCKER_VERSION}"
        return 1
    fi
    log_success "Docker版本检查通过：${docker_version}"
    
    # 检查Docker服务状态
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker服务未运行，请启动Docker服务"
        return 1
    fi
    log_success "Docker服务运行正常"
    
    # 检查Docker Compose
    if ! command -v docker-compose >/dev/null 2>&1; then
        log_error "Docker Compose未安装"
        return 1
    fi
    
    local compose_version=$(docker-compose --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    if ! version_compare "${compose_version}" "${MIN_COMPOSE_VERSION}"; then
        log_error "Docker Compose版本过低：${compose_version} < ${MIN_COMPOSE_VERSION}"
        return 1
    fi
    log_success "Docker Compose版本检查通过：${compose_version}"
}

# 版本比较函数
version_compare() {
    local version1=$1
    local version2=$2
    
    # 将版本号转换为数字进行比较
    local v1_major=$(echo "$version1" | cut -d. -f1)
    local v1_minor=$(echo "$version1" | cut -d. -f2)
    local v1_patch=$(echo "$version1" | cut -d. -f3)
    
    local v2_major=$(echo "$version2" | cut -d. -f1)
    local v2_minor=$(echo "$version2" | cut -d. -f2)
    local v2_patch=$(echo "$version2" | cut -d. -f3)
    
    # 比较主版本号
    if [[ $v1_major -gt $v2_major ]]; then
        return 0
    elif [[ $v1_major -lt $v2_major ]]; then
        return 1
    fi
    
    # 比较次版本号
    if [[ $v1_minor -gt $v2_minor ]]; then
        return 0
    elif [[ $v1_minor -lt $v2_minor ]]; then
        return 1
    fi
    
    # 比较补丁版本号
    if [[ $v1_patch -ge $v2_patch ]]; then
        return 0
    else
        return 1
    fi
}
```

#### 配置生成函数

```bash
# ===========================================
# 配置生成函数
# ===========================================

# 生成随机密码
generate_password() {
    local length=${1:-32}
    openssl rand -base64 $((length * 3 / 4)) | tr -d "=+/" | cut -c1-${length}
}

# 生成环境变量文件
generate_env_file() {
    log_step "生成环境变量配置..."
    
    # 交互式配置收集
    collect_user_config
    
    # 生成密码
    local encryption_key=$(generate_password 32)
    local jwt_secret=$(generate_password 64)
    local postgres_password=$(generate_password 16)
    local redis_password=$(generate_password 16)
    
    # 创建.env文件
    cat > "${ENV_FILE}" << EOF
# ===========================================
# N8N 环境配置文件
# 生成时间：$(date '+%Y-%m-%d %H:%M:%S')
# 生成脚本：${SCRIPT_NAME} v${SCRIPT_VERSION}
# ===========================================

# 基础网络配置
DOMAIN_NAME=${DOMAIN_NAME}
SUBDOMAIN=${SUBDOMAIN}
N8N_PROTOCOL=${N8N_PROTOCOL}
N8N_PORT=${N8N_PORT}
N8N_EDITOR_BASE_URL=${N8N_PROTOCOL}://${SUBDOMAIN}.${DOMAIN_NAME}

# 用户认证配置
N8N_BASIC_AUTH_ACTIVE=true
N8N_BASIC_AUTH_USER=${ADMIN_USER}
N8N_BASIC_AUTH_PASSWORD=${ADMIN_PASSWORD}
N8N_USER_MANAGEMENT_JWT_SECRET=${jwt_secret}
N8N_USER_MANAGEMENT_JWT_DURATION_HOURS=168
N8N_USER_MANAGEMENT_DISABLED=false

# 安全加密配置
N8N_ENCRYPTION_KEY=${encryption_key}
N8N_WORKFLOWS_ENCRYPTION_ENABLED=true
N8N_CREDENTIALS_ENCRYPTION_ENABLED=true
N8N_SECURE_COOKIE=true
N8N_CORS_ORIGIN=${N8N_PROTOCOL}://${SUBDOMAIN}.${DOMAIN_NAME}

# 数据库配置
DB_TYPE=postgresdb
DB_POSTGRESDB_HOST=postgres
DB_POSTGRESDB_PORT=5432
DB_POSTGRESDB_DATABASE=n8n
DB_POSTGRESDB_USER=n8n
DB_POSTGRESDB_PASSWORD=${postgres_password}
DB_POSTGRESDB_POOL_SIZE=10
DB_POSTGRESDB_CONNECTION_TIMEOUT=30000

# PostgreSQL系统配置
POSTGRES_DB=n8n
POSTGRES_USER=n8n
POSTGRES_PASSWORD=${postgres_password}

# Redis配置
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=${redis_password}
REDIS_DB=0
REDIS_CONNECTION_TIMEOUT=5000
REDIS_COMMAND_TIMEOUT=5000

# 执行配置
EXECUTIONS_MODE=queue
QUEUE_BULL_REDIS_HOST=redis
QUEUE_BULL_REDIS_PORT=6379
QUEUE_BULL_REDIS_PASSWORD=${redis_password}
QUEUE_BULL_REDIS_DB=1
N8N_CONCURRENCY=10
N8N_PAYLOAD_SIZE_MAX=16
N8N_EXECUTION_TIMEOUT=3600
EXECUTIONS_DATA_SAVE_ON_ERROR=all
EXECUTIONS_DATA_SAVE_ON_SUCCESS=all
EXECUTIONS_DATA_MAX_AGE=168

# 日志配置
N8N_LOG_LEVEL=info
N8N_LOG_OUTPUT=console,file
N8N_LOG_FILE_LOCATION=/var/log/n8n/
N8N_LOG_FILE_SIZE_MAX=10
N8N_LOG_FILE_COUNT_MAX=10
N8N_ACCESS_LOG_ENABLED=true

# 监控配置
N8N_METRICS_ENABLED=true
N8N_METRICS_PORT=9090
N8N_HEALTH_CHECK_PATH=/healthz
N8N_DIAGNOSTICS_ENABLED=true

# 备份配置
N8N_AUTO_BACKUP_ENABLED=true
N8N_BACKUP_SCHEDULE=0 2 * * *
N8N_BACKUP_RETENTION_DAYS=30
N8N_BACKUP_PATH=/var/backups/n8n/

EOF

    log_success "环境变量文件生成完成：${ENV_FILE}"
}

# 收集用户配置
collect_user_config() {
    log_info "请输入配置信息（按回车使用默认值）："
    
    # 域名配置
    read -p "域名 [localhost]: " DOMAIN_NAME
    DOMAIN_NAME=${DOMAIN_NAME:-localhost}
    
    read -p "子域名 [n8n]: " SUBDOMAIN
    SUBDOMAIN=${SUBDOMAIN:-n8n}
    
    # 协议选择
    if [[ "${DOMAIN_NAME}" == "localhost" ]]; then
        N8N_PROTOCOL="http"
    else
        read -p "协议 (http/https) [https]: " N8N_PROTOCOL
        N8N_PROTOCOL=${N8N_PROTOCOL:-https}
    fi
    
    # 端口配置
    read -p "N8N端口 [${DEFAULT_N8N_PORT}]: " N8N_PORT
    N8N_PORT=${N8N_PORT:-${DEFAULT_N8N_PORT}}
    
    # 管理员账户
    read -p "管理员用户名 [admin]: " ADMIN_USER
    ADMIN_USER=${ADMIN_USER:-admin}
    
    while true; do
        read -s -p "管理员密码（至少8位）: " ADMIN_PASSWORD
        echo
        if [[ ${#ADMIN_PASSWORD} -ge 8 ]]; then
            break
        else
            log_warning "密码长度不足，请输入至少8位密码"
        fi
    done
}
```

---

## 🔒 安全配置

### SSL/TLS 配置

#### Nginx SSL 配置

```nginx
# /config/nginx.conf
server {
    listen 80;
    server_name n8n.your-domain.com;
    
    # HTTP重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name n8n.your-domain.com;
    
    # SSL证书配置
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    
    # SSL安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # 安全头
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # 反向代理配置
    location / {
        proxy_pass http://n8n:5678;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # 超时配置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # Webhook路径优化
    location /webhook/ {
        proxy_pass http://n8n:5678;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 增加超时时间
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
    }
}
```

### 防火墙配置

#### UFW 防火墙规则

```bash
#!/bin/bash
# 防火墙配置脚本

# 重置防火墙规则
ufw --force reset

# 默认策略
ufw default deny incoming
ufw default allow outgoing

# SSH访问
ufw allow ssh

# HTTP/HTTPS访问
ufw allow 80/tcp
ufw allow 443/tcp

# N8N端口（仅本地访问）
ufw allow from 127.0.0.1 to any port 5678

# 数据库端口（仅Docker网络）
ufw allow from 172.20.0.0/16 to any port 5432
ufw allow from 172.20.0.0/16 to any port 6379

# 启用防火墙
ufw --force enable

# 显示状态
ufw status verbose
```

---

## ⚡ 性能优化配置

### PostgreSQL 优化

#### postgresql.conf 优化配置

```sql
-- /config/postgresql.conf

-- 内存配置
shared_buffers = 256MB                    -- 共享缓冲区，建议为内存的25%
effective_cache_size = 1GB                -- 有效缓存大小，建议为内存的75%
work_mem = 4MB                           -- 工作内存
maintenance_work_mem = 64MB              -- 维护工作内存

-- 连接配置
max_connections = 200                     -- 最大连接数
shared_preload_libraries = 'pg_stat_statements'  -- 预加载统计扩展

-- 检查点配置
checkpoint_completion_target = 0.9        -- 检查点完成目标
wal_buffers = 16MB                       -- WAL缓冲区
checkpoint_timeout = 10min               -- 检查点超时

-- 日志配置
log_destination = 'stderr'               -- 日志输出目标
logging_collector = on                   -- 启用日志收集器
log_directory = 'pg_log'                -- 日志目录
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'  -- 日志文件名
log_min_duration_statement = 1000       -- 记录慢查询（毫秒）
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

-- 统计配置
track_activities = on                    -- 跟踪活动
track_counts = on                       -- 跟踪计数
track_functions = all                   -- 跟踪函数
```

### Redis 优化

#### redis.conf 优化配置

```conf
# /config/redis.conf

# 内存配置
maxmemory 512mb                          # 最大内存使用
maxmemory-policy allkeys-lru             # 内存淘汰策略

# 持久化配置
save 900 1                              # 900秒内至少1个key变化时保存
save 300 10                             # 300秒内至少10个key变化时保存
save 60 10000                           # 60秒内至少10000个key变化时保存

# AOF配置
appendonly yes                          # 启用AOF持久化
appendfsync everysec                    # 每秒同步一次
no-appendfsync-on-rewrite no           # 重写时不停止同步

# 网络配置
tcp-keepalive 300                       # TCP保活时间
timeout 0                               # 客户端超时时间（0=不超时）

# 安全配置
requirepass your_redis_password_here    # 设置密码
rename-command FLUSHDB ""               # 禁用危险命令
rename-command FLUSHALL ""              # 禁用危险命令
rename-command CONFIG ""                # 禁用配置命令

# 性能配置
tcp-backlog 511                         # TCP监听队列长度
databases 16                            # 数据库数量
```

---

## 📊 监控配置

### Prometheus 配置

#### prometheus.yml 配置

```yaml
# /config/prometheus.yml
global:
  scrape_interval: 15s                  # 全局抓取间隔
  evaluation_interval: 15s              # 规则评估间隔

rule_files:
  - "alert_rules.yml"                   # 告警规则文件

scrape_configs:
  # N8N指标收集
  - job_name: 'n8n'
    static_configs:
      - targets: ['n8n:9090']
    scrape_interval: 30s
    metrics_path: /metrics
    
  # PostgreSQL指标收集
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
    
  # Redis指标收集
  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
    
  # 系统指标收集
  - job_name: 'node'
    static_configs:
      - targets: ['node-exporter:9100']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

### 告警规则

#### alert_rules.yml 配置

```yaml
# /config/alert_rules.yml
groups:
  - name: n8n_alerts
    rules:
      # N8N服务状态告警
      - alert: N8NServiceDown
        expr: up{job="n8n"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "N8N服务不可用"
          description: "N8N服务已停止运行超过1分钟"
      
      # 工作流执行失败告警
      - alert: WorkflowExecutionFailed
        expr: increase(n8n_workflow_executions_failed_total[5m]) > 5
        for: 0m
        labels:
          severity: warning
        annotations:
          summary: "工作流执行失败率过高"
          description: "5分钟内工作流执行失败次数超过5次"
      
      # 内存使用告警
      - alert: HighMemoryUsage
        expr: (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes > 0.9
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "内存使用率过高"
          description: "系统内存使用率超过90%"
      
      # 磁盘空间告警
      - alert: DiskSpaceLow
        expr: (node_filesystem_size_bytes - node_filesystem_free_bytes) / node_filesystem_size_bytes > 0.8
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "磁盘空间不足"
          description: "磁盘使用率超过80%"
      
      # 数据库连接告警
      - alert: DatabaseConnectionHigh
        expr: pg_stat_activity_count > 150
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "数据库连接数过高"
          description: "PostgreSQL活跃连接数超过150"

  - name: system_alerts
    rules:
      # CPU使用率告警
      - alert: HighCPUUsage
        expr: 100 - (avg by(instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "CPU使用率过高"
          description: "CPU使用率超过80%"
```

---

## 💾 备份配置

### 自动备份脚本

#### backup.sh 脚本配置

```bash
#!/bin/bash
# ===========================================
# N8N 自动备份脚本
# 功能：备份数据库、配置文件、工作流数据
# ===========================================

# 配置变量
BACKUP_DIR="/var/backups/n8n"
DATE=$(date +%Y%m%d_%H%M%S)
RETENTION_DAYS=30

# 创建备份目录
mkdir -p "${BACKUP_DIR}"

# 数据库备份
log_info "开始备份PostgreSQL数据库..."
docker-compose exec -T postgres pg_dump -U n8n n8n | gzip > "${BACKUP_DIR}/postgres_${DATE}.sql.gz"

# 工作流数据备份
log_info "开始备份N8N数据..."
docker-compose exec -T n8n tar -czf - /home/node/.n8n > "${BACKUP_DIR}/n8n_data_${DATE}.tar.gz"

# 配置文件备份
log_info "开始备份配置文件..."
tar -czf "${BACKUP_DIR}/config_${DATE}.tar.gz" .env docker-compose.yml config/

# 清理旧备份
log_info "清理${RETENTION_DAYS}天前的备份文件..."
find "${BACKUP_DIR}" -name "*.gz" -mtime +${RETENTION_DAYS} -delete

# 备份到远程存储（可选）
if [[ -n "${AWS_S3_BUCKET}" ]]; then
    log_info "上传备份到S3..."
    aws s3 sync "${BACKUP_DIR}" "s3://${AWS_S3_BUCKET}/n8n-backups/"
fi

log_success "备份完成：${BACKUP_DIR}"
```

### 恢复脚本

#### restore.sh 脚本配置

```bash
#!/bin/bash
# ===========================================
# N8N 数据恢复脚本
# 功能：从备份文件恢复系统数据
# ===========================================

# 参数检查
if [[ $# -ne 1 ]]; then
    echo "用法: $0 <备份日期>"
    echo "示例: $0 20240101_120000"
    exit 1
fi

BACKUP_DATE=$1
BACKUP_DIR="/var/backups/n8n"

# 检查备份文件
if [[ ! -f "${BACKUP_DIR}/postgres_${BACKUP_DATE}.sql.gz" ]]; then
    log_error "数据库备份文件不存在：${BACKUP_DIR}/postgres_${BACKUP_DATE}.sql.gz"
    exit 1
fi

# 停止服务
log_info "停止N8N服务..."
docker-compose down

# 恢复数据库
log_info "恢复PostgreSQL数据库..."
docker-compose up -d postgres
sleep 10
zcat "${BACKUP_DIR}/postgres_${BACKUP_DATE}.sql.gz" | docker-compose exec -T postgres psql -U n8n -d n8n

# 恢复N8N数据
if [[ -f "${BACKUP_DIR}/n8n_data_${BACKUP_DATE}.tar.gz" ]]; then
    log_info "恢复N8N数据..."
    docker-compose run --rm n8n tar -xzf - -C / < "${BACKUP_DIR}/n8n_data_${BACKUP_DATE}.tar.gz"
fi

# 恢复配置文件
if [[ -f "${BACKUP_DIR}/config_${BACKUP_DATE}.tar.gz" ]]; then
    log_info "恢复配置文件..."
    tar -xzf "${BACKUP_DIR}/config_${BACKUP_DATE}.tar.gz"
fi

# 启动服务
log_info "启动N8N服务..."
docker-compose up -d

log_success "数据恢复完成"
```

---

## 📝 总结

本配置文件详解涵盖了N8N系统的所有重要配置方面：

1. **Docker Compose配置**：完整的容器编排配置
2. **环境变量配置**：详细的参数说明和安全配置
3. **部署脚本配置**：自动化部署和配置生成
4. **安全配置**：SSL/TLS、防火墙、访问控制
5. **性能优化配置**：数据库和缓存优化
6. **监控配置**：Prometheus指标收集和告警
7. **备份配置**：自动备份和恢复策略

通过这些配置，你可以：
- 快速部署生产级N8N系统
- 确保系统安全性和稳定性
- 实现高性能和可扩展性
- 建立完善的监控和备份机制

建议根据实际环境需求调整相关参数，并定期更新配置以保持最佳性能。

---

*最后更新时间：2024年1月*
*版本：v1.0*