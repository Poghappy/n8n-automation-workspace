{
  "name": "ç»Ÿä¸€æ—¥å¿—è®°å½•èŠ‚ç‚¹é…ç½®",
  "description": "ä¸ºn8nå·¥ä½œæµæä¾›ç»Ÿä¸€çš„æ—¥å¿—è®°å½•ã€æ€§èƒ½ç›‘æ§å’Œé”™è¯¯å¤„ç†åŠŸèƒ½",
  "version": "1.0.0",
  "createdAt": "2025-08-23T14:30:00.000Z",
  
  "loggingNodes": {
    "description": "å„ç§æ—¥å¿—è®°å½•èŠ‚ç‚¹çš„é…ç½®",
    
    "workflowLogger": {
      "nodeId": "workflow-logger",
      "name": "å·¥ä½œæµæ—¥å¿—è®°å½•å™¨",
      "type": "n8n-nodes-base.function",
      "description": "è®°å½•å·¥ä½œæµæ‰§è¡Œçš„å…³é”®äº‹ä»¶å’ŒçŠ¶æ€å˜åŒ–",
      
      "parameters": {
        "functionCode": "// ç»Ÿä¸€å·¥ä½œæµæ—¥å¿—è®°å½•å™¨\nconst logLevel = process.env.WORKFLOW_LOG_LEVEL || 'info';\nconst enableStructuredLogging = process.env.ENABLE_STRUCTURED_LOGGING !== 'false';\nconst logDestination = process.env.LOG_DESTINATION || 'console';\n\n// æ—¥å¿—çº§åˆ«æ˜ å°„\nconst LOG_LEVELS = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3,\n  trace: 4\n};\n\n// è·å–å½“å‰æ—¥å¿—çº§åˆ«æ•°å€¼\nconst currentLogLevel = LOG_LEVELS[logLevel] || LOG_LEVELS.info;\n\n// æ—¥å¿—è®°å½•å‡½æ•°\nfunction log(level, category, message, metadata = {}) {\n  if (LOG_LEVELS[level] > currentLogLevel) {\n    return; // è·³è¿‡ä½äºå½“å‰çº§åˆ«çš„æ—¥å¿—\n  }\n  \n  const logEntry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    category: category,\n    executionId: $execution.id,\n    workflowId: $workflow.id,\n    workflowName: $workflow.name,\n    nodeId: $node.id || 'unknown',\n    nodeName: $node.name || 'unknown',\n    message: message,\n    metadata: {\n      ...metadata,\n      memoryUsage: process.memoryUsage ? process.memoryUsage() : null,\n      timestamp: Date.now()\n    }\n  };\n  \n  // æ•æ„Ÿæ•°æ®è„±æ•\n  if (logEntry.metadata) {\n    logEntry.metadata = sanitizeMetadata(logEntry.metadata);\n  }\n  \n  if (enableStructuredLogging) {\n    console.log(JSON.stringify(logEntry));\n  } else {\n    console.log(`[${logEntry.timestamp}] ${logEntry.level} [${logEntry.category}] ${logEntry.message}`);\n  }\n  \n  return logEntry;\n}\n\n// æ•æ„Ÿæ•°æ®è„±æ•å‡½æ•°\nfunction sanitizeMetadata(metadata) {\n  const sensitiveKeys = ['password', 'token', 'key', 'secret', 'credential', 'auth'];\n  const sanitized = { ...metadata };\n  \n  function sanitizeObject(obj) {\n    if (typeof obj !== 'object' || obj === null) return obj;\n    \n    const result = Array.isArray(obj) ? [] : {};\n    \n    for (const [key, value] of Object.entries(obj)) {\n      const lowerKey = key.toLowerCase();\n      const isSensitive = sensitiveKeys.some(sensitive => lowerKey.includes(sensitive));\n      \n      if (isSensitive && typeof value === 'string') {\n        result[key] = '***MASKED***';\n      } else if (typeof value === 'object' && value !== null) {\n        result[key] = sanitizeObject(value);\n      } else if (typeof value === 'string' && value.length > 1000) {\n        result[key] = value.substring(0, 1000) + '...[truncated]';\n      } else {\n        result[key] = value;\n      }\n    }\n    \n    return result;\n  }\n  \n  return sanitizeObject(sanitized);\n}\n\n// è·å–è¾“å…¥æ•°æ®\nconst inputData = $input.first()?.json || {};\nconst logCategory = inputData.logCategory || 'workflow';\nconst logMessage = inputData.logMessage || 'å·¥ä½œæµæ­¥éª¤æ‰§è¡Œ';\nconst logMetadata = inputData.logMetadata || {};\nconst logLevelOverride = inputData.logLevel || 'info';\n\n// æ€§èƒ½æŒ‡æ ‡æ”¶é›†\nconst performanceMetrics = {\n  nodeExecutionTime: Date.now() - ($execution.startedAt ? new Date($execution.startedAt).getTime() : Date.now()),\n  itemCount: $input.all().length,\n  dataSize: JSON.stringify($input.all()).length,\n  processingRate: $input.all().length / Math.max(1, (Date.now() - ($execution.startedAt ? new Date($execution.startedAt).getTime() : Date.now())) / 1000)\n};\n\n// è®°å½•æ—¥å¿—\nconst logEntry = log(logLevelOverride, logCategory, logMessage, {\n  ...logMetadata,\n  performanceMetrics,\n  inputDataSummary: {\n    itemCount: $input.all().length,\n    hasErrors: inputData.errors && inputData.errors.length > 0,\n    status: inputData.status || 'unknown'\n  }\n});\n\n// è¿”å›åŸå§‹æ•°æ®å’Œæ—¥å¿—ä¿¡æ¯\nreturn {\n  json: {\n    ...inputData,\n    logEntry: logEntry,\n    logged: true,\n    logTimestamp: new Date().toISOString()\n  }\n};"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "performanceMonitor": {
      "nodeId": "performance-monitor",
      "name": "æ€§èƒ½ç›‘æ§å™¨",
      "type": "n8n-nodes-base.function",
      "description": "æ”¶é›†å’Œåˆ†æå·¥ä½œæµæ€§èƒ½æŒ‡æ ‡",
      
      "parameters": {
        "functionCode": "// æ€§èƒ½ç›‘æ§å’ŒæŒ‡æ ‡æ”¶é›†å™¨\nconst startTime = Date.now();\nconst inputData = $input.first()?.json || {};\nconst previousMetrics = inputData.performanceMetrics || {};\n\n// ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡æ”¶é›†\nfunction collectSystemMetrics() {\n  const memUsage = process.memoryUsage ? process.memoryUsage() : {};\n  \n  return {\n    memory: {\n      rss: memUsage.rss || 0,\n      heapTotal: memUsage.heapTotal || 0,\n      heapUsed: memUsage.heapUsed || 0,\n      external: memUsage.external || 0,\n      arrayBuffers: memUsage.arrayBuffers || 0,\n      heapUsagePercent: memUsage.heapTotal ? (memUsage.heapUsed / memUsage.heapTotal * 100) : 0\n    },\n    process: {\n      uptime: process.uptime ? process.uptime() : 0,\n      pid: process.pid || 0,\n      platform: process.platform || 'unknown',\n      nodeVersion: process.version || 'unknown'\n    },\n    timestamp: Date.now()\n  };\n}\n\n// å·¥ä½œæµæ€§èƒ½æŒ‡æ ‡è®¡ç®—\nfunction calculateWorkflowMetrics() {\n  const executionStartTime = $execution.startedAt ? new Date($execution.startedAt).getTime() : startTime;\n  const currentTime = Date.now();\n  const totalExecutionTime = currentTime - executionStartTime;\n  \n  const itemCount = $input.all().length;\n  const dataSize = JSON.stringify($input.all()).length;\n  \n  return {\n    execution: {\n      totalTime: totalExecutionTime,\n      currentStepTime: currentTime - (previousMetrics.lastStepTime || executionStartTime),\n      itemsProcessed: itemCount,\n      dataSize: dataSize,\n      throughput: itemCount / Math.max(1, totalExecutionTime / 1000),\n      averageItemSize: itemCount > 0 ? dataSize / itemCount : 0\n    },\n    workflow: {\n      executionId: $execution.id,\n      workflowId: $workflow.id,\n      workflowName: $workflow.name,\n      nodeId: $node.id || 'unknown',\n      nodeName: $node.name || 'unknown'\n    },\n    quality: {\n      errorCount: (inputData.errors && inputData.errors.length) || 0,\n      successRate: itemCount > 0 ? ((itemCount - ((inputData.errors && inputData.errors.length) || 0)) / itemCount * 100) : 100,\n      averageQualityScore: inputData.averageQualityScore || 0\n    }\n  };\n}\n\n// APIæ€§èƒ½æŒ‡æ ‡æ”¶é›†\nfunction collectApiMetrics() {\n  const apiCalls = inputData.apiCalls || [];\n  \n  if (apiCalls.length === 0) {\n    return {\n      totalCalls: 0,\n      averageResponseTime: 0,\n      successRate: 100,\n      errorRate: 0\n    };\n  }\n  \n  const totalResponseTime = apiCalls.reduce((sum, call) => sum + (call.responseTime || 0), 0);\n  const successfulCalls = apiCalls.filter(call => call.success).length;\n  \n  return {\n    totalCalls: apiCalls.length,\n    averageResponseTime: totalResponseTime / apiCalls.length,\n    successRate: (successfulCalls / apiCalls.length) * 100,\n    errorRate: ((apiCalls.length - successfulCalls) / apiCalls.length) * 100,\n    slowestCall: Math.max(...apiCalls.map(call => call.responseTime || 0)),\n    fastestCall: Math.min(...apiCalls.map(call => call.responseTime || Infinity))\n  };\n}\n\n// æ€§èƒ½é˜ˆå€¼æ£€æŸ¥\nfunction checkPerformanceThresholds(metrics) {\n  const thresholds = {\n    executionTime: {\n      warning: 180000, // 3åˆ†é’Ÿ\n      critical: 300000 // 5åˆ†é’Ÿ\n    },\n    memoryUsage: {\n      warning: 80, // 80%\n      critical: 95  // 95%\n    },\n    throughput: {\n      warning: 5,  // 5 items/second\n      critical: 1  // 1 item/second\n    },\n    errorRate: {\n      warning: 5,  // 5%\n      critical: 10 // 10%\n    }\n  };\n  \n  const alerts = [];\n  \n  // æ£€æŸ¥æ‰§è¡Œæ—¶é—´\n  if (metrics.execution.totalTime > thresholds.executionTime.critical) {\n    alerts.push({\n      type: 'critical',\n      metric: 'execution_time',\n      value: metrics.execution.totalTime,\n      threshold: thresholds.executionTime.critical,\n      message: `å·¥ä½œæµæ‰§è¡Œæ—¶é—´è¶…è¿‡ä¸´ç•Œå€¼: ${Math.round(metrics.execution.totalTime/1000)}ç§’`\n    });\n  } else if (metrics.execution.totalTime > thresholds.executionTime.warning) {\n    alerts.push({\n      type: 'warning',\n      metric: 'execution_time',\n      value: metrics.execution.totalTime,\n      threshold: thresholds.executionTime.warning,\n      message: `å·¥ä½œæµæ‰§è¡Œæ—¶é—´è¶…è¿‡è­¦å‘Šå€¼: ${Math.round(metrics.execution.totalTime/1000)}ç§’`\n    });\n  }\n  \n  // æ£€æŸ¥å†…å­˜ä½¿ç”¨\n  const memoryUsagePercent = metrics.system?.memory?.heapUsagePercent || 0;\n  if (memoryUsagePercent > thresholds.memoryUsage.critical) {\n    alerts.push({\n      type: 'critical',\n      metric: 'memory_usage',\n      value: memoryUsagePercent,\n      threshold: thresholds.memoryUsage.critical,\n      message: `å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡ä¸´ç•Œå€¼: ${Math.round(memoryUsagePercent)}%`\n    });\n  } else if (memoryUsagePercent > thresholds.memoryUsage.warning) {\n    alerts.push({\n      type: 'warning',\n      metric: 'memory_usage',\n      value: memoryUsagePercent,\n      threshold: thresholds.memoryUsage.warning,\n      message: `å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡è­¦å‘Šå€¼: ${Math.round(memoryUsagePercent)}%`\n    });\n  }\n  \n  // æ£€æŸ¥é”™è¯¯ç‡\n  const errorRate = metrics.quality?.errorCount > 0 ? (metrics.quality.errorCount / metrics.execution.itemsProcessed * 100) : 0;\n  if (errorRate > thresholds.errorRate.critical) {\n    alerts.push({\n      type: 'critical',\n      metric: 'error_rate',\n      value: errorRate,\n      threshold: thresholds.errorRate.critical,\n      message: `é”™è¯¯ç‡è¶…è¿‡ä¸´ç•Œå€¼: ${Math.round(errorRate)}%`\n    });\n  } else if (errorRate > thresholds.errorRate.warning) {\n    alerts.push({\n      type: 'warning',\n      metric: 'error_rate',\n      value: errorRate,\n      threshold: thresholds.errorRate.warning,\n      message: `é”™è¯¯ç‡è¶…è¿‡è­¦å‘Šå€¼: ${Math.round(errorRate)}%`\n    });\n  }\n  \n  return alerts;\n}\n\n// æ”¶é›†æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡\nconst systemMetrics = collectSystemMetrics();\nconst workflowMetrics = calculateWorkflowMetrics();\nconst apiMetrics = collectApiMetrics();\n\n// åˆå¹¶æ€§èƒ½æŒ‡æ ‡\nconst allMetrics = {\n  system: systemMetrics,\n  workflow: workflowMetrics,\n  api: apiMetrics,\n  collection: {\n    timestamp: Date.now(),\n    collectionTime: Date.now() - startTime,\n    lastStepTime: Date.now()\n  }\n};\n\n// æ£€æŸ¥æ€§èƒ½é˜ˆå€¼\nconst performanceAlerts = checkPerformanceThresholds({\n  execution: workflowMetrics.execution,\n  system: systemMetrics,\n  quality: workflowMetrics.quality\n});\n\n// ç”Ÿæˆæ€§èƒ½æ‘˜è¦\nconst performanceSummary = {\n  status: performanceAlerts.some(alert => alert.type === 'critical') ? 'critical' : \n          performanceAlerts.some(alert => alert.type === 'warning') ? 'warning' : 'healthy',\n  executionTime: workflowMetrics.execution.totalTime,\n  memoryUsage: systemMetrics.memory.heapUsagePercent,\n  throughput: workflowMetrics.execution.throughput,\n  errorRate: workflowMetrics.quality.errorCount > 0 ? \n    (workflowMetrics.quality.errorCount / workflowMetrics.execution.itemsProcessed * 100) : 0,\n  alertCount: performanceAlerts.length\n};\n\n// è®°å½•æ€§èƒ½æ—¥å¿—\nconsole.log('ğŸ“Š æ€§èƒ½ç›‘æ§æŠ¥å‘Š:', JSON.stringify({\n  timestamp: new Date().toISOString(),\n  executionId: $execution.id,\n  summary: performanceSummary,\n  alerts: performanceAlerts.length > 0 ? performanceAlerts : undefined\n}));\n\n// è¿”å›å¢å¼ºçš„æ•°æ®\nreturn {\n  json: {\n    ...inputData,\n    performanceMetrics: allMetrics,\n    performanceAlerts: performanceAlerts,\n    performanceSummary: performanceSummary,\n    monitoringTimestamp: new Date().toISOString()\n  }\n};"
      },
      
      "settings": {
        "continueOnFail": true,\n        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "errorHandler": {
      "nodeId": "error-handler",
      "name": "é”™è¯¯å¤„ç†å’Œå‘Šè­¦",
      "type": "n8n-nodes-base.function",
      "description": "ç»Ÿä¸€çš„é”™è¯¯å¤„ç†ã€åˆ†ç±»å’Œå‘Šè­¦æœºåˆ¶",
      
      "parameters": {
        "functionCode": "// ç»Ÿä¸€é”™è¯¯å¤„ç†å’Œå‘Šè­¦ç³»ç»Ÿ\nconst inputData = $input.first()?.json || {};\nconst error = inputData.error || $execution.lastNodeExecuted?.error;\nconst enableAlerts = process.env.ENABLE_ERROR_ALERTS !== 'false';\nconst webhookUrl = process.env.WEBHOOK_ALERT_URL;\n\n// é”™è¯¯åˆ†ç±»\nfunction classifyError(error) {\n  if (!error) return { category: 'unknown', severity: 'low' };\n  \n  const errorMessage = error.message || error.toString() || '';\n  const errorStack = error.stack || '';\n  \n  // ç½‘ç»œé”™è¯¯\n  if (errorMessage.includes('timeout') || errorMessage.includes('ECONNRESET') || \n      errorMessage.includes('ENOTFOUND') || errorMessage.includes('network')) {\n    return {\n      category: 'network',\n      severity: 'medium',\n      retryable: true,\n      description: 'ç½‘ç»œè¿æ¥é”™è¯¯'\n    };\n  }\n  \n  // è®¤è¯é”™è¯¯\n  if (errorMessage.includes('401') || errorMessage.includes('403') || \n      errorMessage.includes('unauthorized') || errorMessage.includes('authentication')) {\n    return {\n      category: 'authentication',\n      severity: 'high',\n      retryable: false,\n      description: 'APIè®¤è¯å¤±è´¥'\n    };\n  }\n  \n  // é™æµé”™è¯¯\n  if (errorMessage.includes('429') || errorMessage.includes('rate limit') || \n      errorMessage.includes('too many requests')) {\n    return {\n      category: 'rate_limit',\n      severity: 'medium',\n      retryable: true,\n      description: 'APIè¯·æ±‚é¢‘ç‡é™åˆ¶'\n    };\n  }\n  \n  // æ•°æ®éªŒè¯é”™è¯¯\n  if (errorMessage.includes('validation') || errorMessage.includes('invalid') || \n      errorMessage.includes('required field')) {\n    return {\n      category: 'validation',\n      severity: 'medium',\n      retryable: false,\n      description: 'æ•°æ®éªŒè¯å¤±è´¥'\n    };\n  }\n  \n  // æœåŠ¡å™¨é”™è¯¯\n  if (errorMessage.includes('500') || errorMessage.includes('502') || \n      errorMessage.includes('503') || errorMessage.includes('504')) {\n    return {\n      category: 'server_error',\n      severity: 'high',\n      retryable: true,\n      description: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'\n    };\n  }\n  \n  // å†…å®¹å¤„ç†é”™è¯¯\n  if (errorMessage.includes('content') || errorMessage.includes('processing') || \n      errorMessage.includes('parsing')) {\n    return {\n      category: 'content_processing',\n      severity: 'low',\n      retryable: false,\n      description: 'å†…å®¹å¤„ç†é”™è¯¯'\n    };\n  }\n  \n  // é»˜è®¤åˆ†ç±»\n  return {\n    category: 'unknown',\n    severity: 'medium',\n    retryable: false,\n    description: 'æœªçŸ¥é”™è¯¯ç±»å‹'\n  };\n}\n\n// ç”Ÿæˆé”™è¯¯æŠ¥å‘Š\nfunction generateErrorReport(error, classification) {\n  return {\n    errorId: `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    timestamp: new Date().toISOString(),\n    executionId: $execution.id,\n    workflowId: $workflow.id,\n    workflowName: $workflow.name,\n    nodeId: $node.id || 'unknown',\n    nodeName: $node.name || 'unknown',\n    \n    error: {\n      message: error?.message || 'Unknown error',\n      stack: error?.stack || '',\n      code: error?.code || '',\n      type: error?.constructor?.name || 'Error'\n    },\n    \n    classification: classification,\n    \n    context: {\n      inputDataSize: JSON.stringify(inputData).length,\n      hasInputData: Object.keys(inputData).length > 0,\n      executionContext: {\n        mode: $execution.mode,\n        startedAt: $execution.startedAt,\n        resumeUrl: $execution.resumeUrl\n      }\n    },\n    \n    systemInfo: {\n      memoryUsage: process.memoryUsage ? process.memoryUsage() : {},\n      uptime: process.uptime ? process.uptime() : 0,\n      platform: process.platform || 'unknown'\n    },\n    \n    troubleshooting: generateTroubleshootingTips(classification)\n  };\n}\n\n// ç”Ÿæˆæ•…éšœæ’é™¤å»ºè®®\nfunction generateTroubleshootingTips(classification) {\n  const tips = {\n    network: [\n      'æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸',\n      'éªŒè¯ç›®æ ‡æœåŠ¡æ˜¯å¦å¯è®¿é—®',\n      'è€ƒè™‘å¢åŠ è¶…æ—¶æ—¶é—´',\n      'æ£€æŸ¥é˜²ç«å¢™è®¾ç½®'\n    ],\n    authentication: [\n      'éªŒè¯APIå¯†é’¥æ˜¯å¦æ­£ç¡®',\n      'æ£€æŸ¥APIå¯†é’¥æ˜¯å¦è¿‡æœŸ',\n      'ç¡®è®¤APIæƒé™è®¾ç½®',\n      'æ£€æŸ¥è®¤è¯å¤´æ ¼å¼'\n    ],\n    rate_limit: [\n      'å‡å°‘APIè°ƒç”¨é¢‘ç‡',\n      'å®æ–½æŒ‡æ•°é€€é¿é‡è¯•',\n      'è€ƒè™‘å‡çº§APIå¥—é¤',\n      'åˆ†æ‰¹å¤„ç†æ•°æ®'\n    ],\n    validation: [\n      'æ£€æŸ¥è¾“å…¥æ•°æ®æ ¼å¼',\n      'éªŒè¯å¿…å¡«å­—æ®µ',\n      'ç¡®è®¤æ•°æ®ç±»å‹æ­£ç¡®',\n      'æ£€æŸ¥å­—æ®µé•¿åº¦é™åˆ¶'\n    ],\n    server_error: [\n      'ç¨åé‡è¯•æ“ä½œ',\n      'æ£€æŸ¥æœåŠ¡çŠ¶æ€é¡µé¢',\n      'è”ç³»æœåŠ¡æä¾›å•†',\n      'å®æ–½é‡è¯•æœºåˆ¶'\n    ],\n    content_processing: [\n      'æ£€æŸ¥å†…å®¹æ ¼å¼',\n      'éªŒè¯å†…å®¹å®Œæ•´æ€§',\n      'è°ƒæ•´å¤„ç†å‚æ•°',\n      'è·³è¿‡é—®é¢˜å†…å®¹'\n    ]\n  };\n  \n  return tips[classification.category] || [\n    'æ£€æŸ¥é”™è¯¯æ—¥å¿—è¯¦æƒ…',\n    'éªŒè¯è¾“å…¥æ•°æ®',\n    'è”ç³»æŠ€æœ¯æ”¯æŒ',\n    'æŸ¥çœ‹ç›¸å…³æ–‡æ¡£'\n  ];\n}\n\n// å‘é€å‘Šè­¦é€šçŸ¥\nasync function sendAlert(errorReport) {\n  if (!enableAlerts || !webhookUrl) {\n    console.log('âš ï¸ å‘Šè­¦åŠŸèƒ½æœªå¯ç”¨æˆ–æœªé…ç½®Webhook URL');\n    return false;\n  }\n  \n  try {\n    const alertPayload = {\n      type: 'error_alert',\n      severity: errorReport.classification.severity,\n      title: `å·¥ä½œæµé”™è¯¯: ${errorReport.error.message}`,\n      description: errorReport.classification.description,\n      details: {\n        workflowName: errorReport.workflowName,\n        nodeName: errorReport.nodeName,\n        errorCategory: errorReport.classification.category,\n        timestamp: errorReport.timestamp,\n        executionId: errorReport.executionId\n      },\n      troubleshooting: errorReport.troubleshooting,\n      metadata: {\n        retryable: errorReport.classification.retryable,\n        errorId: errorReport.errorId\n      }\n    };\n    \n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(alertPayload),\n      timeout: 10000\n    });\n    \n    if (response.ok) {\n      console.log('âœ… é”™è¯¯å‘Šè­¦å‘é€æˆåŠŸ');\n      return true;\n    } else {\n      console.error('âŒ é”™è¯¯å‘Šè­¦å‘é€å¤±è´¥:', response.status, response.statusText);\n      return false;\n    }\n  } catch (alertError) {\n    console.error('âŒ å‘é€å‘Šè­¦æ—¶å‡ºé”™:', alertError.message);\n    return false;\n  }\n}\n\n// å¤„ç†é”™è¯¯\nif (error || inputData.status === 'error') {\n  const classification = classifyError(error);\n  const errorReport = generateErrorReport(error, classification);\n  \n  // è®°å½•é”™è¯¯æ—¥å¿—\n  console.error('ğŸš¨ å·¥ä½œæµé”™è¯¯æŠ¥å‘Š:', JSON.stringify({\n    errorId: errorReport.errorId,\n    category: classification.category,\n    severity: classification.severity,\n    message: errorReport.error.message,\n    retryable: classification.retryable,\n    troubleshooting: errorReport.troubleshooting.slice(0, 2)\n  }));\n  \n  // å‘é€å‘Šè­¦ï¼ˆå¼‚æ­¥ï¼‰\n  if (classification.severity === 'high' || classification.severity === 'critical') {\n    sendAlert(errorReport).catch(err => {\n      console.error('å‘Šè­¦å‘é€å¤±è´¥:', err.message);\n    });\n  }\n  \n  return {\n    json: {\n      status: 'error_handled',\n      errorReport: errorReport,\n      originalData: inputData,\n      shouldRetry: classification.retryable,\n      skipToEnd: !classification.retryable,\n      timestamp: new Date().toISOString()\n    }\n  };\n} else {\n  // æ²¡æœ‰é”™è¯¯ï¼Œç›´æ¥ä¼ é€’æ•°æ®\n  return {\n    json: {\n      ...inputData,\n      errorHandlingChecked: true,\n      timestamp: new Date().toISOString()\n    }\n  };\n}"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "executionReporter": {
      "nodeId": "execution-reporter",
      "name": "æ‰§è¡ŒæŠ¥å‘Šç”Ÿæˆå™¨",
      "type": "n8n-nodes-base.function",
      "description": "ç”Ÿæˆè¯¦ç»†çš„å·¥ä½œæµæ‰§è¡ŒæŠ¥å‘Šå’Œç»Ÿè®¡ä¿¡æ¯",
      
      "parameters": {
        "functionCode": "// å·¥ä½œæµæ‰§è¡ŒæŠ¥å‘Šç”Ÿæˆå™¨\nconst fs = require('fs').promises;\nconst path = require('path');\n\nconst inputData = $input.first()?.json || {};\nconst workflowStatus = inputData.workflowStatus || {};\nconst performanceMetrics = inputData.performanceMetrics || {};\nconst enableReportGeneration = process.env.ENABLE_EXECUTION_REPORTS !== 'false';\nconst reportStoragePath = process.env.REPORT_STORAGE_PATH || './logs/execution-reports';\n\n// ç”Ÿæˆæ‰§è¡Œæ‘˜è¦\nfunction generateExecutionSummary() {\n  const startTime = workflowStatus.startTime || Date.now();\n  const endTime = Date.now();\n  const duration = endTime - startTime;\n  \n  return {\n    executionId: $execution.id,\n    workflowId: $workflow.id,\n    workflowName: $workflow.name,\n    startTime: new Date(startTime).toISOString(),\n    endTime: new Date(endTime).toISOString(),\n    duration: duration,\n    durationFormatted: formatDuration(duration),\n    status: inputData.status || 'completed',\n    \n    itemsProcessed: {\n      total: inputData.totalItems || 0,\n      successful: inputData.successfulItems || 0,\n      failed: inputData.failedItems || 0,\n      skipped: inputData.skippedItems || 0\n    },\n    \n    phases: {\n      dataCollection: workflowStatus.rssCollection || {},\n      contentProcessing: workflowStatus.contentProcessing || {},\n      notionStorage: workflowStatus.notionStorage || {},\n      aiManagement: workflowStatus.aiManagement || {},\n      firebirdPublish: workflowStatus.firebirdPublish || {}\n    }\n  };\n}\n\n// ç”Ÿæˆæ€§èƒ½åˆ†ææŠ¥å‘Š\nfunction generatePerformanceAnalysis() {\n  const execution = performanceMetrics.workflow?.execution || {};\n  const system = performanceMetrics.system || {};\n  const api = performanceMetrics.api || {};\n  \n  return {\n    executionPerformance: {\n      totalExecutionTime: execution.totalTime || 0,\n      averageItemProcessingTime: execution.itemsProcessed > 0 ? \n        (execution.totalTime / execution.itemsProcessed) : 0,\n      throughput: execution.throughput || 0,\n      dataProcessingRate: execution.dataSize > 0 ? \n        (execution.dataSize / Math.max(1, execution.totalTime / 1000)) : 0\n    },\n    \n    systemPerformance: {\n      memoryUsage: {\n        peak: system.memory?.heapUsed || 0,\n        average: system.memory?.heapUsed || 0,\n        efficiency: system.memory?.heapTotal > 0 ? \n          (system.memory.heapUsed / system.memory.heapTotal * 100) : 0\n      },\n      processUptime: system.process?.uptime || 0\n    },\n    \n    apiPerformance: {\n      totalApiCalls: api.totalCalls || 0,\n      averageResponseTime: api.averageResponseTime || 0,\n      apiSuccessRate: api.successRate || 100,\n      slowestApiCall: api.slowestCall || 0,\n      fastestApiCall: api.fastestCall || 0\n    },\n    \n    bottlenecks: identifyBottlenecks(execution, system, api),\n    recommendations: generatePerformanceRecommendations(execution, system, api)\n  };\n}\n\n// è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ\nfunction identifyBottlenecks(execution, system, api) {\n  const bottlenecks = [];\n  \n  // æ‰§è¡Œæ—¶é—´ç“¶é¢ˆ\n  if (execution.totalTime > 300000) { // 5åˆ†é’Ÿ\n    bottlenecks.push({\n      type: 'execution_time',\n      severity: 'high',\n      description: 'å·¥ä½œæµæ‰§è¡Œæ—¶é—´è¿‡é•¿',\n      value: execution.totalTime,\n      threshold: 300000\n    });\n  }\n  \n  // å†…å­˜ä½¿ç”¨ç“¶é¢ˆ\n  if (system.memory?.heapUsagePercent > 80) {\n    bottlenecks.push({\n      type: 'memory_usage',\n      severity: 'medium',\n      description: 'å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜',\n      value: system.memory.heapUsagePercent,\n      threshold: 80\n    });\n  }\n  \n  // APIå“åº”æ—¶é—´ç“¶é¢ˆ\n  if (api.averageResponseTime > 5000) {\n    bottlenecks.push({\n      type: 'api_response_time',\n      severity: 'medium',\n      description: 'APIå“åº”æ—¶é—´è¿‡é•¿',\n      value: api.averageResponseTime,\n      threshold: 5000\n    });\n  }\n  \n  // ååé‡ç“¶é¢ˆ\n  if (execution.throughput < 1) {\n    bottlenecks.push({\n      type: 'throughput',\n      severity: 'low',\n      description: 'æ•°æ®å¤„ç†ååé‡è¾ƒä½',\n      value: execution.throughput,\n      threshold: 1\n    });\n  }\n  \n  return bottlenecks;\n}\n\n// ç”Ÿæˆæ€§èƒ½ä¼˜åŒ–å»ºè®®\nfunction generatePerformanceRecommendations(execution, system, api) {\n  const recommendations = [];\n  \n  // æ‰§è¡Œæ—¶é—´ä¼˜åŒ–\n  if (execution.totalTime > 180000) {\n    recommendations.push({\n      category: 'execution_optimization',\n      priority: 'high',\n      suggestion: 'è€ƒè™‘å¹¶è¡Œå¤„ç†æ•°æ®æˆ–ä¼˜åŒ–å¤„ç†é€»è¾‘',\n      expectedImprovement: 'å‡å°‘30-50%æ‰§è¡Œæ—¶é—´'\n    });\n  }\n  \n  // å†…å­˜ä¼˜åŒ–\n  if (system.memory?.heapUsagePercent > 70) {\n    recommendations.push({\n      category: 'memory_optimization',\n      priority: 'medium',\n      suggestion: 'å®æ–½æ•°æ®æµå¤„ç†ï¼Œé¿å…å¤§é‡æ•°æ®åŒæ—¶åŠ è½½åˆ°å†…å­˜',\n      expectedImprovement: 'å‡å°‘40-60%å†…å­˜ä½¿ç”¨'\n    });\n  }\n  \n  // APIä¼˜åŒ–\n  if (api.averageResponseTime > 3000) {\n    recommendations.push({\n      category: 'api_optimization',\n      priority: 'medium',\n      suggestion: 'å®æ–½APIè¯·æ±‚ç¼“å­˜æˆ–å¢åŠ å¹¶å‘è¯·æ±‚æ•°',\n      expectedImprovement: 'æå‡20-40%APIå“åº”é€Ÿåº¦'\n    });\n  }\n  \n  // æ•°æ®å¤„ç†ä¼˜åŒ–\n  if (execution.throughput < 2) {\n    recommendations.push({\n      category: 'throughput_optimization',\n      priority: 'low',\n      suggestion: 'ä¼˜åŒ–æ•°æ®å¤„ç†ç®—æ³•æˆ–å¢åŠ æ‰¹å¤„ç†å¤§å°',\n      expectedImprovement: 'æå‡50-100%å¤„ç†ååé‡'\n    });\n  }\n  \n  return recommendations;\n}\n\n// ç”Ÿæˆå†…å®¹åˆ†ææŠ¥å‘Š\nfunction generateContentAnalysis() {\n  const sourceStats = inputData.sourceStats || [];\n  const qualityStats = inputData.qualityStats || {};\n  \n  return {\n    sourceAnalysis: {\n      totalSources: sourceStats.length,\n      successfulSources: sourceStats.filter(s => s.status === 'success').length,\n      failedSources: sourceStats.filter(s => s.status === 'failed').length,\n      sourceBreakdown: sourceStats.map(source => ({\n        name: source.source,\n        status: source.status,\n        itemCount: source.itemCount,\n        processingTime: source.processingTime,\n        successRate: source.itemCount > 0 ? 100 : 0\n      }))\n    },\n    \n    qualityAnalysis: {\n      averageQualityScore: qualityStats.averageQualityScore || 0,\n      qualityDistribution: calculateQualityDistribution(inputData.items || []),\n      contentCompleteness: {\n        itemsWithImages: qualityStats.itemsWithImages || 0,\n        itemsWithAuthors: qualityStats.itemsWithAuthors || 0,\n        averageContentLength: qualityStats.averageContentLength || 0\n      }\n    },\n    \n    processingResults: {\n      duplicatesDetected: inputData.duplicatesRemoved || 0,\n      itemsRejected: inputData.rejectedItems || 0,\n      aiEnhancedItems: inputData.aiEnhancedItems || 0,\n      publishedItems: inputData.publishedItems || 0\n    }\n  };\n}\n\n// è®¡ç®—è´¨é‡åˆ†æ•°åˆ†å¸ƒ\nfunction calculateQualityDistribution(items) {\n  const distribution = {\n    excellent: 0, // 90-100\n    good: 0,      // 70-89\n    fair: 0,      // 50-69\n    poor: 0       // 0-49\n  };\n  \n  items.forEach(item => {\n    const score = item.quality_score || item.validationScore || 0;\n    if (score >= 90) distribution.excellent++;\n    else if (score >= 70) distribution.good++;\n    else if (score >= 50) distribution.fair++;\n    else distribution.poor++;\n  });\n  \n  return distribution;\n}\n\n// ç”Ÿæˆé”™è¯¯åˆ†ææŠ¥å‘Š\nfunction generateErrorAnalysis() {\n  const errors = inputData.errors || [];\n  const performanceAlerts = inputData.performanceAlerts || [];\n  \n  const errorsByCategory = {};\n  const errorsByNode = {};\n  \n  errors.forEach(error => {\n    const category = error.type || 'unknown';\n    const node = error.source || 'unknown';\n    \n    errorsByCategory[category] = (errorsByCategory[category] || 0) + 1;\n    errorsByNode[node] = (errorsByNode[node] || 0) + 1;\n  });\n  \n  return {\n    errorSummary: {\n      totalErrors: errors.length,\n      errorRate: inputData.totalItems > 0 ? (errors.length / inputData.totalItems * 100) : 0,\n      criticalErrors: errors.filter(e => e.severity === 'critical').length,\n      recoverableErrors: errors.filter(e => e.retryable).length\n    },\n    \n    errorBreakdown: {\n      byCategory: errorsByCategory,\n      byNode: errorsByNode,\n      topErrors: errors.slice(0, 5).map(error => ({\n        message: error.error || error.message,\n        category: error.type,\n        timestamp: error.timestamp,\n        node: error.source\n      }))\n    },\n    \n    performanceIssues: {\n      totalAlerts: performanceAlerts.length,\n      criticalAlerts: performanceAlerts.filter(a => a.type === 'critical').length,\n      warningAlerts: performanceAlerts.filter(a => a.type === 'warning').length,\n      alertBreakdown: performanceAlerts.reduce((acc, alert) => {\n        acc[alert.metric] = (acc[alert.metric] || 0) + 1;\n        return acc;\n      }, {})\n    }\n  };\n}\n\n// æ ¼å¼åŒ–æŒç»­æ—¶é—´\nfunction formatDuration(milliseconds) {\n  const seconds = Math.floor(milliseconds / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  \n  if (hours > 0) {\n    return `${hours}å°æ—¶${minutes % 60}åˆ†é’Ÿ${seconds % 60}ç§’`;\n  } else if (minutes > 0) {\n    return `${minutes}åˆ†é’Ÿ${seconds % 60}ç§’`;\n  } else {\n    return `${seconds}ç§’`;\n  }\n}\n\n// ç”Ÿæˆå®Œæ•´æŠ¥å‘Š\nfunction generateCompleteReport() {\n  return {\n    reportMetadata: {\n      reportId: `report_${$execution.id}_${Date.now()}`,\n      generatedAt: new Date().toISOString(),\n      reportVersion: '1.0.0',\n      executionId: $execution.id,\n      workflowName: $workflow.name\n    },\n    \n    executionSummary: generateExecutionSummary(),\n    performanceAnalysis: generatePerformanceAnalysis(),\n    contentAnalysis: generateContentAnalysis(),\n    errorAnalysis: generateErrorAnalysis(),\n    \n    recommendations: {\n      immediate: [\n        'æ£€æŸ¥å¹¶ä¼˜åŒ–æ€§èƒ½ç“¶é¢ˆ',\n        'å¤„ç†å…³é”®é”™è¯¯å’Œå‘Šè­¦',\n        'éªŒè¯å†…å®¹è´¨é‡æŒ‡æ ‡'\n      ],\n      shortTerm: [\n        'å®æ–½æ€§èƒ½ä¼˜åŒ–å»ºè®®',\n        'æ”¹è¿›é”™è¯¯å¤„ç†æœºåˆ¶',\n        'ä¼˜åŒ–å†…å®¹å¤„ç†æµç¨‹'\n      ],\n      longTerm: [\n        'è€ƒè™‘æ¶æ„ä¼˜åŒ–',\n        'å®æ–½é¢„æµ‹æ€§ç›‘æ§',\n        'å»ºç«‹æ€§èƒ½åŸºå‡†'\n      ]\n    }\n  };\n}\n\n// ä¿å­˜æŠ¥å‘Šåˆ°æ–‡ä»¶\nasync function saveReportToFile(report) {\n  if (!enableReportGeneration) {\n    return null;\n  }\n  \n  try {\n    // ç¡®ä¿æŠ¥å‘Šç›®å½•å­˜åœ¨\n    await fs.mkdir(reportStoragePath, { recursive: true });\n    \n    const fileName = `execution-report-${$execution.id}-${Date.now()}.json`;\n    const filePath = path.join(reportStoragePath, fileName);\n    \n    await fs.writeFile(filePath, JSON.stringify(report, null, 2), 'utf8');\n    \n    console.log(`ğŸ“„ æ‰§è¡ŒæŠ¥å‘Šå·²ä¿å­˜: ${filePath}`);\n    return filePath;\n  } catch (error) {\n    console.error('âŒ ä¿å­˜æ‰§è¡ŒæŠ¥å‘Šå¤±è´¥:', error.message);\n    return null;\n  }\n}\n\n// ç”Ÿæˆå¹¶ä¿å­˜æŠ¥å‘Š\nconst completeReport = generateCompleteReport();\nconst reportFilePath = await saveReportToFile(completeReport);\n\n// ç”ŸæˆæŠ¥å‘Šæ‘˜è¦ç”¨äºæ—¥å¿—\nconst reportSummary = {\n  executionId: completeReport.reportMetadata.executionId,\n  duration: completeReport.executionSummary.durationFormatted,\n  status: completeReport.executionSummary.status,\n  itemsProcessed: completeReport.executionSummary.itemsProcessed.total,\n  successRate: completeReport.executionSummary.itemsProcessed.total > 0 ? \n    (completeReport.executionSummary.itemsProcessed.successful / completeReport.executionSummary.itemsProcessed.total * 100) : 100,\n  errorCount: completeReport.errorAnalysis.errorSummary.totalErrors,\n  performanceStatus: completeReport.performanceAnalysis.bottlenecks.length > 0 ? 'issues_detected' : 'healthy',\n  reportPath: reportFilePath\n};\n\nconsole.log('ğŸ“Š å·¥ä½œæµæ‰§è¡ŒæŠ¥å‘Šæ‘˜è¦:', JSON.stringify(reportSummary));\n\n// è¿”å›æŠ¥å‘Šæ•°æ®\nreturn {\n  json: {\n    ...inputData,\n    executionReport: completeReport,\n    reportSummary: reportSummary,\n    reportGenerated: true,\n    reportPath: reportFilePath,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    }
  },
  
  "nodeConnections": {
    "description": "æ—¥å¿—è®°å½•èŠ‚ç‚¹ä¹‹é—´çš„è¿æ¥é…ç½®",
    
    "standardFlow": {
      "description": "æ ‡å‡†çš„æ—¥å¿—è®°å½•æµç¨‹",
      "connections": [
        {
          "from": "any-node",
          "to": "workflow-logger",
          "condition": "always",
          "description": "æ‰€æœ‰èŠ‚ç‚¹éƒ½è¿æ¥åˆ°å·¥ä½œæµæ—¥å¿—è®°å½•å™¨"
        },
        {
          "from": "workflow-logger",
          "to": "performance-monitor",
          "condition": "always",
          "description": "æ—¥å¿—è®°å½•åè¿›è¡Œæ€§èƒ½ç›‘æ§"
        },
        {
          "from": "performance-monitor",
          "to": "error-handler",
          "condition": "has_errors_or_alerts",
          "description": "æœ‰é”™è¯¯æˆ–å‘Šè­¦æ—¶è¿›å…¥é”™è¯¯å¤„ç†"
        },
        {
          "from": "error-handler",
          "to": "next-node",
          "condition": "error_handled",
          "description": "é”™è¯¯å¤„ç†å®Œæˆåç»§ç»­æµç¨‹"
        }
      ]
    },
    
    "completionFlow": {
      "description": "å·¥ä½œæµå®Œæˆæ—¶çš„æŠ¥å‘Šç”Ÿæˆæµç¨‹",
      "connections": [
        {
          "from": "final-node",
          "to": "execution-reporter",
          "condition": "workflow_completed",
          "description": "å·¥ä½œæµå®Œæˆæ—¶ç”Ÿæˆæ‰§è¡ŒæŠ¥å‘Š"
        }
      ]
    }
  },
  
  "integrationGuide": {
    "description": "å¦‚ä½•å°†æ—¥å¿—è®°å½•èŠ‚ç‚¹é›†æˆåˆ°ç°æœ‰å·¥ä½œæµ",
    
    "steps": [
      {
        "step": 1,
        "title": "å¯¼å…¥èŠ‚ç‚¹é…ç½®",
        "description": "å°†æ—¥å¿—è®°å½•èŠ‚ç‚¹é…ç½®å¯¼å…¥åˆ°n8nå·¥ä½œæµä¸­",
        "action": "import_node_configurations"
      },
      {
        "step": 2,
        "title": "é…ç½®ç¯å¢ƒå˜é‡",
        "description": "è®¾ç½®å¿…è¦çš„ç¯å¢ƒå˜é‡",
        "requiredVariables": [
          "WORKFLOW_LOG_LEVEL",
          "ENABLE_STRUCTURED_LOGGING",
          "ENABLE_ERROR_ALERTS",
          "WEBHOOK_ALERT_URL",
          "ENABLE_EXECUTION_REPORTS",
          "REPORT_STORAGE_PATH"
        ]
      },
      {
        "step": 3,
        "title": "è¿æ¥æ—¥å¿—èŠ‚ç‚¹",
        "description": "å°†æ—¥å¿—è®°å½•èŠ‚ç‚¹è¿æ¥åˆ°ç°æœ‰å·¥ä½œæµèŠ‚ç‚¹",
        "action": "connect_logging_nodes"
      },
      {
        "step": 4,
        "title": "æµ‹è¯•æ—¥å¿—åŠŸèƒ½",
        "description": "æ‰§è¡Œæµ‹è¯•å·¥ä½œæµéªŒè¯æ—¥å¿—è®°å½•åŠŸèƒ½",
        "action": "test_logging_functionality"
      }
    ]
  }
}