{
  "name": "é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶é›†æˆé…ç½®",
  "description": "ä¸ºn8nå·¥ä½œæµé›†æˆå¢å¼ºçš„é”™è¯¯å¤„ç†ã€è‡ªåŠ¨é‡è¯•å’Œæ•°æ®ä¸€è‡´æ€§ä¿æŠ¤åŠŸèƒ½",
  "version": "1.0.0",
  "createdAt": "2025-08-23T15:00:00.000Z",
  
  "errorHandlingNodes": {
    "description": "é”™è¯¯å¤„ç†ç›¸å…³çš„n8nèŠ‚ç‚¹é…ç½®",
    
    "enhancedErrorHandler": {
      "nodeId": "enhanced-error-handler",
      "name": "å¢å¼ºé”™è¯¯å¤„ç†å™¨",
      "type": "n8n-nodes-base.function",
      "description": "æä¾›åˆ†å±‚é”™è¯¯å¤„ç†ã€è‡ªåŠ¨é‡è¯•å’Œæ¢å¤ç­–ç•¥",
      
      "parameters": {
        "functionCode": "// å¢å¼ºé”™è¯¯å¤„ç†å™¨é›†æˆ\nconst EnhancedErrorHandler = require('./enhanced-error-handler.js');\n\n// åˆå§‹åŒ–é”™è¯¯å¤„ç†å™¨\nconst errorHandler = new EnhancedErrorHandler({\n  enableRetry: true,\n  enableCircuitBreaker: true,\n  enableDataConsistency: true,\n  maxRetryAttempts: 3,\n  baseRetryDelay: 1000,\n  circuitBreakerThreshold: 5,\n  circuitBreakerTimeout: 60000\n});\n\n// è·å–è¾“å…¥æ•°æ®\nconst inputData = $input.first()?.json || {};\nconst error = inputData.error || $execution.lastNodeExecuted?.error;\nconst context = {\n  service: inputData.service || $node.name,\n  operation: inputData.operation || 'workflow_step',\n  workflowId: $workflow.id,\n  executionId: $execution.id,\n  retryAttempt: inputData.retryAttempt || 0,\n  phase: inputData.phase || inputData.workflowStatus?.phase || 'unknown',\n  \n  // é‡è¯•å›è°ƒå‡½æ•°\n  retryCallback: async (retryContext) => {\n    console.log(`ğŸ”„ æ‰§è¡Œé‡è¯•å›è°ƒ - å°è¯• ${retryContext.retryAttempt}`);\n    \n    // è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„é‡è¯•é€»è¾‘\n    // ä¾‹å¦‚é‡æ–°è°ƒç”¨å¤±è´¥çš„APIæˆ–é‡æ–°å¤„ç†æ•°æ®\n    \n    if (inputData.retryFunction && typeof inputData.retryFunction === 'function') {\n      return await inputData.retryFunction(retryContext);\n    }\n    \n    // é»˜è®¤é‡è¯•é€»è¾‘ï¼šè¿”å›æˆåŠŸï¼ˆæ¨¡æ‹Ÿé‡è¯•æˆåŠŸï¼‰\n    return {\n      success: Math.random() > 0.3, // 70% æˆåŠŸç‡\n      data: { retryAttempt: retryContext.retryAttempt, timestamp: Date.now() }\n    };\n  },\n  \n  // ä¸Šä¸‹æ–‡æ•°æ®\n  inputData: inputData,\n  backupEndpoint: inputData.backupEndpoint,\n  backupAuth: inputData.backupAuth,\n  timeout: inputData.timeout || 30000,\n  requestRate: inputData.requestRate || 10\n};\n\n// å¤„ç†é”™è¯¯ï¼ˆå¦‚æœå­˜åœ¨ï¼‰\nif (error || inputData.forceErrorHandling) {\n  try {\n    console.log('ğŸš¨ æ£€æµ‹åˆ°é”™è¯¯ï¼Œå¯åŠ¨å¢å¼ºé”™è¯¯å¤„ç†...');\n    \n    const handleResult = await errorHandler.handleError(error || new Error(inputData.simulatedError || 'æ¨¡æ‹Ÿé”™è¯¯'), context);\n    \n    console.log('âœ… é”™è¯¯å¤„ç†å®Œæˆ:', JSON.stringify({\n      success: handleResult.success,\n      errorId: handleResult.errorId,\n      classification: handleResult.classification?.category,\n      shouldRetry: handleResult.shouldRetry,\n      shouldSkip: handleResult.shouldSkip,\n      shouldAbort: handleResult.shouldAbort\n    }));\n    \n    return {\n      json: {\n        ...inputData,\n        errorHandling: {\n          processed: true,\n          result: handleResult,\n          timestamp: new Date().toISOString()\n        },\n        \n        // æ§åˆ¶æµç¨‹\n        shouldRetry: handleResult.shouldRetry,\n        shouldSkip: handleResult.shouldSkip,\n        shouldAbort: handleResult.shouldAbort,\n        \n        // é”™è¯¯ä¿¡æ¯\n        errorId: handleResult.errorId,\n        errorClassification: handleResult.classification,\n        recoveryResult: handleResult.recoveryResult,\n        \n        // æ—¥å¿—å…ƒæ•°æ®\n        logMetadata: {\n          category: 'error_handling',\n          message: `é”™è¯¯å¤„ç†å®Œæˆ - ${handleResult.classification?.category || 'unknown'}`,\n          level: handleResult.shouldAbort ? 'error' : handleResult.shouldSkip ? 'warn' : 'info',\n          errorHandled: true\n        }\n      }\n    };\n    \n  } catch (handlingError) {\n    console.error('âŒ é”™è¯¯å¤„ç†å™¨å¤±è´¥:', handlingError);\n    \n    return {\n      json: {\n        ...inputData,\n        errorHandling: {\n          processed: false,\n          error: handlingError.message,\n          timestamp: new Date().toISOString()\n        },\n        shouldAbort: true,\n        criticalError: true,\n        \n        logMetadata: {\n          category: 'error_handling',\n          message: `é”™è¯¯å¤„ç†å™¨å¤±è´¥: ${handlingError.message}`,\n          level: 'error',\n          critical: true\n        }\n      }\n    };\n  }\n} else {\n  // æ²¡æœ‰é”™è¯¯ï¼Œç›´æ¥ä¼ é€’æ•°æ®\n  return {\n    json: {\n      ...inputData,\n      errorHandling: {\n        processed: false,\n        reason: 'no_error_detected',\n        timestamp: new Date().toISOString()\n      },\n      shouldContinue: true,\n      \n      logMetadata: {\n        category: 'error_handling',\n        message: 'æ— é”™è¯¯æ£€æµ‹ï¼Œç»§ç»­æ‰§è¡Œ',\n        level: 'debug'\n      }\n    }\n  };\n}"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "dataConsistencyManager": {
      "nodeId": "data-consistency-manager",
      "name": "æ•°æ®ä¸€è‡´æ€§ç®¡ç†å™¨",
      "type": "n8n-nodes-base.function",
      "description": "ç®¡ç†æ•°æ®ä¸€è‡´æ€§ã€äº‹åŠ¡å’Œå›æ»šæœºåˆ¶",
      
      "parameters": {
        "functionCode": "// æ•°æ®ä¸€è‡´æ€§ç®¡ç†å™¨é›†æˆ\nconst DataConsistencyManager = require('./data-consistency-manager.js');\n\n// åˆå§‹åŒ–æ•°æ®ä¸€è‡´æ€§ç®¡ç†å™¨\nconst consistencyManager = new DataConsistencyManager({\n  enableTransactions: true,\n  enableRollback: true,\n  enableVersioning: true,\n  enableChecksums: true,\n  consistencyCheckInterval: 30000,\n  maxRollbackDepth: 10,\n  transactionTimeout: 300000\n});\n\n// è·å–è¾“å…¥æ•°æ®\nconst inputData = $input.first()?.json || {};\nconst operation = inputData.operation || 'unknown';\nconst transactionId = inputData.transactionId;\n\n// å¤„ç†ä¸åŒçš„ä¸€è‡´æ€§æ“ä½œ\ntry {\n  let result = { success: false, data: null };\n  \n  switch (operation) {\n    case 'begin_transaction':\n      console.log('ğŸ”„ å¼€å§‹æ•°æ®ä¸€è‡´æ€§äº‹åŠ¡...');\n      const beginResult = await consistencyManager.beginTransaction(\n        inputData.customTransactionId,\n        {\n          workflowId: $workflow.id,\n          executionId: $execution.id,\n          phase: inputData.phase || 'unknown',\n          operation: inputData.operationType || 'workflow_step'\n        }\n      );\n      result = {\n        success: beginResult.success,\n        transactionId: beginResult.transactionId,\n        message: 'äº‹åŠ¡å·²å¼€å§‹'\n      };\n      break;\n      \n    case 'record_operation':\n      console.log(`ğŸ“ è®°å½•æ•°æ®æ“ä½œ - äº‹åŠ¡: ${transactionId}`);\n      if (!transactionId) {\n        throw new Error('ç¼ºå°‘äº‹åŠ¡ID');\n      }\n      \n      const operationId = await consistencyManager.recordOperation(transactionId, {\n        type: inputData.operationType || 'update',\n        target: inputData.target || `${$node.name}_${Date.now()}`,\n        data: inputData.operationData || inputData\n      });\n      \n      result = {\n        success: true,\n        operationId: operationId,\n        transactionId: transactionId,\n        message: 'æ“ä½œå·²è®°å½•'\n      };\n      break;\n      \n    case 'commit_transaction':\n      console.log(`âœ… æäº¤äº‹åŠ¡: ${transactionId}`);\n      if (!transactionId) {\n        throw new Error('ç¼ºå°‘äº‹åŠ¡ID');\n      }\n      \n      const commitResult = await consistencyManager.commitTransaction(transactionId);\n      result = {\n        success: commitResult.success,\n        transactionId: commitResult.transactionId,\n        operationsCount: commitResult.operationsCount,\n        duration: commitResult.duration,\n        message: 'äº‹åŠ¡å·²æäº¤'\n      };\n      break;\n      \n    case 'rollback_transaction':\n      console.log(`ğŸ”„ å›æ»šäº‹åŠ¡: ${transactionId}`);\n      if (!transactionId) {\n        throw new Error('ç¼ºå°‘äº‹åŠ¡ID');\n      }\n      \n      const rollbackResult = await consistencyManager.rollbackTransaction(\n        transactionId,\n        inputData.rollbackReason || 'manual_rollback'\n      );\n      result = {\n        success: rollbackResult.success,\n        transactionId: rollbackResult.transactionId,\n        operationsRolledBack: rollbackResult.operationsRolledBack,\n        reason: rollbackResult.reason,\n        message: 'äº‹åŠ¡å·²å›æ»š'\n      };\n      break;\n      \n    case 'check_consistency':\n      console.log('ğŸ” æ‰§è¡Œä¸€è‡´æ€§æ£€æŸ¥...');\n      await consistencyManager.performPeriodicConsistencyCheck();\n      result = {\n        success: true,\n        message: 'ä¸€è‡´æ€§æ£€æŸ¥å·²å®Œæˆ',\n        timestamp: new Date().toISOString()\n      };\n      break;\n      \n    case 'get_statistics':\n      const stats = consistencyManager.getStatistics();\n      result = {\n        success: true,\n        statistics: stats,\n        message: 'ç»Ÿè®¡ä¿¡æ¯å·²è·å–'\n      };\n      break;\n      \n    default:\n      // é»˜è®¤æ“ä½œï¼šä¼ é€’æ•°æ®å¹¶ç¡®ä¿ä¸€è‡´æ€§\n      result = {\n        success: true,\n        data: inputData,\n        message: 'æ•°æ®å·²ä¼ é€’ï¼Œä¸€è‡´æ€§å·²ç¡®ä¿'\n      };\n  }\n  \n  console.log(`ğŸ“Š æ•°æ®ä¸€è‡´æ€§æ“ä½œå®Œæˆ: ${operation}`);\n  \n  return {\n    json: {\n      ...inputData,\n      consistencyManagement: {\n        operation: operation,\n        result: result,\n        timestamp: new Date().toISOString(),\n        processed: true\n      },\n      \n      // ä¼ é€’äº‹åŠ¡IDç»™åç»­èŠ‚ç‚¹\n      transactionId: result.transactionId || transactionId,\n      \n      // æ—¥å¿—å…ƒæ•°æ®\n      logMetadata: {\n        category: 'data_consistency',\n        message: `æ•°æ®ä¸€è‡´æ€§æ“ä½œ: ${operation} - ${result.message}`,\n        level: result.success ? 'info' : 'error',\n        operation: operation\n      }\n    }\n  };\n  \n} catch (error) {\n  console.error('âŒ æ•°æ®ä¸€è‡´æ€§ç®¡ç†å¤±è´¥:', error);\n  \n  return {\n    json: {\n      ...inputData,\n      consistencyManagement: {\n        operation: operation,\n        error: error.message,\n        timestamp: new Date().toISOString(),\n        processed: false\n      },\n      consistencyError: true,\n      \n      logMetadata: {\n        category: 'data_consistency',\n        message: `æ•°æ®ä¸€è‡´æ€§æ“ä½œå¤±è´¥: ${error.message}`,\n        level: 'error',\n        operation: operation\n      }\n    }\n  };\n}"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "errorRecoveryOrchestrator": {
      "nodeId": "error-recovery-orchestrator",
      "name": "é”™è¯¯æ¢å¤ç¼–æ’å™¨",
      "type": "n8n-nodes-base.function",
      "description": "åè°ƒæ•´ä¸ªå·¥ä½œæµçš„é”™è¯¯æ¢å¤è¿‡ç¨‹",
      
      "parameters": {
        "functionCode": "// é”™è¯¯æ¢å¤ç¼–æ’å™¨é›†æˆ\nconst ErrorRecoveryOrchestrator = require('./error-recovery-orchestrator.js');\n\n// åˆå§‹åŒ–é”™è¯¯æ¢å¤ç¼–æ’å™¨\nconst recoveryOrchestrator = new ErrorRecoveryOrchestrator({\n  enableAutoRecovery: true,\n  enableFailover: true,\n  enableGracefulDegradation: true,\n  maxRecoveryAttempts: 3,\n  recoveryTimeout: 300000,\n  healthCheckInterval: 60000,\n  \n  // é”™è¯¯å¤„ç†å™¨é…ç½®\n  errorHandler: {\n    enableRetry: true,\n    enableCircuitBreaker: true,\n    maxRetryAttempts: 3,\n    baseRetryDelay: 1000\n  },\n  \n  // æ•°æ®ä¸€è‡´æ€§ç®¡ç†å™¨é…ç½®\n  consistencyManager: {\n    enableTransactions: true,\n    enableRollback: true,\n    enableVersioning: true\n  }\n});\n\n// è·å–è¾“å…¥æ•°æ®\nconst inputData = $input.first()?.json || {};\nconst error = inputData.error || $execution.lastNodeExecuted?.error;\nconst operation = inputData.operation || 'orchestrate_recovery';\n\n// æ„å»ºæ¢å¤ä¸Šä¸‹æ–‡\nconst recoveryContext = {\n  workflowId: $workflow.id,\n  executionId: $execution.id,\n  workflowName: $workflow.name,\n  phase: inputData.phase || inputData.workflowStatus?.phase || 'unknown',\n  service: inputData.service || $node.name,\n  operation: inputData.operationType || 'workflow_step',\n  \n  // æ¢å¤ç›¸å…³æ•°æ®\n  recoveryAttempts: inputData.recoveryAttempts || 0,\n  transactionId: inputData.transactionId,\n  \n  // å¤‡ç”¨èµ„æº\n  backupSources: inputData.backupSources,\n  backupEndpoint: inputData.backupEndpoint,\n  backupAuth: inputData.backupAuth,\n  backupService: inputData.backupService,\n  \n  // é…ç½®å‚æ•°\n  batchSize: inputData.batchSize,\n  timeout: inputData.timeout,\n  requestRate: inputData.requestRate,\n  \n  // åŸå§‹æ•°æ®\n  originalData: inputData\n};\n\ntry {\n  let result = { success: false, data: null };\n  \n  switch (operation) {\n    case 'orchestrate_recovery':\n      if (!error && !inputData.forceRecovery) {\n        // æ²¡æœ‰é”™è¯¯ï¼Œç›´æ¥ä¼ é€’æ•°æ®\n        result = {\n          success: true,\n          data: inputData,\n          message: 'æ— éœ€æ¢å¤ï¼Œæ­£å¸¸æ‰§è¡Œ',\n          nextAction: 'continue_workflow'\n        };\n      } else {\n        console.log('ğŸš¨ å¯åŠ¨é”™è¯¯æ¢å¤ç¼–æ’...');\n        \n        const recoveryResult = await recoveryOrchestrator.orchestrateRecovery(\n          error || new Error(inputData.simulatedError || 'æ¨¡æ‹Ÿæ¢å¤åœºæ™¯'),\n          recoveryContext\n        );\n        \n        result = {\n          success: recoveryResult.success,\n          recoveryId: recoveryResult.recoveryId,\n          strategy: recoveryResult.strategy,\n          duration: recoveryResult.duration,\n          nextAction: recoveryResult.nextAction,\n          data: recoveryResult.result?.data || inputData,\n          message: recoveryResult.success ? 'æ¢å¤æˆåŠŸ' : 'æ¢å¤å¤±è´¥'\n        };\n        \n        console.log(`${recoveryResult.success ? 'âœ…' : 'âŒ'} é”™è¯¯æ¢å¤ç¼–æ’å®Œæˆ: ${recoveryResult.recoveryId}`);\n      }\n      break;\n      \n    case 'get_recovery_statistics':\n      const stats = recoveryOrchestrator.getStatistics();\n      result = {\n        success: true,\n        statistics: stats,\n        message: 'æ¢å¤ç»Ÿè®¡ä¿¡æ¯å·²è·å–'\n      };\n      break;\n      \n    case 'health_check':\n      console.log('ğŸ” æ‰§è¡Œç³»ç»Ÿå¥åº·æ£€æŸ¥...');\n      const healthResult = await recoveryOrchestrator.analyzeSystemHealth(recoveryContext);\n      result = {\n        success: true,\n        health: healthResult,\n        message: `ç³»ç»Ÿå¥åº·çŠ¶æ€: ${healthResult.overall}`\n      };\n      break;\n      \n    default:\n      result = {\n        success: true,\n        data: inputData,\n        message: 'æœªçŸ¥æ“ä½œï¼Œæ•°æ®å·²ä¼ é€’'\n      };\n  }\n  \n  return {\n    json: {\n      ...inputData,\n      errorRecovery: {\n        operation: operation,\n        result: result,\n        timestamp: new Date().toISOString(),\n        processed: true\n      },\n      \n      // æ§åˆ¶æµç¨‹\n      shouldContinue: result.nextAction === 'continue_workflow',\n      shouldRetry: result.nextAction === 'retry_validation',\n      shouldEscalate: result.nextAction === 'escalate_to_manual',\n      \n      // æ¢å¤æ•°æ®\n      recoveryId: result.recoveryId,\n      recoveryStrategy: result.strategy,\n      recoverySuccess: result.success,\n      \n      // æ—¥å¿—å…ƒæ•°æ®\n      logMetadata: {\n        category: 'error_recovery',\n        message: `é”™è¯¯æ¢å¤ç¼–æ’: ${operation} - ${result.message}`,\n        level: result.success ? 'info' : 'error',\n        operation: operation,\n        recoveryData: {\n          recoveryId: result.recoveryId,\n          strategy: result.strategy,\n          duration: result.duration\n        }\n      }\n    }\n  };\n  \n} catch (orchestrationError) {\n  console.error('âŒ é”™è¯¯æ¢å¤ç¼–æ’å¤±è´¥:', orchestrationError);\n  \n  return {\n    json: {\n      ...inputData,\n      errorRecovery: {\n        operation: operation,\n        error: orchestrationError.message,\n        timestamp: new Date().toISOString(),\n        processed: false\n      },\n      orchestrationError: true,\n      shouldEscalate: true,\n      \n      logMetadata: {\n        category: 'error_recovery',\n        message: `é”™è¯¯æ¢å¤ç¼–æ’å¤±è´¥: ${orchestrationError.message}`,\n        level: 'error',\n        critical: true,\n        operation: operation\n      }\n    }\n  };\n}"
      },\n      \n      \"settings\": {\n        \"continueOnFail\": true,\n        \"retryOnFail\": false,\n        \"executeOnce\": false\n      }\n    }\n  },\n  \n  \"workflowIntegration\": {\n    \"description\": \"é”™è¯¯å¤„ç†æœºåˆ¶åœ¨å·¥ä½œæµä¸­çš„é›†æˆæ–¹å¼\",\n    \n    \"integrationPoints\": {\n      \"dataCollection\": {\n        \"phase\": \"data_collection\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"retry_with_fallback\",\n          \"maxRetries\": 3,\n          \"fallbackSources\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": true,\n          \"transactionScope\": \"collection_batch\",\n          \"rollbackOnFailure\": true\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"gracefulDegradation\": true\n        }\n      },\n      \n      \"contentProcessing\": {\n        \"phase\": \"content_processing\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"skip_and_continue\",\n          \"maxRetries\": 2,\n          \"fallbackProcessing\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": true,\n          \"transactionScope\": \"processing_batch\",\n          \"versionControl\": true\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"simplifiedProcessing\": true\n        }\n      },\n      \n      \"notionStorage\": {\n        \"phase\": \"notion_storage\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"retry_with_backoff\",\n          \"maxRetries\": 5,\n          \"circuitBreaker\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": true,\n          \"transactionScope\": \"storage_operation\",\n          \"rollbackOnFailure\": true,\n          \"checksumValidation\": true\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"backupStorage\": true,\n          \"localCaching\": true\n        }\n      },\n      \n      \"aiManagement\": {\n        \"phase\": \"ai_management\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"degrade_gracefully\",\n          \"maxRetries\": 2,\n          \"fallbackAI\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": false,\n          \"reason\": \"AI operations are stateless\"\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"disableOnFailure\": true\n        }\n      },\n      \n      \"firebirdPublish\": {\n        \"phase\": \"firebird_publish\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"retry_with_auth_refresh\",\n          \"maxRetries\": 3,\n          \"authRefresh\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": true,\n          \"transactionScope\": \"publish_operation\",\n          \"rollbackOnFailure\": true,\n          \"crossSystemConsistency\": true\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"queueForRetry\": true,\n          \"notifyOnFailure\": true\n        }\n      }\n    },\n    \n    \"nodeConnections\": {\n      \"description\": \"èŠ‚ç‚¹ä¹‹é—´çš„è¿æ¥å’Œæ•°æ®æµ\",\n      \n      \"errorHandlingFlow\": {\n        \"trigger\": \"on_error_or_condition\",\n        \"sequence\": [\n          \"enhanced-error-handler\",\n          \"data-consistency-manager\",\n          \"error-recovery-orchestrator\"\n        ],\n        \"conditionalRouting\": {\n          \"shouldRetry\": \"retry_node\",\n          \"shouldSkip\": \"skip_to_next_phase\",\n          \"shouldAbort\": \"abort_workflow\",\n          \"shouldEscalate\": \"manual_intervention_node\"\n        }\n      },\n      \n      \"dataConsistencyFlow\": {\n        \"beforeOperation\": \"begin_transaction\",\n        \"duringOperation\": \"record_operation\",\n        \"afterSuccess\": \"commit_transaction\",\n        \"afterFailure\": \"rollback_transaction\",\n        \"periodicCheck\": \"check_consistency\"\n      },\n      \n      \"recoveryOrchestrationFlow\": {\n        \"onError\": \"orchestrate_recovery\",\n        \"healthMonitoring\": \"health_check\",\n        \"statisticsCollection\": \"get_recovery_statistics\"\n      }\n    }\n  },\n  \n  \"configuration\": {\n    \"description\": \"é”™è¯¯å¤„ç†æœºåˆ¶çš„é…ç½®å‚æ•°\",\n    \n    \"globalSettings\": {\n      \"enableErrorHandling\": true,\n      \"enableDataConsistency\": true,\n      \"enableRecoveryOrchestration\": true,\n      \"enableDetailedLogging\": true,\n      \"enablePerformanceMonitoring\": true\n    },\n    \n    \"errorHandlingSettings\": {\n      \"maxRetryAttempts\": 3,\n      \"baseRetryDelay\": 1000,\n      \"maxRetryDelay\": 30000,\n      \"retryBackoffStrategy\": \"exponential\",\n      \"circuitBreakerThreshold\": 5,\n      \"circuitBreakerTimeout\": 60000,\n      \"enableJitter\": true\n    },\n    \n    \"consistencySettings\": {\n      \"transactionTimeout\": 300000,\n      \"maxRollbackDepth\": 10,\n      \"enableVersioning\": true,\n      \"enableChecksums\": true,\n      \"consistencyCheckInterval\": 30000,\n      \"autoCleanupInterval\": 3600000\n    },\n    \n    \"recoverySettings\": {\n      \"maxRecoveryAttempts\": 3,\n      \"recoveryTimeout\": 300000,\n      \"healthCheckInterval\": 60000,\n      \"enableAutoRecovery\": true,\n      \"enableFailover\": true,\n      \"enableGracefulDegradation\": true\n    },\n    \n    \"alertingSettings\": {\n      \"enableAlerts\": true,\n      \"webhookUrl\": \"${WEBHOOK_ALERT_URL}\",\n      \"alertThresholds\": {\n        \"errorRate\": 5,\n        \"responseTime\": 5000,\n        \"memoryUsage\": 80,\n        \"consecutiveFailures\": 3\n      },\n      \"alertCooldown\": 300000\n    }\n  },\n  \n  \"monitoring\": {\n    \"description\": \"é”™è¯¯å¤„ç†å’Œæ¢å¤çš„ç›‘æ§é…ç½®\",\n    \n    \"metrics\": {\n      \"errorMetrics\": {\n        \"totalErrors\": \"counter\",\n        \"errorsByCategory\": \"counter_by_label\",\n        \"errorRate\": \"gauge\",\n        \"recoverySuccessRate\": \"gauge\",\n        \"averageRecoveryTime\": \"histogram\"\n      },\n      \n      \"consistencyMetrics\": {\n        \"activeTransactions\": \"gauge\",\n        \"committedTransactions\": \"counter\",\n        \"rolledBackTransactions\": \"counter\",\n        \"consistencyCheckFailures\": \"counter\",\n        \"dataIntegrityScore\": \"gauge\"\n      },\n      \n      \"recoveryMetrics\": {\n        \"recoveryAttempts\": \"counter\",\n        \"successfulRecoveries\": \"counter\",\n        \"failedRecoveries\": \"counter\",\n        \"averageRecoveryDuration\": \"histogram\",\n        \"systemHealthScore\": \"gauge\"\n      }\n    },\n    \n    \"dashboards\": {\n      \"errorHandlingDashboard\": {\n        \"panels\": [\n          \"error_rate_over_time\",\n          \"error_distribution_by_category\",\n          \"recovery_success_rate\",\n          \"circuit_breaker_status\",\n          \"retry_attempts_distribution\"\n        ]\n      },\n      \n      \"dataConsistencyDashboard\": {\n        \"panels\": [\n          \"transaction_status_overview\",\n          \"rollback_frequency\",\n          \"consistency_check_results\",\n          \"data_integrity_trends\",\n          \"version_history_growth\"\n        ]\n      },\n      \n      \"systemHealthDashboard\": {\n        \"panels\": [\n          \"overall_system_health\",\n          \"component_health_status\",\n          \"recovery_orchestration_activity\",\n          \"performance_degradation_alerts\",\n          \"resource_utilization_trends\"\n        ]\n      }\n    }\n  },\n  \n  \"testing\": {\n    \"description\": \"é”™è¯¯å¤„ç†æœºåˆ¶çš„æµ‹è¯•é…ç½®\",\n    \n    \"testScenarios\": {\n      \"networkFailure\": {\n        \"description\": \"æ¨¡æ‹Ÿç½‘ç»œè¿æ¥å¤±è´¥\",\n        \"errorType\": \"network\",\n        \"expectedRecovery\": \"retry_with_backoff\",\n        \"expectedOutcome\": \"success_after_retry\"\n      },\n      \n      \"authenticationFailure\": {\n        \"description\": \"æ¨¡æ‹Ÿè®¤è¯å¤±è´¥\",\n        \"errorType\": \"authentication\",\n        \"expectedRecovery\": \"refresh_credentials\",\n        \"expectedOutcome\": \"success_after_auth_refresh\"\n      },\n      \n      \"rateLimitExceeded\": {\n        \"description\": \"æ¨¡æ‹ŸAPIé™æµ\",\n        \"errorType\": \"rate_limit\",\n        \"expectedRecovery\": \"exponential_backoff\",\n        \"expectedOutcome\": \"success_after_delay\"\n      },\n      \n      \"dataCorruption\": {\n        \"description\": \"æ¨¡æ‹Ÿæ•°æ®æŸå\",\n        \"errorType\": \"validation\",\n        \"expectedRecovery\": \"rollback_transaction\",\n        \"expectedOutcome\": \"data_integrity_preserved\"\n      },\n      \n      \"systemOverload\": {\n        \"description\": \"æ¨¡æ‹Ÿç³»ç»Ÿè¿‡è½½\",\n        \"errorType\": \"resource_exhaustion\",\n        \"expectedRecovery\": \"graceful_degradation\",\n        \"expectedOutcome\": \"reduced_functionality_maintained\"\n      }\n    },\n    \n    \"validationCriteria\": {\n      \"errorDetection\": \"All errors must be properly classified\",\n      \"recoveryExecution\": \"Recovery strategies must execute within timeout\",\n      \"dataConsistency\": \"Data integrity must be maintained throughout recovery\",\n      \"systemStability\": \"System must remain stable during recovery operations\",\n      \"performanceImpact\": \"Recovery overhead must not exceed 20% of normal operation time\"\n    }\n  },\n  \n  \"deployment\": {\n    \"description\": \"é”™è¯¯å¤„ç†æœºåˆ¶çš„éƒ¨ç½²è¯´æ˜\",\n    \n    \"prerequisites\": [\n      \"Node.js runtime with ES2020+ support\",\n      \"n8n workflow engine v1.0+\",\n      \"Sufficient memory for transaction history (minimum 512MB)\",\n      \"Network access for external service monitoring\",\n      \"Write permissions for log and backup storage\"\n    ],\n    \n    \"installationSteps\": [\n      \"Copy error handling modules to n8n-config directory\",\n      \"Configure environment variables for error handling\",\n      \"Import error handling nodes into n8n workflow\",\n      \"Configure node connections and conditional routing\",\n      \"Test error handling scenarios\",\n      \"Enable monitoring and alerting\",\n      \"Deploy to production environment\"\n    ],\n    \n    \"environmentVariables\": {\n      \"ENABLE_ERROR_HANDLING\": \"true\",\n      \"ENABLE_DATA_CONSISTENCY\": \"true\",\n      \"ENABLE_RECOVERY_ORCHESTRATION\": \"true\",\n      \"ERROR_HANDLING_LOG_LEVEL\": \"info\",\n      \"WEBHOOK_ALERT_URL\": \"https://your-webhook-url.com/alerts\",\n      \"TRANSACTION_TIMEOUT\": \"300000\",\n      \"MAX_RETRY_ATTEMPTS\": \"3\",\n      \"CIRCUIT_BREAKER_THRESHOLD\": \"5\",\n      \"HEALTH_CHECK_INTERVAL\": \"60000\"\n    }\n  }\n}"