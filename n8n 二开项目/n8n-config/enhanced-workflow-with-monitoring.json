{
  "name": "火鸟门户新闻采集工作流 - 增强监控版",
  "description": "集成了全面日志记录和监控系统的新闻采集工作流",
  "version": "2.0.0",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 */30 * * * *"
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "定时触发器",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [240, 300]
    },
    
    {
      "parameters": {
        "functionCode": "// 工作流初始化和监控系统启动\nconst PerformanceMetricsCollector = require('./performance-metrics-collector.js');\nconst WorkflowExecutionReporter = require('./workflow-execution-reporter.js');\n\n// 初始化监控系统\nconst metricsCollector = new PerformanceMetricsCollector({\n  enableSystemMetrics: true,\n  enableWorkflowMetrics: true,\n  enableApiMetrics: true,\n  collectionInterval: 30000\n});\n\nconst executionReporter = new WorkflowExecutionReporter({\n  enableFileStorage: true,\n  enablePeriodicReports: true,\n  includePerformanceAnalysis: true\n});\n\n// 工作流基本信息\nconst workflowId = $execution.id;\nconst startTime = Date.now();\n\n// 数据源配置\nconst rssSources = [\n  { name: 'The Neuron', url: 'https://www.theneuron.ai/feed', category: 'AI资讯', categoryId: 1 },\n  { name: 'Futurepedia', url: 'https://www.futurepedia.io/rss', category: 'AI工具', categoryId: 1 },\n  { name: 'Superhuman', url: 'https://blog.superhuman.com/feed/', category: '科技资讯', categoryId: 1 },\n  { name: 'The Rundown AI', url: 'https://www.therundown.ai/feed', category: 'AI资讯', categoryId: 1 }\n];\n\nconst githubSources = [\n  { name: 'GitHub Trending', repo: 'trending', category: '开源项目', categoryId: 1 }\n];\n\n// 工作流状态跟踪\nconst workflowStatus = {\n  executionId: workflowId,\n  workflowId: $workflow.id,\n  workflowName: $workflow.name,\n  startTime: startTime,\n  startTimestamp: new Date().toISOString(),\n  phase: 'initialization',\n  totalSources: rssSources.length + githubSources.length,\n  expectedSteps: [\n    'initialization',\n    'data_collection',\n    'content_processing', \n    'notion_storage',\n    'ai_management',\n    'firebird_publish',\n    'completion',\n    'reporting'\n  ],\n  currentStep: 1,\n  totalSteps: 8,\n  \n  // 监控系统引用\n  metricsCollector: metricsCollector,\n  executionReporter: executionReporter\n};\n\n// 收集初始系统指标\nconst initialMetrics = metricsCollector.collectSystemMetrics();\nconst initialWorkflowMetrics = metricsCollector.collectWorkflowMetrics({\n  executionId: workflowId,\n  workflowId: $workflow.id,\n  workflowName: $workflow.name,\n  nodeId: $node.id,\n  nodeName: $node.name,\n  itemsProcessed: 0,\n  dataSize: 0\n});\n\n// 记录工作流启动日志\nconsole.log('🚀 工作流启动 - 监控系统已激活:', JSON.stringify({\n  executionId: workflowId,\n  workflowName: $workflow.name,\n  totalSources: workflowStatus.totalSources,\n  expectedDuration: '5-10分钟',\n  startTime: workflowStatus.startTimestamp,\n  monitoringEnabled: true,\n  systemMetrics: {\n    memoryUsage: Math.round(initialMetrics.memory.heapUsagePercent) + '%',\n    processUptime: Math.round(initialMetrics.process.uptime) + 's'\n  }\n}));\n\nreturn { \n  json: { \n    rssSources, \n    githubSources, \n    workflowStatus,\n    initialMetrics,\n    timestamp: new Date().toISOString(),\n    \n    // 日志记录元数据\n    logMetadata: {\n      phase: 'initialization',\n      step: 1,\n      totalSteps: 8,\n      executionId: workflowId\n    }\n  } \n};"
      },
      "id": "workflow-initialization",
      "name": "工作流初始化与监控启动",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,\n      "position": [460, 300]
    },
    
    {
      "parameters": {
        "functionCode": "// 统一日志记录节点 - 基于配置文件\nconst logLevel = process.env.WORKFLOW_LOG_LEVEL || 'info';\nconst enableStructuredLogging = process.env.ENABLE_STRUCTURED_LOGGING !== 'false';\n\n// 日志级别映射\nconst LOG_LEVELS = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3,\n  trace: 4\n};\n\nconst currentLogLevel = LOG_LEVELS[logLevel] || LOG_LEVELS.info;\n\n// 日志记录函数\nfunction log(level, category, message, metadata = {}) {\n  if (LOG_LEVELS[level] > currentLogLevel) {\n    return;\n  }\n  \n  const logEntry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    category: category,\n    executionId: $execution.id,\n    workflowId: $workflow.id,\n    workflowName: $workflow.name,\n    nodeId: $node.id || 'workflow-logger',\n    nodeName: $node.name || '工作流日志记录器',\n    message: message,\n    metadata: {\n      ...metadata,\n      memoryUsage: process.memoryUsage ? process.memoryUsage() : null,\n      timestamp: Date.now()\n    }\n  };\n  \n  // 敏感数据脱敏\n  if (logEntry.metadata) {\n    logEntry.metadata = sanitizeMetadata(logEntry.metadata);\n  }\n  \n  if (enableStructuredLogging) {\n    console.log(JSON.stringify(logEntry));\n  } else {\n    console.log(`[${logEntry.timestamp}] ${logEntry.level} [${logEntry.category}] ${logEntry.message}`);\n  }\n  \n  return logEntry;\n}\n\n// 敏感数据脱敏函数\nfunction sanitizeMetadata(metadata) {\n  const sensitiveKeys = ['password', 'token', 'key', 'secret', 'credential', 'auth'];\n  const sanitized = { ...metadata };\n  \n  function sanitizeObject(obj) {\n    if (typeof obj !== 'object' || obj === null) return obj;\n    \n    const result = Array.isArray(obj) ? [] : {};\n    \n    for (const [key, value] of Object.entries(obj)) {\n      const lowerKey = key.toLowerCase();\n      const isSensitive = sensitiveKeys.some(sensitive => lowerKey.includes(sensitive));\n      \n      if (isSensitive && typeof value === 'string') {\n        result[key] = '***MASKED***';\n      } else if (typeof value === 'object' && value !== null) {\n        result[key] = sanitizeObject(value);\n      } else if (typeof value === 'string' && value.length > 1000) {\n        result[key] = value.substring(0, 1000) + '...[truncated]';\n      } else {\n        result[key] = value;\n      }\n    }\n    \n    return result;\n  }\n  \n  return sanitizeObject(sanitized);\n}\n\n// 获取输入数据\nconst inputData = $input.first()?.json || {};\nconst logCategory = inputData.logMetadata?.category || 'workflow';\nconst logMessage = inputData.logMetadata?.message || '工作流步骤执行';\nconst logMetadata = inputData.logMetadata || {};\nconst logLevelOverride = inputData.logMetadata?.level || 'info';\n\n// 性能指标收集\nconst performanceMetrics = {\n  nodeExecutionTime: Date.now() - (inputData.workflowStatus?.startTime || Date.now()),\n  itemCount: $input.all().length,\n  dataSize: JSON.stringify($input.all()).length,\n  processingRate: $input.all().length / Math.max(1, (Date.now() - (inputData.workflowStatus?.startTime || Date.now())) / 1000)\n};\n\n// 记录日志\nconst logEntry = log(logLevelOverride, logCategory, logMessage, {\n  ...logMetadata,\n  performanceMetrics,\n  inputDataSummary: {\n    itemCount: $input.all().length,\n    hasErrors: inputData.errors && inputData.errors.length > 0,\n    status: inputData.status || 'unknown',\n    phase: inputData.workflowStatus?.phase || 'unknown'\n  }\n});\n\n// 返回原始数据和日志信息\nreturn {\n  json: {\n    ...inputData,\n    logEntry: logEntry,\n    logged: true,\n    logTimestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "workflow-logger",
      "name": "统一日志记录器",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [680, 300],
      "continueOnFail": true
    },
    
    {
      "parameters": {
        "functionCode": "// RSS采集逻辑 - 增强版 (含监控)\nconst axios = require('axios');\nconst xml2js = require('xml2js');\n\nconst inputData = $input.first().json;\nconst rssSources = inputData.rssSources;\nconst workflowStatus = inputData.workflowStatus;\nconst metricsCollector = workflowStatus.metricsCollector;\n\nconst collectedItems = [];\nconst errors = [];\nconst sourceStats = [];\nconst apiCalls = [];\n\n// 更新工作流状态\nworkflowStatus.phase = 'rss_collection';\nworkflowStatus.currentStep = 3;\n\n// RSS采集函数 - 增强监控\nasync function fetchRSSFeed(source) {\n  const startTime = Date.now();\n  const apiCall = {\n    endpoint: source.url,\n    method: 'GET',\n    startTime: startTime\n  };\n  \n  try {\n    console.log(`📡 开始采集RSS源: ${source.name}`);\n    \n    const response = await axios.get(source.url, {\n      timeout: 30000,\n      headers: {\n        'User-Agent': 'Mozilla/5.0 (compatible; n8n-news-collector/1.0)',\n        'Accept': 'application/rss+xml, application/xml, text/xml'\n      }\n    });\n\n    const parser = new xml2js.Parser({\n      explicitArray: false,\n      ignoreAttrs: false,\n      mergeAttrs: true\n    });\n\n    const result = await parser.parseStringPromise(response.data);\n    const items = result.rss?.channel?.item || result.feed?.entry || [];\n    \n    let processedItems = Array.isArray(items) ? items : [items].filter(Boolean);\n    processedItems = processedItems.slice(0, 10);\n    \n    const processingTime = Date.now() - startTime;\n    \n    // 记录API调用成功\n    apiCall.responseTime = processingTime;\n    apiCall.success = true;\n    apiCall.statusCode = response.status;\n    apiCalls.push(apiCall);\n    \n    sourceStats.push({\n      source: source.name,\n      status: 'success',\n      itemCount: processedItems.length,\n      processingTime: processingTime,\n      url: source.url,\n      responseSize: JSON.stringify(response.data).length\n    });\n    \n    console.log(`✅ RSS采集成功 - ${source.name}: ${processedItems.length}条 (${processingTime}ms)`);\n    return processedItems;\n    \n  } catch (error) {\n    const processingTime = Date.now() - startTime;\n    \n    // 记录API调用失败\n    apiCall.responseTime = processingTime;\n    apiCall.success = false;\n    apiCall.error = error.message;\n    apiCall.statusCode = error.response?.status || 0;\n    apiCalls.push(apiCall);\n    \n    console.error(`❌ RSS采集失败 - ${source.name}:`, error.message);\n    \n    errors.push({\n      source: source.name,\n      error: error.message,\n      type: 'rss',\n      url: source.url,\n      timestamp: new Date().toISOString(),\n      severity: 'medium',\n      retryable: true\n    });\n    \n    sourceStats.push({\n      source: source.name,\n      status: 'failed',\n      itemCount: 0,\n      processingTime: processingTime,\n      error: error.message,\n      url: source.url\n    });\n    \n    return [];\n  }\n}\n\n// 数据标准化函数 - 保持原有逻辑\nfunction normalizeRSSItem(item, source) {\n  const publishDate = item.pubDate || item.published || item.updated || new Date().toISOString();\n  \n  let content = '';\n  if (item.content) {\n    content = typeof item.content === 'object' ? (item.content._ || item.content) : item.content;\n  } else if (item.description) {\n    content = typeof item.description === 'object' ? (item.description._ || item.description) : item.description;\n  } else if (item.summary) {\n    content = typeof item.summary === 'object' ? (item.summary._ || item.summary) : item.summary;\n  }\n  \n  content = content.replace(/<[^>]*>/g, '').trim();\n  \n  let title = '';\n  if (item.title) {\n    title = typeof item.title === 'object' ? (item.title._ || item.title) : item.title;\n  }\n  title = title.replace(/<[^>]*>/g, '').trim();\n  \n  return {\n    title: title || '无标题',\n    content: content || '无内容',\n    summary: content.substring(0, 200) + (content.length > 200 ? '...' : ''),\n    author: item.author?.name || item.author || item['dc:creator'] || source.name,\n    source: source.name,\n    category: source.category,\n    categoryId: source.categoryId,\n    source_url: item.link?.href || item.link || item.guid?._ || item.guid || '',\n    image_url: item.enclosure?.url || item['media:thumbnail']?.url || item['media:content']?.url || '',\n    keywords: Array.isArray(item.category) ? item.category.join(',') : (item.category || ''),\n    publishedAt: publishDate,\n    collectedAt: new Date().toISOString(),\n    sourceType: 'rss',\n    \n    dataQuality: {\n      hasTitle: !!title,\n      hasContent: !!content,\n      hasImage: !!(item.enclosure?.url || item['media:thumbnail']?.url),\n      hasAuthor: !!(item.author?.name || item.author || item['dc:creator']),\n      contentLength: content.length,\n      titleLength: title.length\n    },\n    \n    processingMetadata: {\n      collectionTime: Date.now(),\n      sourceUrl: source.url,\n      parsingMethod: 'xml2js'\n    },\n    \n    originalData: item\n  };\n}\n\n// 并行采集所有RSS源\nconst rssPromises = rssSources.map(async (source) => {\n  const items = await fetchRSSFeed(source);\n  return items.map(item => normalizeRSSItem(item, source));\n});\n\ntry {\n  const rssResults = await Promise.all(rssPromises);\n  \n  rssResults.forEach(sourceItems => {\n    collectedItems.push(...sourceItems);\n  });\n  \n  // 收集性能指标\n  if (metricsCollector) {\n    const workflowMetrics = metricsCollector.collectWorkflowMetrics({\n      executionId: workflowStatus.executionId,\n      workflowId: workflowStatus.workflowId,\n      workflowName: workflowStatus.workflowName,\n      nodeId: $node.id,\n      nodeName: $node.name,\n      itemsProcessed: collectedItems.length,\n      dataSize: JSON.stringify(collectedItems).length,\n      successCount: collectedItems.length,\n      errorCount: errors.length\n    });\n    \n    const apiMetrics = metricsCollector.collectApiMetrics(apiCalls);\n    \n    // 检查性能阈值\n    const performanceAlerts = metricsCollector.checkPerformanceThresholds({\n      workflow: workflowMetrics,\n      api: apiMetrics\n    });\n    \n    workflowStatus.performanceMetrics = {\n      workflow: workflowMetrics,\n      api: apiMetrics\n    };\n    \n    workflowStatus.performanceAlerts = performanceAlerts;\n  }\n  \n  // 数据质量统计\n  const qualityStats = {\n    totalItems: collectedItems.length,\n    itemsWithImages: collectedItems.filter(item => item.image_url).length,\n    itemsWithAuthors: collectedItems.filter(item => item.author !== item.source).length,\n    averageContentLength: collectedItems.reduce((sum, item) => sum + item.content.length, 0) / collectedItems.length || 0,\n    averageTitleLength: collectedItems.reduce((sum, item) => sum + item.title.length, 0) / collectedItems.length || 0\n  };\n  \n  // 更新工作流状态\n  workflowStatus.rssCollection = {\n    completed: true,\n    itemsCollected: collectedItems.length,\n    sourcesProcessed: rssSources.length,\n    successfulSources: sourceStats.filter(s => s.status === 'success').length,\n    failedSources: sourceStats.filter(s => s.status === 'failed').length,\n    totalProcessingTime: Date.now() - workflowStatus.startTime,\n    qualityStats: qualityStats,\n    apiCallsCount: apiCalls.length,\n    averageResponseTime: apiCalls.reduce((sum, call) => sum + call.responseTime, 0) / apiCalls.length || 0\n  };\n  \n  console.log(`📊 RSS采集完成统计:`, JSON.stringify({\n    总条数: collectedItems.length,\n    错误数: errors.length,\n    成功源: workflowStatus.rssCollection.successfulSources,\n    失败源: workflowStatus.rssCollection.failedSources,\n    平均内容长度: Math.round(qualityStats.averageContentLength),\n    带图片比例: Math.round((qualityStats.itemsWithImages / collectedItems.length) * 100) + '%',\n    平均响应时间: Math.round(workflowStatus.rssCollection.averageResponseTime) + 'ms'\n  }));\n  \n  return {\n    json: {\n      items: collectedItems,\n      errors,\n      sourceStats,\n      qualityStats,\n      workflowStatus,\n      apiCalls,\n      summary: {\n        totalItems: collectedItems.length,\n        errorCount: errors.length,\n        sources: rssSources.length,\n        collectedAt: new Date().toISOString(),\n        processingTime: Date.now() - workflowStatus.startTime\n      },\n      \n      // 日志记录元数据\n      logMetadata: {\n        category: 'data_collection',\n        message: `RSS采集完成: ${collectedItems.length}条数据`,\n        level: errors.length > 0 ? 'warn' : 'info',\n        phase: 'rss_collection',\n        step: 3,\n        totalSteps: 8\n      }\n    }\n  };\n  \n} catch (error) {\n  console.error('❌ RSS批量采集失败:', error);\n  \n  workflowStatus.rssCollection = {\n    completed: false,\n    error: error.message,\n    failedAt: new Date().toISOString()\n  };\n  \n  // 记录严重错误\n  errors.push({\n    source: 'RSS批量采集',\n    error: error.message,\n    type: 'rss_batch',\n    timestamp: new Date().toISOString(),\n    severity: 'critical',\n    retryable: false\n  });\n  \n  return {\n    json: {\n      status: 'error',\n      error: error.message,\n      errors,\n      workflowStatus,\n      \n      // 错误日志元数据\n      logMetadata: {\n        category: 'error',\n        message: `RSS采集失败: ${error.message}`,\n        level: 'error',\n        phase: 'rss_collection',\n        step: 3,\n        totalSteps: 8\n      }\n    }\n  };\n}"
      },
      "id": "enhanced-rss-collector",
      "name": "增强RSS采集器(含监控)",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 200]
    },
    
    {
      "parameters": {
        "functionCode": "// 性能监控和指标收集器\nconst inputData = $input.first()?.json || {};\nconst workflowStatus = inputData.workflowStatus || {};\nconst metricsCollector = workflowStatus.metricsCollector;\n\nif (!metricsCollector) {\n  console.warn('⚠️ 性能监控器未初始化，跳过性能分析');\n  return {\n    json: {\n      ...inputData,\n      performanceMonitored: false,\n      monitoringSkipped: true\n    }\n  };\n}\n\nconst startTime = Date.now();\n\n// 收集系统性能指标\nconst systemMetrics = metricsCollector.collectSystemMetrics();\n\n// 收集工作流性能指标\nconst workflowMetrics = metricsCollector.collectWorkflowMetrics({\n  executionId: workflowStatus.executionId,\n  workflowId: workflowStatus.workflowId,\n  workflowName: workflowStatus.workflowName,\n  nodeId: $node.id,\n  nodeName: $node.name,\n  itemsProcessed: inputData.items?.length || 0,\n  dataSize: JSON.stringify(inputData.items || []).length,\n  successCount: inputData.items?.length || 0,\n  errorCount: inputData.errors?.length || 0,\n  averageQualityScore: inputData.qualityStats?.averageQualityScore || 0\n});\n\n// 收集API性能指标\nconst apiMetrics = metricsCollector.collectApiMetrics(inputData.apiCalls || []);\n\n// 收集自定义指标\nconst customMetrics = metricsCollector.collectCustomMetrics({\n  sourceDistribution: inputData.sourceStats?.reduce((acc, stat) => {\n    acc[stat.source] = stat.itemCount;\n    return acc;\n  }, {}) || {},\n  qualityScoreDistribution: inputData.qualityStats || {},\n  contentPublishRate: inputData.items?.length || 0\n});\n\n// 合并所有性能指标\nconst allMetrics = {\n  system: systemMetrics,\n  workflow: workflowMetrics,\n  api: apiMetrics,\n  custom: customMetrics,\n  collection: {\n    timestamp: Date.now(),\n    collectionTime: Date.now() - startTime,\n    nodeId: $node.id,\n    nodeName: $node.name\n  }\n};\n\n// 检查性能阈值并生成告警\nconst performanceAlerts = metricsCollector.checkPerformanceThresholds(allMetrics);\n\n// 分析性能趋势\nconst performanceTrends = metricsCollector.analyzePerformanceTrends('1h');\n\n// 生成性能摘要\nconst performanceSummary = {\n  status: performanceAlerts.some(alert => alert.type === 'critical') ? 'critical' : \n          performanceAlerts.some(alert => alert.type === 'warning') ? 'warning' : 'healthy',\n  executionTime: workflowMetrics.execution?.totalExecutionTime || 0,\n  memoryUsage: systemMetrics.memory?.heapUsagePercent || 0,\n  throughput: workflowMetrics.execution?.throughput || 0,\n  errorRate: workflowMetrics.quality?.errorRate || 0,\n  alertCount: performanceAlerts.length,\n  apiResponseTime: apiMetrics.overall?.averageResponseTime || 0\n};\n\n// 记录性能监控日志\nconsole.log('📊 性能监控报告:', JSON.stringify({\n  timestamp: new Date().toISOString(),\n  executionId: workflowStatus.executionId,\n  summary: performanceSummary,\n  alerts: performanceAlerts.length > 0 ? performanceAlerts.slice(0, 3) : undefined,\n  trends: {\n    executionTime: performanceTrends.executionTime?.trend || 'stable',\n    memoryUsage: performanceTrends.memoryUsage?.trend || 'stable',\n    throughput: performanceTrends.throughput?.trend || 'stable'\n  }\n}));\n\n// 更新工作流状态\nworkflowStatus.performanceMetrics = allMetrics;\nworkflowStatus.performanceAlerts = performanceAlerts;\nworkflowStatus.performanceTrends = performanceTrends;\nworkflowStatus.performanceSummary = performanceSummary;\n\nreturn {\n  json: {\n    ...inputData,\n    performanceMetrics: allMetrics,\n    performanceAlerts: performanceAlerts,\n    performanceTrends: performanceTrends,\n    performanceSummary: performanceSummary,\n    workflowStatus: workflowStatus,\n    performanceMonitored: true,\n    monitoringTimestamp: new Date().toISOString(),\n    \n    // 日志记录元数据\n    logMetadata: {\n      category: 'performance',\n      message: `性能监控完成 - 状态: ${performanceSummary.status}`,\n      level: performanceSummary.status === 'critical' ? 'error' : \n             performanceSummary.status === 'warning' ? 'warn' : 'info',\n      phase: workflowStatus.phase,\n      performanceData: {\n        executionTime: performanceSummary.executionTime,\n        memoryUsage: performanceSummary.memoryUsage,\n        alertCount: performanceSummary.alertCount\n      }\n    }\n  }\n};"
      },
      "id": "performance-monitor",
      "name": "性能监控器",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 300],
      "continueOnFail": true
    },
    
    {
      "parameters": {
        "functionCode": "// 错误处理和告警系统\nconst inputData = $input.first()?.json || {};\nconst errors = inputData.errors || [];\nconst performanceAlerts = inputData.performanceAlerts || [];\nconst workflowStatus = inputData.workflowStatus || {};\n\nconst enableAlerts = process.env.ENABLE_ERROR_ALERTS !== 'false';\nconst webhookUrl = process.env.WEBHOOK_ALERT_URL;\n\n// 错误分类函数\nfunction classifyError(error) {\n  if (!error) return { category: 'unknown', severity: 'low' };\n  \n  const errorMessage = error.error || error.message || '';\n  \n  if (errorMessage.includes('timeout') || errorMessage.includes('ECONNRESET') || \n      errorMessage.includes('ENOTFOUND') || errorMessage.includes('network')) {\n    return {\n      category: 'network',\n      severity: 'medium',\n      retryable: true,\n      description: '网络连接错误'\n    };\n  }\n  \n  if (errorMessage.includes('401') || errorMessage.includes('403') || \n      errorMessage.includes('unauthorized') || errorMessage.includes('authentication')) {\n    return {\n      category: 'authentication',\n      severity: 'high',\n      retryable: false,\n      description: 'API认证失败'\n    };\n  }\n  \n  if (errorMessage.includes('429') || errorMessage.includes('rate limit')) {\n    return {\n      category: 'rate_limit',\n      severity: 'medium',\n      retryable: true,\n      description: 'API请求频率限制'\n    };\n  }\n  \n  return {\n    category: error.type || 'unknown',\n    severity: error.severity || 'medium',\n    retryable: error.retryable !== false,\n    description: error.description || '未知错误类型'\n  };\n}\n\n// 生成错误报告\nfunction generateErrorReport(error, classification) {\n  return {\n    errorId: `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    timestamp: new Date().toISOString(),\n    executionId: workflowStatus.executionId,\n    workflowId: workflowStatus.workflowId,\n    workflowName: workflowStatus.workflowName,\n    nodeId: $node.id || 'error-handler',\n    nodeName: $node.name || '错误处理器',\n    \n    error: {\n      message: error.error || error.message || 'Unknown error',\n      source: error.source || 'unknown',\n      type: error.type || 'unknown',\n      timestamp: error.timestamp\n    },\n    \n    classification: classification,\n    \n    context: {\n      phase: workflowStatus.phase,\n      step: workflowStatus.currentStep,\n      totalSteps: workflowStatus.totalSteps,\n      itemsProcessed: inputData.items?.length || 0,\n      hasPerformanceIssues: performanceAlerts.length > 0\n    },\n    \n    troubleshooting: generateTroubleshootingTips(classification)\n  };\n}\n\n// 生成故障排除建议\nfunction generateTroubleshootingTips(classification) {\n  const tips = {\n    network: [\n      '检查网络连接是否正常',\n      '验证目标服务是否可访问',\n      '考虑增加超时时间',\n      '检查防火墙设置'\n    ],\n    authentication: [\n      '验证API密钥是否正确',\n      '检查API密钥是否过期',\n      '确认API权限设置',\n      '检查认证头格式'\n    ],\n    rate_limit: [\n      '减少API调用频率',\n      '实施指数退避重试',\n      '考虑升级API套餐',\n      '分批处理数据'\n    ]\n  };\n  \n  return tips[classification.category] || [\n    '检查错误日志详情',\n    '验证输入数据',\n    '联系技术支持',\n    '查看相关文档'\n  ];\n}\n\n// 发送告警通知\nasync function sendAlert(errorReport) {\n  if (!enableAlerts || !webhookUrl) {\n    console.log('⚠️ 告警功能未启用或未配置Webhook URL');\n    return false;\n  }\n  \n  try {\n    const alertPayload = {\n      type: 'error_alert',\n      severity: errorReport.classification.severity,\n      title: `工作流错误: ${errorReport.error.message}`,\n      description: errorReport.classification.description,\n      details: {\n        workflowName: errorReport.workflowName,\n        nodeName: errorReport.nodeName,\n        errorCategory: errorReport.classification.category,\n        timestamp: errorReport.timestamp,\n        executionId: errorReport.executionId,\n        phase: errorReport.context.phase\n      },\n      troubleshooting: errorReport.troubleshooting,\n      metadata: {\n        retryable: errorReport.classification.retryable,\n        errorId: errorReport.errorId\n      }\n    };\n    \n    // 这里应该实际发送到webhook，但在n8n函数节点中我们只能模拟\n    console.log('📧 告警通知 (模拟发送):', JSON.stringify(alertPayload));\n    return true;\n    \n  } catch (alertError) {\n    console.error('❌ 发送告警时出错:', alertError.message);\n    return false;\n  }\n}\n\n// 处理错误和告警\nconst processedErrors = [];\nconst alertsSent = [];\n\n// 处理工作流错误\nfor (const error of errors) {\n  const classification = classifyError(error);\n  const errorReport = generateErrorReport(error, classification);\n  \n  processedErrors.push(errorReport);\n  \n  // 记录错误日志\n  console.error('🚨 工作流错误报告:', JSON.stringify({\n    errorId: errorReport.errorId,\n    category: classification.category,\n    severity: classification.severity,\n    message: errorReport.error.message,\n    retryable: classification.retryable,\n    phase: errorReport.context.phase\n  }));\n  \n  // 发送高严重性错误的告警\n  if (classification.severity === 'high' || classification.severity === 'critical') {\n    const alertSent = await sendAlert(errorReport);\n    if (alertSent) {\n      alertsSent.push(errorReport.errorId);\n    }\n  }\n}\n\n// 处理性能告警\nfor (const alert of performanceAlerts) {\n  console.warn('⚠️ 性能告警:', JSON.stringify({\n    metric: alert.metric,\n    value: alert.value,\n    threshold: alert.threshold,\n    message: alert.message,\n    severity: alert.type\n  }));\n  \n  if (alert.type === 'critical') {\n    const alertSent = await sendAlert({\n      type: 'performance_alert',\n      severity: 'critical',\n      title: `性能告警: ${alert.message}`,\n      details: {\n        metric: alert.metric,\n        value: alert.value,\n        threshold: alert.threshold,\n        executionId: workflowStatus.executionId\n      }\n    });\n    \n    if (alertSent) {\n      alertsSent.push(`perf_${alert.metric}_${Date.now()}`);\n    }\n  }\n}\n\n// 生成错误处理摘要\nconst errorHandlingSummary = {\n  totalErrors: errors.length,\n  processedErrors: processedErrors.length,\n  criticalErrors: processedErrors.filter(e => e.classification.severity === 'critical').length,\n  retryableErrors: processedErrors.filter(e => e.classification.retryable).length,\n  performanceAlerts: performanceAlerts.length,\n  alertsSent: alertsSent.length,\n  status: processedErrors.some(e => e.classification.severity === 'critical') ? 'critical' :\n          processedErrors.some(e => e.classification.severity === 'high') ? 'warning' : 'stable'\n};\n\nconsole.log('🔍 错误处理摘要:', JSON.stringify(errorHandlingSummary));\n\nreturn {\n  json: {\n    ...inputData,\n    processedErrors: processedErrors,\n    errorHandlingSummary: errorHandlingSummary,\n    alertsSent: alertsSent,\n    errorHandlingCompleted: true,\n    \n    // 日志记录元数据\n    logMetadata: {\n      category: 'error_handling',\n      message: `错误处理完成 - 状态: ${errorHandlingSummary.status}`,\n      level: errorHandlingSummary.status === 'critical' ? 'error' : \n             errorHandlingSummary.status === 'warning' ? 'warn' : 'info',\n      errorData: errorHandlingSummary\n    }\n  }\n};"
      },
      "id": "error-handler",
      "name": "错误处理和告警",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1340, 300],
      "continueOnFail": true
    },
    
    {
      "parameters": {
        "functionCode": "// 工作流执行报告生成器\nconst WorkflowExecutionReporter = require('./workflow-execution-reporter.js');\n\nconst inputData = $input.first()?.json || {};\nconst workflowStatus = inputData.workflowStatus || {};\nconst executionReporter = workflowStatus.executionReporter;\n\nif (!executionReporter) {\n  console.warn('⚠️ 执行报告器未初始化，跳过报告生成');\n  return {\n    json: {\n      ...inputData,\n      reportGenerated: false,\n      reportSkipped: true\n    }\n  };\n}\n\n// 更新工作流状态为完成\nworkflowStatus.phase = 'completion';\nworkflowStatus.currentStep = 8;\nworkflowStatus.endTime = Date.now();\nworkflowStatus.duration = workflowStatus.endTime - workflowStatus.startTime;\nworkflowStatus.status = inputData.errorHandlingSummary?.status === 'critical' ? 'failed' : 'completed';\n\n// 准备执行数据\nconst executionData = {\n  executionId: workflowStatus.executionId,\n  workflowId: workflowStatus.workflowId,\n  workflowName: workflowStatus.workflowName,\n  startTime: workflowStatus.startTime,\n  endTime: workflowStatus.endTime,\n  duration: workflowStatus.duration,\n  status: workflowStatus.status,\n  \n  // 步骤统计\n  totalSteps: workflowStatus.totalSteps,\n  completedSteps: workflowStatus.currentStep,\n  failedSteps: inputData.processedErrors?.filter(e => e.classification.severity === 'critical').length || 0,\n  \n  // 数据处理统计\n  totalItemsCollected: inputData.items?.length || 0,\n  totalItemsProcessed: inputData.items?.length || 0,\n  successfulItems: inputData.items?.length || 0,\n  failedItems: inputData.errors?.length || 0,\n  duplicateItems: inputData.duplicatesFound || 0,\n  publishedItems: inputData.publishedItems || 0,\n  \n  // 来源统计\n  sourceStats: inputData.sourceStats || [],\n  qualityStats: inputData.qualityStats || {},\n  \n  // 性能数据\n  performanceMetrics: inputData.performanceMetrics || {},\n  performanceAlerts: inputData.performanceAlerts || [],\n  \n  // 错误数据\n  errors: inputData.errors || [],\n  processedErrors: inputData.processedErrors || [],\n  \n  // 工作流状态\n  workflowStatus: workflowStatus,\n  \n  // API调用统计\n  apiCalls: inputData.apiCalls || []\n};\n\ntry {\n  // 生成执行报告\n  const executionReport = await executionReporter.generateExecutionReport(executionData);\n  \n  // 生成报告摘要\n  const reportSummary = {\n    reportId: executionReport.reportMetadata.reportId,\n    executionId: executionData.executionId,\n    status: executionData.status,\n    duration: executionReport.executionSummary.basicInfo.durationFormatted,\n    itemsProcessed: executionData.totalItemsProcessed,\n    successRate: executionReport.executionSummary.itemProcessing.processingSuccessRate,\n    errorCount: executionData.errors.length,\n    performanceScore: executionReport.performanceAnalysis?.performanceScore || 0,\n    generatedAt: executionReport.reportMetadata.generatedAt\n  };\n  \n  console.log('📊 工作流执行报告已生成:', JSON.stringify(reportSummary));\n  \n  // 如果是定期报告时间，也生成定期报告\n  const now = new Date();\n  const shouldGeneratePeriodicReport = now.getMinutes() === 0 && now.getHours() % 6 === 0; // 每6小时\n  \n  let periodicReport = null;\n  if (shouldGeneratePeriodicReport) {\n    try {\n      const endDate = new Date();\n      const startDate = new Date(endDate.getTime() - 6 * 60 * 60 * 1000); // 过去6小时\n      periodicReport = await executionReporter.generatePeriodicReport('6hourly', startDate, endDate);\n      console.log('📈 定期报告已生成:', periodicReport.reportMetadata.reportId);\n    } catch (periodicError) {\n      console.error('❌ 生成定期报告失败:', periodicError.message);\n    }\n  }\n  \n  return {\n    json: {\n      ...inputData,\n      executionReport: executionReport,\n      reportSummary: reportSummary,\n      periodicReport: periodicReport,\n      reportGenerated: true,\n      workflowCompleted: true,\n      finalStatus: executionData.status,\n      \n      // 最终日志记录元数据\n      logMetadata: {\n        category: 'completion',\n        message: `工作流执行完成 - 状态: ${executionData.status}`,\n        level: executionData.status === 'failed' ? 'error' : 'info',\n        phase: 'completion',\n        step: 8,\n        totalSteps: 8,\n        finalSummary: reportSummary\n      }\n    }\n  };\n  \n} catch (error) {\n  console.error('❌ 生成执行报告失败:', error.message);\n  \n  return {\n    json: {\n      ...inputData,\n      reportGenerated: false,\n      reportError: error.message,\n      workflowCompleted: true,\n      finalStatus: 'completed_with_report_error',\n      \n      // 错误日志记录元数据\n      logMetadata: {\n        category: 'error',\n        message: `报告生成失败: ${error.message}`,\n        level: 'error',\n        phase: 'completion',\n        step: 8,\n        totalSteps: 8\n      }\n    }\n  };\n}"
      },
      "id": "execution-reporter",
      "name": "执行报告生成器",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1560, 300],
      "continueOnFail": true
    }
  ],
  
  "connections": {
    "cron-trigger": {
      "main": [[\n        {\n          "node": "workflow-initialization",\n          "type": "main",\n          "index": 0\n        }\n      ]]\n    },\n    "workflow-initialization": {\n      "main": [[\n        {\n          "node": "workflow-logger",\n          "type": "main",\n          "index": 0\n        }\n      ]]\n    },\n    "workflow-logger": {\n      "main": [[\n        {\n          "node": "enhanced-rss-collector",\n          "type": "main",\n          "index": 0\n        }\n      ]]\n    },\n    "enhanced-rss-collector": {\n      "main": [[\n        {\n          "node": "performance-monitor",\n          "type": "main",\n          "index": 0\n        }\n      ]]\n    },\n    "performance-monitor": {\n      "main": [[\n        {\n          "node": "error-handler",\n          "type": "main",\n          "index": 0\n        }\n      ]]\n    },\n    "error-handler": {\n      "main": [[\n        {\n          "node": "execution-reporter",\n          "type": "main",\n          "index": 0\n        }\n      ]]\n    }\n  },\n  \n  "settings": {\n    "timezone": "Asia/Shanghai",\n    "saveManualExecutions": true,\n    "callerPolicy": "workflowsFromSameOwner",\n    "executionTimeout": 600,\n    "maxExecutionTime": "10 minutes"\n  },\n  \n  "staticData": {},\n  \n  "meta": {\n    "templateCredsSetupCompleted": true\n  },\n  \n  "pinData": {},\n  \n  "versionId": "2.0.0"\n}