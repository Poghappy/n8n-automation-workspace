{
  "name": "错误处理和恢复机制集成配置",
  "description": "为n8n工作流集成增强的错误处理、自动重试和数据一致性保护功能",
  "version": "1.0.0",
  "createdAt": "2025-08-23T15:00:00.000Z",
  
  "errorHandlingNodes": {
    "description": "错误处理相关的n8n节点配置",
    
    "enhancedErrorHandler": {
      "nodeId": "enhanced-error-handler",
      "name": "增强错误处理器",
      "type": "n8n-nodes-base.function",
      "description": "提供分层错误处理、自动重试和恢复策略",
      
      "parameters": {
        "functionCode": "// 增强错误处理器集成\nconst EnhancedErrorHandler = require('./enhanced-error-handler.js');\n\n// 初始化错误处理器\nconst errorHandler = new EnhancedErrorHandler({\n  enableRetry: true,\n  enableCircuitBreaker: true,\n  enableDataConsistency: true,\n  maxRetryAttempts: 3,\n  baseRetryDelay: 1000,\n  circuitBreakerThreshold: 5,\n  circuitBreakerTimeout: 60000\n});\n\n// 获取输入数据\nconst inputData = $input.first()?.json || {};\nconst error = inputData.error || $execution.lastNodeExecuted?.error;\nconst context = {\n  service: inputData.service || $node.name,\n  operation: inputData.operation || 'workflow_step',\n  workflowId: $workflow.id,\n  executionId: $execution.id,\n  retryAttempt: inputData.retryAttempt || 0,\n  phase: inputData.phase || inputData.workflowStatus?.phase || 'unknown',\n  \n  // 重试回调函数\n  retryCallback: async (retryContext) => {\n    console.log(`🔄 执行重试回调 - 尝试 ${retryContext.retryAttempt}`);\n    \n    // 这里可以实现具体的重试逻辑\n    // 例如重新调用失败的API或重新处理数据\n    \n    if (inputData.retryFunction && typeof inputData.retryFunction === 'function') {\n      return await inputData.retryFunction(retryContext);\n    }\n    \n    // 默认重试逻辑：返回成功（模拟重试成功）\n    return {\n      success: Math.random() > 0.3, // 70% 成功率\n      data: { retryAttempt: retryContext.retryAttempt, timestamp: Date.now() }\n    };\n  },\n  \n  // 上下文数据\n  inputData: inputData,\n  backupEndpoint: inputData.backupEndpoint,\n  backupAuth: inputData.backupAuth,\n  timeout: inputData.timeout || 30000,\n  requestRate: inputData.requestRate || 10\n};\n\n// 处理错误（如果存在）\nif (error || inputData.forceErrorHandling) {\n  try {\n    console.log('🚨 检测到错误，启动增强错误处理...');\n    \n    const handleResult = await errorHandler.handleError(error || new Error(inputData.simulatedError || '模拟错误'), context);\n    \n    console.log('✅ 错误处理完成:', JSON.stringify({\n      success: handleResult.success,\n      errorId: handleResult.errorId,\n      classification: handleResult.classification?.category,\n      shouldRetry: handleResult.shouldRetry,\n      shouldSkip: handleResult.shouldSkip,\n      shouldAbort: handleResult.shouldAbort\n    }));\n    \n    return {\n      json: {\n        ...inputData,\n        errorHandling: {\n          processed: true,\n          result: handleResult,\n          timestamp: new Date().toISOString()\n        },\n        \n        // 控制流程\n        shouldRetry: handleResult.shouldRetry,\n        shouldSkip: handleResult.shouldSkip,\n        shouldAbort: handleResult.shouldAbort,\n        \n        // 错误信息\n        errorId: handleResult.errorId,\n        errorClassification: handleResult.classification,\n        recoveryResult: handleResult.recoveryResult,\n        \n        // 日志元数据\n        logMetadata: {\n          category: 'error_handling',\n          message: `错误处理完成 - ${handleResult.classification?.category || 'unknown'}`,\n          level: handleResult.shouldAbort ? 'error' : handleResult.shouldSkip ? 'warn' : 'info',\n          errorHandled: true\n        }\n      }\n    };\n    \n  } catch (handlingError) {\n    console.error('❌ 错误处理器失败:', handlingError);\n    \n    return {\n      json: {\n        ...inputData,\n        errorHandling: {\n          processed: false,\n          error: handlingError.message,\n          timestamp: new Date().toISOString()\n        },\n        shouldAbort: true,\n        criticalError: true,\n        \n        logMetadata: {\n          category: 'error_handling',\n          message: `错误处理器失败: ${handlingError.message}`,\n          level: 'error',\n          critical: true\n        }\n      }\n    };\n  }\n} else {\n  // 没有错误，直接传递数据\n  return {\n    json: {\n      ...inputData,\n      errorHandling: {\n        processed: false,\n        reason: 'no_error_detected',\n        timestamp: new Date().toISOString()\n      },\n      shouldContinue: true,\n      \n      logMetadata: {\n        category: 'error_handling',\n        message: '无错误检测，继续执行',\n        level: 'debug'\n      }\n    }\n  };\n}"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "dataConsistencyManager": {
      "nodeId": "data-consistency-manager",
      "name": "数据一致性管理器",
      "type": "n8n-nodes-base.function",
      "description": "管理数据一致性、事务和回滚机制",
      
      "parameters": {
        "functionCode": "// 数据一致性管理器集成\nconst DataConsistencyManager = require('./data-consistency-manager.js');\n\n// 初始化数据一致性管理器\nconst consistencyManager = new DataConsistencyManager({\n  enableTransactions: true,\n  enableRollback: true,\n  enableVersioning: true,\n  enableChecksums: true,\n  consistencyCheckInterval: 30000,\n  maxRollbackDepth: 10,\n  transactionTimeout: 300000\n});\n\n// 获取输入数据\nconst inputData = $input.first()?.json || {};\nconst operation = inputData.operation || 'unknown';\nconst transactionId = inputData.transactionId;\n\n// 处理不同的一致性操作\ntry {\n  let result = { success: false, data: null };\n  \n  switch (operation) {\n    case 'begin_transaction':\n      console.log('🔄 开始数据一致性事务...');\n      const beginResult = await consistencyManager.beginTransaction(\n        inputData.customTransactionId,\n        {\n          workflowId: $workflow.id,\n          executionId: $execution.id,\n          phase: inputData.phase || 'unknown',\n          operation: inputData.operationType || 'workflow_step'\n        }\n      );\n      result = {\n        success: beginResult.success,\n        transactionId: beginResult.transactionId,\n        message: '事务已开始'\n      };\n      break;\n      \n    case 'record_operation':\n      console.log(`📝 记录数据操作 - 事务: ${transactionId}`);\n      if (!transactionId) {\n        throw new Error('缺少事务ID');\n      }\n      \n      const operationId = await consistencyManager.recordOperation(transactionId, {\n        type: inputData.operationType || 'update',\n        target: inputData.target || `${$node.name}_${Date.now()}`,\n        data: inputData.operationData || inputData\n      });\n      \n      result = {\n        success: true,\n        operationId: operationId,\n        transactionId: transactionId,\n        message: '操作已记录'\n      };\n      break;\n      \n    case 'commit_transaction':\n      console.log(`✅ 提交事务: ${transactionId}`);\n      if (!transactionId) {\n        throw new Error('缺少事务ID');\n      }\n      \n      const commitResult = await consistencyManager.commitTransaction(transactionId);\n      result = {\n        success: commitResult.success,\n        transactionId: commitResult.transactionId,\n        operationsCount: commitResult.operationsCount,\n        duration: commitResult.duration,\n        message: '事务已提交'\n      };\n      break;\n      \n    case 'rollback_transaction':\n      console.log(`🔄 回滚事务: ${transactionId}`);\n      if (!transactionId) {\n        throw new Error('缺少事务ID');\n      }\n      \n      const rollbackResult = await consistencyManager.rollbackTransaction(\n        transactionId,\n        inputData.rollbackReason || 'manual_rollback'\n      );\n      result = {\n        success: rollbackResult.success,\n        transactionId: rollbackResult.transactionId,\n        operationsRolledBack: rollbackResult.operationsRolledBack,\n        reason: rollbackResult.reason,\n        message: '事务已回滚'\n      };\n      break;\n      \n    case 'check_consistency':\n      console.log('🔍 执行一致性检查...');\n      await consistencyManager.performPeriodicConsistencyCheck();\n      result = {\n        success: true,\n        message: '一致性检查已完成',\n        timestamp: new Date().toISOString()\n      };\n      break;\n      \n    case 'get_statistics':\n      const stats = consistencyManager.getStatistics();\n      result = {\n        success: true,\n        statistics: stats,\n        message: '统计信息已获取'\n      };\n      break;\n      \n    default:\n      // 默认操作：传递数据并确保一致性\n      result = {\n        success: true,\n        data: inputData,\n        message: '数据已传递，一致性已确保'\n      };\n  }\n  \n  console.log(`📊 数据一致性操作完成: ${operation}`);\n  \n  return {\n    json: {\n      ...inputData,\n      consistencyManagement: {\n        operation: operation,\n        result: result,\n        timestamp: new Date().toISOString(),\n        processed: true\n      },\n      \n      // 传递事务ID给后续节点\n      transactionId: result.transactionId || transactionId,\n      \n      // 日志元数据\n      logMetadata: {\n        category: 'data_consistency',\n        message: `数据一致性操作: ${operation} - ${result.message}`,\n        level: result.success ? 'info' : 'error',\n        operation: operation\n      }\n    }\n  };\n  \n} catch (error) {\n  console.error('❌ 数据一致性管理失败:', error);\n  \n  return {\n    json: {\n      ...inputData,\n      consistencyManagement: {\n        operation: operation,\n        error: error.message,\n        timestamp: new Date().toISOString(),\n        processed: false\n      },\n      consistencyError: true,\n      \n      logMetadata: {\n        category: 'data_consistency',\n        message: `数据一致性操作失败: ${error.message}`,\n        level: 'error',\n        operation: operation\n      }\n    }\n  };\n}"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "errorRecoveryOrchestrator": {
      "nodeId": "error-recovery-orchestrator",
      "name": "错误恢复编排器",
      "type": "n8n-nodes-base.function",
      "description": "协调整个工作流的错误恢复过程",
      
      "parameters": {
        "functionCode": "// 错误恢复编排器集成\nconst ErrorRecoveryOrchestrator = require('./error-recovery-orchestrator.js');\n\n// 初始化错误恢复编排器\nconst recoveryOrchestrator = new ErrorRecoveryOrchestrator({\n  enableAutoRecovery: true,\n  enableFailover: true,\n  enableGracefulDegradation: true,\n  maxRecoveryAttempts: 3,\n  recoveryTimeout: 300000,\n  healthCheckInterval: 60000,\n  \n  // 错误处理器配置\n  errorHandler: {\n    enableRetry: true,\n    enableCircuitBreaker: true,\n    maxRetryAttempts: 3,\n    baseRetryDelay: 1000\n  },\n  \n  // 数据一致性管理器配置\n  consistencyManager: {\n    enableTransactions: true,\n    enableRollback: true,\n    enableVersioning: true\n  }\n});\n\n// 获取输入数据\nconst inputData = $input.first()?.json || {};\nconst error = inputData.error || $execution.lastNodeExecuted?.error;\nconst operation = inputData.operation || 'orchestrate_recovery';\n\n// 构建恢复上下文\nconst recoveryContext = {\n  workflowId: $workflow.id,\n  executionId: $execution.id,\n  workflowName: $workflow.name,\n  phase: inputData.phase || inputData.workflowStatus?.phase || 'unknown',\n  service: inputData.service || $node.name,\n  operation: inputData.operationType || 'workflow_step',\n  \n  // 恢复相关数据\n  recoveryAttempts: inputData.recoveryAttempts || 0,\n  transactionId: inputData.transactionId,\n  \n  // 备用资源\n  backupSources: inputData.backupSources,\n  backupEndpoint: inputData.backupEndpoint,\n  backupAuth: inputData.backupAuth,\n  backupService: inputData.backupService,\n  \n  // 配置参数\n  batchSize: inputData.batchSize,\n  timeout: inputData.timeout,\n  requestRate: inputData.requestRate,\n  \n  // 原始数据\n  originalData: inputData\n};\n\ntry {\n  let result = { success: false, data: null };\n  \n  switch (operation) {\n    case 'orchestrate_recovery':\n      if (!error && !inputData.forceRecovery) {\n        // 没有错误，直接传递数据\n        result = {\n          success: true,\n          data: inputData,\n          message: '无需恢复，正常执行',\n          nextAction: 'continue_workflow'\n        };\n      } else {\n        console.log('🚨 启动错误恢复编排...');\n        \n        const recoveryResult = await recoveryOrchestrator.orchestrateRecovery(\n          error || new Error(inputData.simulatedError || '模拟恢复场景'),\n          recoveryContext\n        );\n        \n        result = {\n          success: recoveryResult.success,\n          recoveryId: recoveryResult.recoveryId,\n          strategy: recoveryResult.strategy,\n          duration: recoveryResult.duration,\n          nextAction: recoveryResult.nextAction,\n          data: recoveryResult.result?.data || inputData,\n          message: recoveryResult.success ? '恢复成功' : '恢复失败'\n        };\n        \n        console.log(`${recoveryResult.success ? '✅' : '❌'} 错误恢复编排完成: ${recoveryResult.recoveryId}`);\n      }\n      break;\n      \n    case 'get_recovery_statistics':\n      const stats = recoveryOrchestrator.getStatistics();\n      result = {\n        success: true,\n        statistics: stats,\n        message: '恢复统计信息已获取'\n      };\n      break;\n      \n    case 'health_check':\n      console.log('🔍 执行系统健康检查...');\n      const healthResult = await recoveryOrchestrator.analyzeSystemHealth(recoveryContext);\n      result = {\n        success: true,\n        health: healthResult,\n        message: `系统健康状态: ${healthResult.overall}`\n      };\n      break;\n      \n    default:\n      result = {\n        success: true,\n        data: inputData,\n        message: '未知操作，数据已传递'\n      };\n  }\n  \n  return {\n    json: {\n      ...inputData,\n      errorRecovery: {\n        operation: operation,\n        result: result,\n        timestamp: new Date().toISOString(),\n        processed: true\n      },\n      \n      // 控制流程\n      shouldContinue: result.nextAction === 'continue_workflow',\n      shouldRetry: result.nextAction === 'retry_validation',\n      shouldEscalate: result.nextAction === 'escalate_to_manual',\n      \n      // 恢复数据\n      recoveryId: result.recoveryId,\n      recoveryStrategy: result.strategy,\n      recoverySuccess: result.success,\n      \n      // 日志元数据\n      logMetadata: {\n        category: 'error_recovery',\n        message: `错误恢复编排: ${operation} - ${result.message}`,\n        level: result.success ? 'info' : 'error',\n        operation: operation,\n        recoveryData: {\n          recoveryId: result.recoveryId,\n          strategy: result.strategy,\n          duration: result.duration\n        }\n      }\n    }\n  };\n  \n} catch (orchestrationError) {\n  console.error('❌ 错误恢复编排失败:', orchestrationError);\n  \n  return {\n    json: {\n      ...inputData,\n      errorRecovery: {\n        operation: operation,\n        error: orchestrationError.message,\n        timestamp: new Date().toISOString(),\n        processed: false\n      },\n      orchestrationError: true,\n      shouldEscalate: true,\n      \n      logMetadata: {\n        category: 'error_recovery',\n        message: `错误恢复编排失败: ${orchestrationError.message}`,\n        level: 'error',\n        critical: true,\n        operation: operation\n      }\n    }\n  };\n}"
      },\n      \n      \"settings\": {\n        \"continueOnFail\": true,\n        \"retryOnFail\": false,\n        \"executeOnce\": false\n      }\n    }\n  },\n  \n  \"workflowIntegration\": {\n    \"description\": \"错误处理机制在工作流中的集成方式\",\n    \n    \"integrationPoints\": {\n      \"dataCollection\": {\n        \"phase\": \"data_collection\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"retry_with_fallback\",\n          \"maxRetries\": 3,\n          \"fallbackSources\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": true,\n          \"transactionScope\": \"collection_batch\",\n          \"rollbackOnFailure\": true\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"gracefulDegradation\": true\n        }\n      },\n      \n      \"contentProcessing\": {\n        \"phase\": \"content_processing\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"skip_and_continue\",\n          \"maxRetries\": 2,\n          \"fallbackProcessing\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": true,\n          \"transactionScope\": \"processing_batch\",\n          \"versionControl\": true\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"simplifiedProcessing\": true\n        }\n      },\n      \n      \"notionStorage\": {\n        \"phase\": \"notion_storage\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"retry_with_backoff\",\n          \"maxRetries\": 5,\n          \"circuitBreaker\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": true,\n          \"transactionScope\": \"storage_operation\",\n          \"rollbackOnFailure\": true,\n          \"checksumValidation\": true\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"backupStorage\": true,\n          \"localCaching\": true\n        }\n      },\n      \n      \"aiManagement\": {\n        \"phase\": \"ai_management\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"degrade_gracefully\",\n          \"maxRetries\": 2,\n          \"fallbackAI\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": false,\n          \"reason\": \"AI operations are stateless\"\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"disableOnFailure\": true\n        }\n      },\n      \n      \"firebirdPublish\": {\n        \"phase\": \"firebird_publish\",\n        \"errorHandling\": {\n          \"enabled\": true,\n          \"strategy\": \"retry_with_auth_refresh\",\n          \"maxRetries\": 3,\n          \"authRefresh\": true\n        },\n        \"consistencyManagement\": {\n          \"enabled\": true,\n          \"transactionScope\": \"publish_operation\",\n          \"rollbackOnFailure\": true,\n          \"crossSystemConsistency\": true\n        },\n        \"recoveryOrchestration\": {\n          \"enabled\": true,\n          \"autoRecovery\": true,\n          \"queueForRetry\": true,\n          \"notifyOnFailure\": true\n        }\n      }\n    },\n    \n    \"nodeConnections\": {\n      \"description\": \"节点之间的连接和数据流\",\n      \n      \"errorHandlingFlow\": {\n        \"trigger\": \"on_error_or_condition\",\n        \"sequence\": [\n          \"enhanced-error-handler\",\n          \"data-consistency-manager\",\n          \"error-recovery-orchestrator\"\n        ],\n        \"conditionalRouting\": {\n          \"shouldRetry\": \"retry_node\",\n          \"shouldSkip\": \"skip_to_next_phase\",\n          \"shouldAbort\": \"abort_workflow\",\n          \"shouldEscalate\": \"manual_intervention_node\"\n        }\n      },\n      \n      \"dataConsistencyFlow\": {\n        \"beforeOperation\": \"begin_transaction\",\n        \"duringOperation\": \"record_operation\",\n        \"afterSuccess\": \"commit_transaction\",\n        \"afterFailure\": \"rollback_transaction\",\n        \"periodicCheck\": \"check_consistency\"\n      },\n      \n      \"recoveryOrchestrationFlow\": {\n        \"onError\": \"orchestrate_recovery\",\n        \"healthMonitoring\": \"health_check\",\n        \"statisticsCollection\": \"get_recovery_statistics\"\n      }\n    }\n  },\n  \n  \"configuration\": {\n    \"description\": \"错误处理机制的配置参数\",\n    \n    \"globalSettings\": {\n      \"enableErrorHandling\": true,\n      \"enableDataConsistency\": true,\n      \"enableRecoveryOrchestration\": true,\n      \"enableDetailedLogging\": true,\n      \"enablePerformanceMonitoring\": true\n    },\n    \n    \"errorHandlingSettings\": {\n      \"maxRetryAttempts\": 3,\n      \"baseRetryDelay\": 1000,\n      \"maxRetryDelay\": 30000,\n      \"retryBackoffStrategy\": \"exponential\",\n      \"circuitBreakerThreshold\": 5,\n      \"circuitBreakerTimeout\": 60000,\n      \"enableJitter\": true\n    },\n    \n    \"consistencySettings\": {\n      \"transactionTimeout\": 300000,\n      \"maxRollbackDepth\": 10,\n      \"enableVersioning\": true,\n      \"enableChecksums\": true,\n      \"consistencyCheckInterval\": 30000,\n      \"autoCleanupInterval\": 3600000\n    },\n    \n    \"recoverySettings\": {\n      \"maxRecoveryAttempts\": 3,\n      \"recoveryTimeout\": 300000,\n      \"healthCheckInterval\": 60000,\n      \"enableAutoRecovery\": true,\n      \"enableFailover\": true,\n      \"enableGracefulDegradation\": true\n    },\n    \n    \"alertingSettings\": {\n      \"enableAlerts\": true,\n      \"webhookUrl\": \"${WEBHOOK_ALERT_URL}\",\n      \"alertThresholds\": {\n        \"errorRate\": 5,\n        \"responseTime\": 5000,\n        \"memoryUsage\": 80,\n        \"consecutiveFailures\": 3\n      },\n      \"alertCooldown\": 300000\n    }\n  },\n  \n  \"monitoring\": {\n    \"description\": \"错误处理和恢复的监控配置\",\n    \n    \"metrics\": {\n      \"errorMetrics\": {\n        \"totalErrors\": \"counter\",\n        \"errorsByCategory\": \"counter_by_label\",\n        \"errorRate\": \"gauge\",\n        \"recoverySuccessRate\": \"gauge\",\n        \"averageRecoveryTime\": \"histogram\"\n      },\n      \n      \"consistencyMetrics\": {\n        \"activeTransactions\": \"gauge\",\n        \"committedTransactions\": \"counter\",\n        \"rolledBackTransactions\": \"counter\",\n        \"consistencyCheckFailures\": \"counter\",\n        \"dataIntegrityScore\": \"gauge\"\n      },\n      \n      \"recoveryMetrics\": {\n        \"recoveryAttempts\": \"counter\",\n        \"successfulRecoveries\": \"counter\",\n        \"failedRecoveries\": \"counter\",\n        \"averageRecoveryDuration\": \"histogram\",\n        \"systemHealthScore\": \"gauge\"\n      }\n    },\n    \n    \"dashboards\": {\n      \"errorHandlingDashboard\": {\n        \"panels\": [\n          \"error_rate_over_time\",\n          \"error_distribution_by_category\",\n          \"recovery_success_rate\",\n          \"circuit_breaker_status\",\n          \"retry_attempts_distribution\"\n        ]\n      },\n      \n      \"dataConsistencyDashboard\": {\n        \"panels\": [\n          \"transaction_status_overview\",\n          \"rollback_frequency\",\n          \"consistency_check_results\",\n          \"data_integrity_trends\",\n          \"version_history_growth\"\n        ]\n      },\n      \n      \"systemHealthDashboard\": {\n        \"panels\": [\n          \"overall_system_health\",\n          \"component_health_status\",\n          \"recovery_orchestration_activity\",\n          \"performance_degradation_alerts\",\n          \"resource_utilization_trends\"\n        ]\n      }\n    }\n  },\n  \n  \"testing\": {\n    \"description\": \"错误处理机制的测试配置\",\n    \n    \"testScenarios\": {\n      \"networkFailure\": {\n        \"description\": \"模拟网络连接失败\",\n        \"errorType\": \"network\",\n        \"expectedRecovery\": \"retry_with_backoff\",\n        \"expectedOutcome\": \"success_after_retry\"\n      },\n      \n      \"authenticationFailure\": {\n        \"description\": \"模拟认证失败\",\n        \"errorType\": \"authentication\",\n        \"expectedRecovery\": \"refresh_credentials\",\n        \"expectedOutcome\": \"success_after_auth_refresh\"\n      },\n      \n      \"rateLimitExceeded\": {\n        \"description\": \"模拟API限流\",\n        \"errorType\": \"rate_limit\",\n        \"expectedRecovery\": \"exponential_backoff\",\n        \"expectedOutcome\": \"success_after_delay\"\n      },\n      \n      \"dataCorruption\": {\n        \"description\": \"模拟数据损坏\",\n        \"errorType\": \"validation\",\n        \"expectedRecovery\": \"rollback_transaction\",\n        \"expectedOutcome\": \"data_integrity_preserved\"\n      },\n      \n      \"systemOverload\": {\n        \"description\": \"模拟系统过载\",\n        \"errorType\": \"resource_exhaustion\",\n        \"expectedRecovery\": \"graceful_degradation\",\n        \"expectedOutcome\": \"reduced_functionality_maintained\"\n      }\n    },\n    \n    \"validationCriteria\": {\n      \"errorDetection\": \"All errors must be properly classified\",\n      \"recoveryExecution\": \"Recovery strategies must execute within timeout\",\n      \"dataConsistency\": \"Data integrity must be maintained throughout recovery\",\n      \"systemStability\": \"System must remain stable during recovery operations\",\n      \"performanceImpact\": \"Recovery overhead must not exceed 20% of normal operation time\"\n    }\n  },\n  \n  \"deployment\": {\n    \"description\": \"错误处理机制的部署说明\",\n    \n    \"prerequisites\": [\n      \"Node.js runtime with ES2020+ support\",\n      \"n8n workflow engine v1.0+\",\n      \"Sufficient memory for transaction history (minimum 512MB)\",\n      \"Network access for external service monitoring\",\n      \"Write permissions for log and backup storage\"\n    ],\n    \n    \"installationSteps\": [\n      \"Copy error handling modules to n8n-config directory\",\n      \"Configure environment variables for error handling\",\n      \"Import error handling nodes into n8n workflow\",\n      \"Configure node connections and conditional routing\",\n      \"Test error handling scenarios\",\n      \"Enable monitoring and alerting\",\n      \"Deploy to production environment\"\n    ],\n    \n    \"environmentVariables\": {\n      \"ENABLE_ERROR_HANDLING\": \"true\",\n      \"ENABLE_DATA_CONSISTENCY\": \"true\",\n      \"ENABLE_RECOVERY_ORCHESTRATION\": \"true\",\n      \"ERROR_HANDLING_LOG_LEVEL\": \"info\",\n      \"WEBHOOK_ALERT_URL\": \"https://your-webhook-url.com/alerts\",\n      \"TRANSACTION_TIMEOUT\": \"300000\",\n      \"MAX_RETRY_ATTEMPTS\": \"3\",\n      \"CIRCUIT_BREAKER_THRESHOLD\": \"5\",\n      \"HEALTH_CHECK_INTERVAL\": \"60000\"\n    }\n  }\n}"