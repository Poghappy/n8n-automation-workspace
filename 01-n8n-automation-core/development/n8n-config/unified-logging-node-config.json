{
  "name": "统一日志记录节点配置",
  "description": "为n8n工作流提供统一的日志记录、性能监控和错误处理功能",
  "version": "1.0.0",
  "createdAt": "2025-08-23T14:30:00.000Z",
  
  "loggingNodes": {
    "description": "各种日志记录节点的配置",
    
    "workflowLogger": {
      "nodeId": "workflow-logger",
      "name": "工作流日志记录器",
      "type": "n8n-nodes-base.function",
      "description": "记录工作流执行的关键事件和状态变化",
      
      "parameters": {
        "functionCode": "// 统一工作流日志记录器\nconst logLevel = process.env.WORKFLOW_LOG_LEVEL || 'info';\nconst enableStructuredLogging = process.env.ENABLE_STRUCTURED_LOGGING !== 'false';\nconst logDestination = process.env.LOG_DESTINATION || 'console';\n\n// 日志级别映射\nconst LOG_LEVELS = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3,\n  trace: 4\n};\n\n// 获取当前日志级别数值\nconst currentLogLevel = LOG_LEVELS[logLevel] || LOG_LEVELS.info;\n\n// 日志记录函数\nfunction log(level, category, message, metadata = {}) {\n  if (LOG_LEVELS[level] > currentLogLevel) {\n    return; // 跳过低于当前级别的日志\n  }\n  \n  const logEntry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    category: category,\n    executionId: $execution.id,\n    workflowId: $workflow.id,\n    workflowName: $workflow.name,\n    nodeId: $node.id || 'unknown',\n    nodeName: $node.name || 'unknown',\n    message: message,\n    metadata: {\n      ...metadata,\n      memoryUsage: process.memoryUsage ? process.memoryUsage() : null,\n      timestamp: Date.now()\n    }\n  };\n  \n  // 敏感数据脱敏\n  if (logEntry.metadata) {\n    logEntry.metadata = sanitizeMetadata(logEntry.metadata);\n  }\n  \n  if (enableStructuredLogging) {\n    console.log(JSON.stringify(logEntry));\n  } else {\n    console.log(`[${logEntry.timestamp}] ${logEntry.level} [${logEntry.category}] ${logEntry.message}`);\n  }\n  \n  return logEntry;\n}\n\n// 敏感数据脱敏函数\nfunction sanitizeMetadata(metadata) {\n  const sensitiveKeys = ['password', 'token', 'key', 'secret', 'credential', 'auth'];\n  const sanitized = { ...metadata };\n  \n  function sanitizeObject(obj) {\n    if (typeof obj !== 'object' || obj === null) return obj;\n    \n    const result = Array.isArray(obj) ? [] : {};\n    \n    for (const [key, value] of Object.entries(obj)) {\n      const lowerKey = key.toLowerCase();\n      const isSensitive = sensitiveKeys.some(sensitive => lowerKey.includes(sensitive));\n      \n      if (isSensitive && typeof value === 'string') {\n        result[key] = '***MASKED***';\n      } else if (typeof value === 'object' && value !== null) {\n        result[key] = sanitizeObject(value);\n      } else if (typeof value === 'string' && value.length > 1000) {\n        result[key] = value.substring(0, 1000) + '...[truncated]';\n      } else {\n        result[key] = value;\n      }\n    }\n    \n    return result;\n  }\n  \n  return sanitizeObject(sanitized);\n}\n\n// 获取输入数据\nconst inputData = $input.first()?.json || {};\nconst logCategory = inputData.logCategory || 'workflow';\nconst logMessage = inputData.logMessage || '工作流步骤执行';\nconst logMetadata = inputData.logMetadata || {};\nconst logLevelOverride = inputData.logLevel || 'info';\n\n// 性能指标收集\nconst performanceMetrics = {\n  nodeExecutionTime: Date.now() - ($execution.startedAt ? new Date($execution.startedAt).getTime() : Date.now()),\n  itemCount: $input.all().length,\n  dataSize: JSON.stringify($input.all()).length,\n  processingRate: $input.all().length / Math.max(1, (Date.now() - ($execution.startedAt ? new Date($execution.startedAt).getTime() : Date.now())) / 1000)\n};\n\n// 记录日志\nconst logEntry = log(logLevelOverride, logCategory, logMessage, {\n  ...logMetadata,\n  performanceMetrics,\n  inputDataSummary: {\n    itemCount: $input.all().length,\n    hasErrors: inputData.errors && inputData.errors.length > 0,\n    status: inputData.status || 'unknown'\n  }\n});\n\n// 返回原始数据和日志信息\nreturn {\n  json: {\n    ...inputData,\n    logEntry: logEntry,\n    logged: true,\n    logTimestamp: new Date().toISOString()\n  }\n};"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "performanceMonitor": {
      "nodeId": "performance-monitor",
      "name": "性能监控器",
      "type": "n8n-nodes-base.function",
      "description": "收集和分析工作流性能指标",
      
      "parameters": {
        "functionCode": "// 性能监控和指标收集器\nconst startTime = Date.now();\nconst inputData = $input.first()?.json || {};\nconst previousMetrics = inputData.performanceMetrics || {};\n\n// 系统性能指标收集\nfunction collectSystemMetrics() {\n  const memUsage = process.memoryUsage ? process.memoryUsage() : {};\n  \n  return {\n    memory: {\n      rss: memUsage.rss || 0,\n      heapTotal: memUsage.heapTotal || 0,\n      heapUsed: memUsage.heapUsed || 0,\n      external: memUsage.external || 0,\n      arrayBuffers: memUsage.arrayBuffers || 0,\n      heapUsagePercent: memUsage.heapTotal ? (memUsage.heapUsed / memUsage.heapTotal * 100) : 0\n    },\n    process: {\n      uptime: process.uptime ? process.uptime() : 0,\n      pid: process.pid || 0,\n      platform: process.platform || 'unknown',\n      nodeVersion: process.version || 'unknown'\n    },\n    timestamp: Date.now()\n  };\n}\n\n// 工作流性能指标计算\nfunction calculateWorkflowMetrics() {\n  const executionStartTime = $execution.startedAt ? new Date($execution.startedAt).getTime() : startTime;\n  const currentTime = Date.now();\n  const totalExecutionTime = currentTime - executionStartTime;\n  \n  const itemCount = $input.all().length;\n  const dataSize = JSON.stringify($input.all()).length;\n  \n  return {\n    execution: {\n      totalTime: totalExecutionTime,\n      currentStepTime: currentTime - (previousMetrics.lastStepTime || executionStartTime),\n      itemsProcessed: itemCount,\n      dataSize: dataSize,\n      throughput: itemCount / Math.max(1, totalExecutionTime / 1000),\n      averageItemSize: itemCount > 0 ? dataSize / itemCount : 0\n    },\n    workflow: {\n      executionId: $execution.id,\n      workflowId: $workflow.id,\n      workflowName: $workflow.name,\n      nodeId: $node.id || 'unknown',\n      nodeName: $node.name || 'unknown'\n    },\n    quality: {\n      errorCount: (inputData.errors && inputData.errors.length) || 0,\n      successRate: itemCount > 0 ? ((itemCount - ((inputData.errors && inputData.errors.length) || 0)) / itemCount * 100) : 100,\n      averageQualityScore: inputData.averageQualityScore || 0\n    }\n  };\n}\n\n// API性能指标收集\nfunction collectApiMetrics() {\n  const apiCalls = inputData.apiCalls || [];\n  \n  if (apiCalls.length === 0) {\n    return {\n      totalCalls: 0,\n      averageResponseTime: 0,\n      successRate: 100,\n      errorRate: 0\n    };\n  }\n  \n  const totalResponseTime = apiCalls.reduce((sum, call) => sum + (call.responseTime || 0), 0);\n  const successfulCalls = apiCalls.filter(call => call.success).length;\n  \n  return {\n    totalCalls: apiCalls.length,\n    averageResponseTime: totalResponseTime / apiCalls.length,\n    successRate: (successfulCalls / apiCalls.length) * 100,\n    errorRate: ((apiCalls.length - successfulCalls) / apiCalls.length) * 100,\n    slowestCall: Math.max(...apiCalls.map(call => call.responseTime || 0)),\n    fastestCall: Math.min(...apiCalls.map(call => call.responseTime || Infinity))\n  };\n}\n\n// 性能阈值检查\nfunction checkPerformanceThresholds(metrics) {\n  const thresholds = {\n    executionTime: {\n      warning: 180000, // 3分钟\n      critical: 300000 // 5分钟\n    },\n    memoryUsage: {\n      warning: 80, // 80%\n      critical: 95  // 95%\n    },\n    throughput: {\n      warning: 5,  // 5 items/second\n      critical: 1  // 1 item/second\n    },\n    errorRate: {\n      warning: 5,  // 5%\n      critical: 10 // 10%\n    }\n  };\n  \n  const alerts = [];\n  \n  // 检查执行时间\n  if (metrics.execution.totalTime > thresholds.executionTime.critical) {\n    alerts.push({\n      type: 'critical',\n      metric: 'execution_time',\n      value: metrics.execution.totalTime,\n      threshold: thresholds.executionTime.critical,\n      message: `工作流执行时间超过临界值: ${Math.round(metrics.execution.totalTime/1000)}秒`\n    });\n  } else if (metrics.execution.totalTime > thresholds.executionTime.warning) {\n    alerts.push({\n      type: 'warning',\n      metric: 'execution_time',\n      value: metrics.execution.totalTime,\n      threshold: thresholds.executionTime.warning,\n      message: `工作流执行时间超过警告值: ${Math.round(metrics.execution.totalTime/1000)}秒`\n    });\n  }\n  \n  // 检查内存使用\n  const memoryUsagePercent = metrics.system?.memory?.heapUsagePercent || 0;\n  if (memoryUsagePercent > thresholds.memoryUsage.critical) {\n    alerts.push({\n      type: 'critical',\n      metric: 'memory_usage',\n      value: memoryUsagePercent,\n      threshold: thresholds.memoryUsage.critical,\n      message: `内存使用率超过临界值: ${Math.round(memoryUsagePercent)}%`\n    });\n  } else if (memoryUsagePercent > thresholds.memoryUsage.warning) {\n    alerts.push({\n      type: 'warning',\n      metric: 'memory_usage',\n      value: memoryUsagePercent,\n      threshold: thresholds.memoryUsage.warning,\n      message: `内存使用率超过警告值: ${Math.round(memoryUsagePercent)}%`\n    });\n  }\n  \n  // 检查错误率\n  const errorRate = metrics.quality?.errorCount > 0 ? (metrics.quality.errorCount / metrics.execution.itemsProcessed * 100) : 0;\n  if (errorRate > thresholds.errorRate.critical) {\n    alerts.push({\n      type: 'critical',\n      metric: 'error_rate',\n      value: errorRate,\n      threshold: thresholds.errorRate.critical,\n      message: `错误率超过临界值: ${Math.round(errorRate)}%`\n    });\n  } else if (errorRate > thresholds.errorRate.warning) {\n    alerts.push({\n      type: 'warning',\n      metric: 'error_rate',\n      value: errorRate,\n      threshold: thresholds.errorRate.warning,\n      message: `错误率超过警告值: ${Math.round(errorRate)}%`\n    });\n  }\n  \n  return alerts;\n}\n\n// 收集所有性能指标\nconst systemMetrics = collectSystemMetrics();\nconst workflowMetrics = calculateWorkflowMetrics();\nconst apiMetrics = collectApiMetrics();\n\n// 合并性能指标\nconst allMetrics = {\n  system: systemMetrics,\n  workflow: workflowMetrics,\n  api: apiMetrics,\n  collection: {\n    timestamp: Date.now(),\n    collectionTime: Date.now() - startTime,\n    lastStepTime: Date.now()\n  }\n};\n\n// 检查性能阈值\nconst performanceAlerts = checkPerformanceThresholds({\n  execution: workflowMetrics.execution,\n  system: systemMetrics,\n  quality: workflowMetrics.quality\n});\n\n// 生成性能摘要\nconst performanceSummary = {\n  status: performanceAlerts.some(alert => alert.type === 'critical') ? 'critical' : \n          performanceAlerts.some(alert => alert.type === 'warning') ? 'warning' : 'healthy',\n  executionTime: workflowMetrics.execution.totalTime,\n  memoryUsage: systemMetrics.memory.heapUsagePercent,\n  throughput: workflowMetrics.execution.throughput,\n  errorRate: workflowMetrics.quality.errorCount > 0 ? \n    (workflowMetrics.quality.errorCount / workflowMetrics.execution.itemsProcessed * 100) : 0,\n  alertCount: performanceAlerts.length\n};\n\n// 记录性能日志\nconsole.log('📊 性能监控报告:', JSON.stringify({\n  timestamp: new Date().toISOString(),\n  executionId: $execution.id,\n  summary: performanceSummary,\n  alerts: performanceAlerts.length > 0 ? performanceAlerts : undefined\n}));\n\n// 返回增强的数据\nreturn {\n  json: {\n    ...inputData,\n    performanceMetrics: allMetrics,\n    performanceAlerts: performanceAlerts,\n    performanceSummary: performanceSummary,\n    monitoringTimestamp: new Date().toISOString()\n  }\n};"
      },
      
      "settings": {
        "continueOnFail": true,\n        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "errorHandler": {
      "nodeId": "error-handler",
      "name": "错误处理和告警",
      "type": "n8n-nodes-base.function",
      "description": "统一的错误处理、分类和告警机制",
      
      "parameters": {
        "functionCode": "// 统一错误处理和告警系统\nconst inputData = $input.first()?.json || {};\nconst error = inputData.error || $execution.lastNodeExecuted?.error;\nconst enableAlerts = process.env.ENABLE_ERROR_ALERTS !== 'false';\nconst webhookUrl = process.env.WEBHOOK_ALERT_URL;\n\n// 错误分类\nfunction classifyError(error) {\n  if (!error) return { category: 'unknown', severity: 'low' };\n  \n  const errorMessage = error.message || error.toString() || '';\n  const errorStack = error.stack || '';\n  \n  // 网络错误\n  if (errorMessage.includes('timeout') || errorMessage.includes('ECONNRESET') || \n      errorMessage.includes('ENOTFOUND') || errorMessage.includes('network')) {\n    return {\n      category: 'network',\n      severity: 'medium',\n      retryable: true,\n      description: '网络连接错误'\n    };\n  }\n  \n  // 认证错误\n  if (errorMessage.includes('401') || errorMessage.includes('403') || \n      errorMessage.includes('unauthorized') || errorMessage.includes('authentication')) {\n    return {\n      category: 'authentication',\n      severity: 'high',\n      retryable: false,\n      description: 'API认证失败'\n    };\n  }\n  \n  // 限流错误\n  if (errorMessage.includes('429') || errorMessage.includes('rate limit') || \n      errorMessage.includes('too many requests')) {\n    return {\n      category: 'rate_limit',\n      severity: 'medium',\n      retryable: true,\n      description: 'API请求频率限制'\n    };\n  }\n  \n  // 数据验证错误\n  if (errorMessage.includes('validation') || errorMessage.includes('invalid') || \n      errorMessage.includes('required field')) {\n    return {\n      category: 'validation',\n      severity: 'medium',\n      retryable: false,\n      description: '数据验证失败'\n    };\n  }\n  \n  // 服务器错误\n  if (errorMessage.includes('500') || errorMessage.includes('502') || \n      errorMessage.includes('503') || errorMessage.includes('504')) {\n    return {\n      category: 'server_error',\n      severity: 'high',\n      retryable: true,\n      description: '服务器内部错误'\n    };\n  }\n  \n  // 内容处理错误\n  if (errorMessage.includes('content') || errorMessage.includes('processing') || \n      errorMessage.includes('parsing')) {\n    return {\n      category: 'content_processing',\n      severity: 'low',\n      retryable: false,\n      description: '内容处理错误'\n    };\n  }\n  \n  // 默认分类\n  return {\n    category: 'unknown',\n    severity: 'medium',\n    retryable: false,\n    description: '未知错误类型'\n  };\n}\n\n// 生成错误报告\nfunction generateErrorReport(error, classification) {\n  return {\n    errorId: `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    timestamp: new Date().toISOString(),\n    executionId: $execution.id,\n    workflowId: $workflow.id,\n    workflowName: $workflow.name,\n    nodeId: $node.id || 'unknown',\n    nodeName: $node.name || 'unknown',\n    \n    error: {\n      message: error?.message || 'Unknown error',\n      stack: error?.stack || '',\n      code: error?.code || '',\n      type: error?.constructor?.name || 'Error'\n    },\n    \n    classification: classification,\n    \n    context: {\n      inputDataSize: JSON.stringify(inputData).length,\n      hasInputData: Object.keys(inputData).length > 0,\n      executionContext: {\n        mode: $execution.mode,\n        startedAt: $execution.startedAt,\n        resumeUrl: $execution.resumeUrl\n      }\n    },\n    \n    systemInfo: {\n      memoryUsage: process.memoryUsage ? process.memoryUsage() : {},\n      uptime: process.uptime ? process.uptime() : 0,\n      platform: process.platform || 'unknown'\n    },\n    \n    troubleshooting: generateTroubleshootingTips(classification)\n  };\n}\n\n// 生成故障排除建议\nfunction generateTroubleshootingTips(classification) {\n  const tips = {\n    network: [\n      '检查网络连接是否正常',\n      '验证目标服务是否可访问',\n      '考虑增加超时时间',\n      '检查防火墙设置'\n    ],\n    authentication: [\n      '验证API密钥是否正确',\n      '检查API密钥是否过期',\n      '确认API权限设置',\n      '检查认证头格式'\n    ],\n    rate_limit: [\n      '减少API调用频率',\n      '实施指数退避重试',\n      '考虑升级API套餐',\n      '分批处理数据'\n    ],\n    validation: [\n      '检查输入数据格式',\n      '验证必填字段',\n      '确认数据类型正确',\n      '检查字段长度限制'\n    ],\n    server_error: [\n      '稍后重试操作',\n      '检查服务状态页面',\n      '联系服务提供商',\n      '实施重试机制'\n    ],\n    content_processing: [\n      '检查内容格式',\n      '验证内容完整性',\n      '调整处理参数',\n      '跳过问题内容'\n    ]\n  };\n  \n  return tips[classification.category] || [\n    '检查错误日志详情',\n    '验证输入数据',\n    '联系技术支持',\n    '查看相关文档'\n  ];\n}\n\n// 发送告警通知\nasync function sendAlert(errorReport) {\n  if (!enableAlerts || !webhookUrl) {\n    console.log('⚠️ 告警功能未启用或未配置Webhook URL');\n    return false;\n  }\n  \n  try {\n    const alertPayload = {\n      type: 'error_alert',\n      severity: errorReport.classification.severity,\n      title: `工作流错误: ${errorReport.error.message}`,\n      description: errorReport.classification.description,\n      details: {\n        workflowName: errorReport.workflowName,\n        nodeName: errorReport.nodeName,\n        errorCategory: errorReport.classification.category,\n        timestamp: errorReport.timestamp,\n        executionId: errorReport.executionId\n      },\n      troubleshooting: errorReport.troubleshooting,\n      metadata: {\n        retryable: errorReport.classification.retryable,\n        errorId: errorReport.errorId\n      }\n    };\n    \n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(alertPayload),\n      timeout: 10000\n    });\n    \n    if (response.ok) {\n      console.log('✅ 错误告警发送成功');\n      return true;\n    } else {\n      console.error('❌ 错误告警发送失败:', response.status, response.statusText);\n      return false;\n    }\n  } catch (alertError) {\n    console.error('❌ 发送告警时出错:', alertError.message);\n    return false;\n  }\n}\n\n// 处理错误\nif (error || inputData.status === 'error') {\n  const classification = classifyError(error);\n  const errorReport = generateErrorReport(error, classification);\n  \n  // 记录错误日志\n  console.error('🚨 工作流错误报告:', JSON.stringify({\n    errorId: errorReport.errorId,\n    category: classification.category,\n    severity: classification.severity,\n    message: errorReport.error.message,\n    retryable: classification.retryable,\n    troubleshooting: errorReport.troubleshooting.slice(0, 2)\n  }));\n  \n  // 发送告警（异步）\n  if (classification.severity === 'high' || classification.severity === 'critical') {\n    sendAlert(errorReport).catch(err => {\n      console.error('告警发送失败:', err.message);\n    });\n  }\n  \n  return {\n    json: {\n      status: 'error_handled',\n      errorReport: errorReport,\n      originalData: inputData,\n      shouldRetry: classification.retryable,\n      skipToEnd: !classification.retryable,\n      timestamp: new Date().toISOString()\n    }\n  };\n} else {\n  // 没有错误，直接传递数据\n  return {\n    json: {\n      ...inputData,\n      errorHandlingChecked: true,\n      timestamp: new Date().toISOString()\n    }\n  };\n}"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    },
    
    "executionReporter": {
      "nodeId": "execution-reporter",
      "name": "执行报告生成器",
      "type": "n8n-nodes-base.function",
      "description": "生成详细的工作流执行报告和统计信息",
      
      "parameters": {
        "functionCode": "// 工作流执行报告生成器\nconst fs = require('fs').promises;\nconst path = require('path');\n\nconst inputData = $input.first()?.json || {};\nconst workflowStatus = inputData.workflowStatus || {};\nconst performanceMetrics = inputData.performanceMetrics || {};\nconst enableReportGeneration = process.env.ENABLE_EXECUTION_REPORTS !== 'false';\nconst reportStoragePath = process.env.REPORT_STORAGE_PATH || './logs/execution-reports';\n\n// 生成执行摘要\nfunction generateExecutionSummary() {\n  const startTime = workflowStatus.startTime || Date.now();\n  const endTime = Date.now();\n  const duration = endTime - startTime;\n  \n  return {\n    executionId: $execution.id,\n    workflowId: $workflow.id,\n    workflowName: $workflow.name,\n    startTime: new Date(startTime).toISOString(),\n    endTime: new Date(endTime).toISOString(),\n    duration: duration,\n    durationFormatted: formatDuration(duration),\n    status: inputData.status || 'completed',\n    \n    itemsProcessed: {\n      total: inputData.totalItems || 0,\n      successful: inputData.successfulItems || 0,\n      failed: inputData.failedItems || 0,\n      skipped: inputData.skippedItems || 0\n    },\n    \n    phases: {\n      dataCollection: workflowStatus.rssCollection || {},\n      contentProcessing: workflowStatus.contentProcessing || {},\n      notionStorage: workflowStatus.notionStorage || {},\n      aiManagement: workflowStatus.aiManagement || {},\n      firebirdPublish: workflowStatus.firebirdPublish || {}\n    }\n  };\n}\n\n// 生成性能分析报告\nfunction generatePerformanceAnalysis() {\n  const execution = performanceMetrics.workflow?.execution || {};\n  const system = performanceMetrics.system || {};\n  const api = performanceMetrics.api || {};\n  \n  return {\n    executionPerformance: {\n      totalExecutionTime: execution.totalTime || 0,\n      averageItemProcessingTime: execution.itemsProcessed > 0 ? \n        (execution.totalTime / execution.itemsProcessed) : 0,\n      throughput: execution.throughput || 0,\n      dataProcessingRate: execution.dataSize > 0 ? \n        (execution.dataSize / Math.max(1, execution.totalTime / 1000)) : 0\n    },\n    \n    systemPerformance: {\n      memoryUsage: {\n        peak: system.memory?.heapUsed || 0,\n        average: system.memory?.heapUsed || 0,\n        efficiency: system.memory?.heapTotal > 0 ? \n          (system.memory.heapUsed / system.memory.heapTotal * 100) : 0\n      },\n      processUptime: system.process?.uptime || 0\n    },\n    \n    apiPerformance: {\n      totalApiCalls: api.totalCalls || 0,\n      averageResponseTime: api.averageResponseTime || 0,\n      apiSuccessRate: api.successRate || 100,\n      slowestApiCall: api.slowestCall || 0,\n      fastestApiCall: api.fastestCall || 0\n    },\n    \n    bottlenecks: identifyBottlenecks(execution, system, api),\n    recommendations: generatePerformanceRecommendations(execution, system, api)\n  };\n}\n\n// 识别性能瓶颈\nfunction identifyBottlenecks(execution, system, api) {\n  const bottlenecks = [];\n  \n  // 执行时间瓶颈\n  if (execution.totalTime > 300000) { // 5分钟\n    bottlenecks.push({\n      type: 'execution_time',\n      severity: 'high',\n      description: '工作流执行时间过长',\n      value: execution.totalTime,\n      threshold: 300000\n    });\n  }\n  \n  // 内存使用瓶颈\n  if (system.memory?.heapUsagePercent > 80) {\n    bottlenecks.push({\n      type: 'memory_usage',\n      severity: 'medium',\n      description: '内存使用率过高',\n      value: system.memory.heapUsagePercent,\n      threshold: 80\n    });\n  }\n  \n  // API响应时间瓶颈\n  if (api.averageResponseTime > 5000) {\n    bottlenecks.push({\n      type: 'api_response_time',\n      severity: 'medium',\n      description: 'API响应时间过长',\n      value: api.averageResponseTime,\n      threshold: 5000\n    });\n  }\n  \n  // 吞吐量瓶颈\n  if (execution.throughput < 1) {\n    bottlenecks.push({\n      type: 'throughput',\n      severity: 'low',\n      description: '数据处理吞吐量较低',\n      value: execution.throughput,\n      threshold: 1\n    });\n  }\n  \n  return bottlenecks;\n}\n\n// 生成性能优化建议\nfunction generatePerformanceRecommendations(execution, system, api) {\n  const recommendations = [];\n  \n  // 执行时间优化\n  if (execution.totalTime > 180000) {\n    recommendations.push({\n      category: 'execution_optimization',\n      priority: 'high',\n      suggestion: '考虑并行处理数据或优化处理逻辑',\n      expectedImprovement: '减少30-50%执行时间'\n    });\n  }\n  \n  // 内存优化\n  if (system.memory?.heapUsagePercent > 70) {\n    recommendations.push({\n      category: 'memory_optimization',\n      priority: 'medium',\n      suggestion: '实施数据流处理，避免大量数据同时加载到内存',\n      expectedImprovement: '减少40-60%内存使用'\n    });\n  }\n  \n  // API优化\n  if (api.averageResponseTime > 3000) {\n    recommendations.push({\n      category: 'api_optimization',\n      priority: 'medium',\n      suggestion: '实施API请求缓存或增加并发请求数',\n      expectedImprovement: '提升20-40%API响应速度'\n    });\n  }\n  \n  // 数据处理优化\n  if (execution.throughput < 2) {\n    recommendations.push({\n      category: 'throughput_optimization',\n      priority: 'low',\n      suggestion: '优化数据处理算法或增加批处理大小',\n      expectedImprovement: '提升50-100%处理吞吐量'\n    });\n  }\n  \n  return recommendations;\n}\n\n// 生成内容分析报告\nfunction generateContentAnalysis() {\n  const sourceStats = inputData.sourceStats || [];\n  const qualityStats = inputData.qualityStats || {};\n  \n  return {\n    sourceAnalysis: {\n      totalSources: sourceStats.length,\n      successfulSources: sourceStats.filter(s => s.status === 'success').length,\n      failedSources: sourceStats.filter(s => s.status === 'failed').length,\n      sourceBreakdown: sourceStats.map(source => ({\n        name: source.source,\n        status: source.status,\n        itemCount: source.itemCount,\n        processingTime: source.processingTime,\n        successRate: source.itemCount > 0 ? 100 : 0\n      }))\n    },\n    \n    qualityAnalysis: {\n      averageQualityScore: qualityStats.averageQualityScore || 0,\n      qualityDistribution: calculateQualityDistribution(inputData.items || []),\n      contentCompleteness: {\n        itemsWithImages: qualityStats.itemsWithImages || 0,\n        itemsWithAuthors: qualityStats.itemsWithAuthors || 0,\n        averageContentLength: qualityStats.averageContentLength || 0\n      }\n    },\n    \n    processingResults: {\n      duplicatesDetected: inputData.duplicatesRemoved || 0,\n      itemsRejected: inputData.rejectedItems || 0,\n      aiEnhancedItems: inputData.aiEnhancedItems || 0,\n      publishedItems: inputData.publishedItems || 0\n    }\n  };\n}\n\n// 计算质量分数分布\nfunction calculateQualityDistribution(items) {\n  const distribution = {\n    excellent: 0, // 90-100\n    good: 0,      // 70-89\n    fair: 0,      // 50-69\n    poor: 0       // 0-49\n  };\n  \n  items.forEach(item => {\n    const score = item.quality_score || item.validationScore || 0;\n    if (score >= 90) distribution.excellent++;\n    else if (score >= 70) distribution.good++;\n    else if (score >= 50) distribution.fair++;\n    else distribution.poor++;\n  });\n  \n  return distribution;\n}\n\n// 生成错误分析报告\nfunction generateErrorAnalysis() {\n  const errors = inputData.errors || [];\n  const performanceAlerts = inputData.performanceAlerts || [];\n  \n  const errorsByCategory = {};\n  const errorsByNode = {};\n  \n  errors.forEach(error => {\n    const category = error.type || 'unknown';\n    const node = error.source || 'unknown';\n    \n    errorsByCategory[category] = (errorsByCategory[category] || 0) + 1;\n    errorsByNode[node] = (errorsByNode[node] || 0) + 1;\n  });\n  \n  return {\n    errorSummary: {\n      totalErrors: errors.length,\n      errorRate: inputData.totalItems > 0 ? (errors.length / inputData.totalItems * 100) : 0,\n      criticalErrors: errors.filter(e => e.severity === 'critical').length,\n      recoverableErrors: errors.filter(e => e.retryable).length\n    },\n    \n    errorBreakdown: {\n      byCategory: errorsByCategory,\n      byNode: errorsByNode,\n      topErrors: errors.slice(0, 5).map(error => ({\n        message: error.error || error.message,\n        category: error.type,\n        timestamp: error.timestamp,\n        node: error.source\n      }))\n    },\n    \n    performanceIssues: {\n      totalAlerts: performanceAlerts.length,\n      criticalAlerts: performanceAlerts.filter(a => a.type === 'critical').length,\n      warningAlerts: performanceAlerts.filter(a => a.type === 'warning').length,\n      alertBreakdown: performanceAlerts.reduce((acc, alert) => {\n        acc[alert.metric] = (acc[alert.metric] || 0) + 1;\n        return acc;\n      }, {})\n    }\n  };\n}\n\n// 格式化持续时间\nfunction formatDuration(milliseconds) {\n  const seconds = Math.floor(milliseconds / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  \n  if (hours > 0) {\n    return `${hours}小时${minutes % 60}分钟${seconds % 60}秒`;\n  } else if (minutes > 0) {\n    return `${minutes}分钟${seconds % 60}秒`;\n  } else {\n    return `${seconds}秒`;\n  }\n}\n\n// 生成完整报告\nfunction generateCompleteReport() {\n  return {\n    reportMetadata: {\n      reportId: `report_${$execution.id}_${Date.now()}`,\n      generatedAt: new Date().toISOString(),\n      reportVersion: '1.0.0',\n      executionId: $execution.id,\n      workflowName: $workflow.name\n    },\n    \n    executionSummary: generateExecutionSummary(),\n    performanceAnalysis: generatePerformanceAnalysis(),\n    contentAnalysis: generateContentAnalysis(),\n    errorAnalysis: generateErrorAnalysis(),\n    \n    recommendations: {\n      immediate: [\n        '检查并优化性能瓶颈',\n        '处理关键错误和告警',\n        '验证内容质量指标'\n      ],\n      shortTerm: [\n        '实施性能优化建议',\n        '改进错误处理机制',\n        '优化内容处理流程'\n      ],\n      longTerm: [\n        '考虑架构优化',\n        '实施预测性监控',\n        '建立性能基准'\n      ]\n    }\n  };\n}\n\n// 保存报告到文件\nasync function saveReportToFile(report) {\n  if (!enableReportGeneration) {\n    return null;\n  }\n  \n  try {\n    // 确保报告目录存在\n    await fs.mkdir(reportStoragePath, { recursive: true });\n    \n    const fileName = `execution-report-${$execution.id}-${Date.now()}.json`;\n    const filePath = path.join(reportStoragePath, fileName);\n    \n    await fs.writeFile(filePath, JSON.stringify(report, null, 2), 'utf8');\n    \n    console.log(`📄 执行报告已保存: ${filePath}`);\n    return filePath;\n  } catch (error) {\n    console.error('❌ 保存执行报告失败:', error.message);\n    return null;\n  }\n}\n\n// 生成并保存报告\nconst completeReport = generateCompleteReport();\nconst reportFilePath = await saveReportToFile(completeReport);\n\n// 生成报告摘要用于日志\nconst reportSummary = {\n  executionId: completeReport.reportMetadata.executionId,\n  duration: completeReport.executionSummary.durationFormatted,\n  status: completeReport.executionSummary.status,\n  itemsProcessed: completeReport.executionSummary.itemsProcessed.total,\n  successRate: completeReport.executionSummary.itemsProcessed.total > 0 ? \n    (completeReport.executionSummary.itemsProcessed.successful / completeReport.executionSummary.itemsProcessed.total * 100) : 100,\n  errorCount: completeReport.errorAnalysis.errorSummary.totalErrors,\n  performanceStatus: completeReport.performanceAnalysis.bottlenecks.length > 0 ? 'issues_detected' : 'healthy',\n  reportPath: reportFilePath\n};\n\nconsole.log('📊 工作流执行报告摘要:', JSON.stringify(reportSummary));\n\n// 返回报告数据\nreturn {\n  json: {\n    ...inputData,\n    executionReport: completeReport,\n    reportSummary: reportSummary,\n    reportGenerated: true,\n    reportPath: reportFilePath,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      
      "settings": {
        "continueOnFail": true,
        "retryOnFail": false,
        "executeOnce": false
      }
    }
  },
  
  "nodeConnections": {
    "description": "日志记录节点之间的连接配置",
    
    "standardFlow": {
      "description": "标准的日志记录流程",
      "connections": [
        {
          "from": "any-node",
          "to": "workflow-logger",
          "condition": "always",
          "description": "所有节点都连接到工作流日志记录器"
        },
        {
          "from": "workflow-logger",
          "to": "performance-monitor",
          "condition": "always",
          "description": "日志记录后进行性能监控"
        },
        {
          "from": "performance-monitor",
          "to": "error-handler",
          "condition": "has_errors_or_alerts",
          "description": "有错误或告警时进入错误处理"
        },
        {
          "from": "error-handler",
          "to": "next-node",
          "condition": "error_handled",
          "description": "错误处理完成后继续流程"
        }
      ]
    },
    
    "completionFlow": {
      "description": "工作流完成时的报告生成流程",
      "connections": [
        {
          "from": "final-node",
          "to": "execution-reporter",
          "condition": "workflow_completed",
          "description": "工作流完成时生成执行报告"
        }
      ]
    }
  },
  
  "integrationGuide": {
    "description": "如何将日志记录节点集成到现有工作流",
    
    "steps": [
      {
        "step": 1,
        "title": "导入节点配置",
        "description": "将日志记录节点配置导入到n8n工作流中",
        "action": "import_node_configurations"
      },
      {
        "step": 2,
        "title": "配置环境变量",
        "description": "设置必要的环境变量",
        "requiredVariables": [
          "WORKFLOW_LOG_LEVEL",
          "ENABLE_STRUCTURED_LOGGING",
          "ENABLE_ERROR_ALERTS",
          "WEBHOOK_ALERT_URL",
          "ENABLE_EXECUTION_REPORTS",
          "REPORT_STORAGE_PATH"
        ]
      },
      {
        "step": 3,
        "title": "连接日志节点",
        "description": "将日志记录节点连接到现有工作流节点",
        "action": "connect_logging_nodes"
      },
      {
        "step": 4,
        "title": "测试日志功能",
        "description": "执行测试工作流验证日志记录功能",
        "action": "test_logging_functionality"
      }
    ]
  }
}