#!/usr/bin/env node

/**
 * Â¢ûÂº∫ÁâàÊñ∞ÈóªÈááÈõÜÂ∑•‰ΩúÊµÅÊµãËØïËÑöÊú¨
 * ÂÖ®Èù¢ÊµãËØïÂ§öÊ∫êÊñ∞ÈóªÈááÈõÜ„ÄÅÊï∞ÊçÆÈ™åËØÅ„ÄÅÈîôËØØÂ§ÑÁêÜÁ≠âÂäüËÉΩ
 * 
 * @author AI Assistant
 * @version 1.0.0
 * @date 2025-01-22
 */

const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');
const { EnhancedDataValidator } = require('./enhanced-data-validator');
const { EnhancedErrorHandler } = require('./enhanced-error-handler');

class WorkflowTester {
    constructor(config = {}) {
        this.config = {
            workspaceRoot: config.workspaceRoot || process.cwd(),
            enableDetailedLogging: config.enableDetailedLogging !== false,
            testTimeout: config.testTimeout || 60000,
            maxTestItems: config.maxTestItems || 10,
            ...config
        };

        this.testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            skipped: 0,
            tests: []
        };

        this.validator = new EnhancedDataValidator({
            enableLogging: this.config.enableDetailedLogging
        });

        this.errorHandler = new EnhancedErrorHandler({
            enableLogging: this.config.enableDetailedLogging
        });
    }

    /**
     * ËøêË°åÊâÄÊúâÊµãËØï
     */
    async runAllTests() {
        console.log('üß™ ÂºÄÂßãËøêË°åÂ¢ûÂº∫ÁâàÂ∑•‰ΩúÊµÅÊµãËØïÂ•ó‰ª∂...\n');

        try {
            // 1. ÁéØÂ¢ÉÊµãËØï
            await this.testEnvironment();

            // 2. ÈÖçÁΩÆÊñá‰ª∂ÊµãËØï
            await this.testConfigurations();

            // 3. RSSÈááÈõÜÊµãËØï
            await this.testRSSCollection();

            // 4. GitHubÈááÈõÜÊµãËØï
            await this.testGitHubCollection();

            // 5. Êï∞ÊçÆÈ™åËØÅÊµãËØï
            await this.testDataValidation();

            // 6. ÈîôËØØÂ§ÑÁêÜÊµãËØï
            await this.testErrorHandling();

            // 7. ÂÜÖÂÆπÂ§ÑÁêÜÊµãËØï
            await this.testContentProcessing();

            // 8. Á´ØÂà∞Á´ØÈõÜÊàêÊµãËØï
            await this.testEndToEndIntegration();

            // 9. ÂÆåÊï¥ÊµãËØïÁî®‰æãÂíåÊµãËØïÊï∞ÊçÆÂàõÂª∫
            await this.createComprehensiveTestData();

            // 10. ÈîôËØØÂú∫ÊôØÂíåÊÅ¢Â§çÊú∫Âà∂ÊµãËØï
            await this.testErrorScenariosAndRecovery();

            // 11. Êï∞ÊçÆÂÆåÊï¥ÊÄßÈ™åËØÅÊµãËØï
            await this.testDataIntegrityValidation();

            // 12. Á≥ªÁªüÊÄßËÉΩÂü∫ÂáÜÊµãËØï
            await this.testSystemPerformanceBenchmarks();

            // ÁîüÊàêÊµãËØïÊä•Âëä
            await this.generateTestReport();

            this.printTestSummary();

        } catch (error) {
            console.error('‚ùå ÊµãËØïÂ•ó‰ª∂ÊâßË°åÂ§±Ë¥•:', error.message);
            process.exit(1);
        }
    }

    /**
     * ÁéØÂ¢ÉÊµãËØï
     */
    async testEnvironment() {
        console.log('üîç ÊµãËØïÁéØÂ¢ÉÈÖçÁΩÆ...');

        await this.runTest('ÁéØÂ¢ÉÂèòÈáèÊ£ÄÊü•', async () => {
            const requiredVars = [
                'OPENAI_API_KEY',
                'NOTION_API_TOKEN',
                'NOTION_DATABASE_ID',
                'HUONIAO_SESSION_ID'
            ];

            const missing = requiredVars.filter(varName => !process.env[varName]);

            if (missing.length > 0) {
                throw new Error(`Áº∫Â∞ëÁéØÂ¢ÉÂèòÈáè: ${missing.join(', ')}`);
            }

            return { status: 'passed', message: 'ÊâÄÊúâÂøÖÈúÄÁéØÂ¢ÉÂèòÈáèÂ∑≤ÈÖçÁΩÆ' };
        });

        await this.runTest('Êñá‰ª∂Á≥ªÁªüÊùÉÈôêÊ£ÄÊü•', async () => {
            const paths = [
                'n8n-config/workflows',
                'n8n-config/credentials',
                'scripts',
                'logs'
            ];

            for (const dirPath of paths) {
                const fullPath = path.join(this.config.workspaceRoot, dirPath);
                try {
                    await fs.access(fullPath, fs.constants.R_OK | fs.constants.W_OK);
                } catch (error) {
                    throw new Error(`ÁõÆÂΩïËÆøÈóÆÂ§±Ë¥•: ${dirPath}`);
                }
            }

            return { status: 'passed', message: 'Êñá‰ª∂Á≥ªÁªüÊùÉÈôêÊ≠£Â∏∏' };
        });

        console.log('‚úÖ ÁéØÂ¢ÉÊµãËØïÂÆåÊàê\n');
    }

    /**
     * ÈÖçÁΩÆÊñá‰ª∂ÊµãËØï
     */
    async testConfigurations() {
        console.log('üîß ÊµãËØïÈÖçÁΩÆÊñá‰ª∂...');

        await this.runTest('Êï∞ÊçÆÊ∫êÈÖçÁΩÆÈ™åËØÅ', async () => {
            const configPath = path.join(this.config.workspaceRoot, 'n8n-config/enhanced-sources-config.json');
            const configContent = await fs.readFile(configPath, 'utf8');
            const config = JSON.parse(configContent);

            if (!config.rssSources || !Array.isArray(config.rssSources)) {
                throw new Error('RSSÊ∫êÈÖçÁΩÆÊó†Êïà');
            }

            if (!config.githubSources || !Array.isArray(config.githubSources)) {
                throw new Error('GitHubÊ∫êÈÖçÁΩÆÊó†Êïà');
            }

            const enabledRSS = config.rssSources.filter(s => s.enabled).length;
            const enabledGitHub = config.githubSources.filter(s => s.enabled).length;

            return {
                status: 'passed',
                message: `ÈÖçÁΩÆÊúâÊïà: ${enabledRSS}‰∏™RSSÊ∫ê, ${enabledGitHub}‰∏™GitHubÊ∫ê`
            };
        });

        await this.runTest('Â∑•‰ΩúÊµÅÈÖçÁΩÆÈ™åËØÅ', async () => {
            const workflowPath = path.join(this.config.workspaceRoot, 'n8n-config/workflows/enhanced-news-collection-workflow.json');
            const workflowContent = await fs.readFile(workflowPath, 'utf8');
            const workflow = JSON.parse(workflowContent);

            if (!workflow.nodes || !Array.isArray(workflow.nodes)) {
                throw new Error('Â∑•‰ΩúÊµÅËäÇÁÇπÈÖçÁΩÆÊó†Êïà');
            }

            if (!workflow.connections || typeof workflow.connections !== 'object') {
                throw new Error('Â∑•‰ΩúÊµÅËøûÊé•ÈÖçÁΩÆÊó†Êïà');
            }

            return {
                status: 'passed',
                message: `Â∑•‰ΩúÊµÅÊúâÊïà: ${workflow.nodes.length}‰∏™ËäÇÁÇπ`
            };
        });

        console.log('‚úÖ ÈÖçÁΩÆÊñá‰ª∂ÊµãËØïÂÆåÊàê\n');
    }

    /**
     * RSSÈááÈõÜÊµãËØï
     */
    async testRSSCollection() {
        console.log('üì° ÊµãËØïRSSÈááÈõÜÂäüËÉΩ...');

        await this.runTest('RSSÊ∫êËøûÊé•ÊµãËØï', async () => {
            const configPath = path.join(this.config.workspaceRoot, 'n8n-config/enhanced-sources-config.json');
            const configContent = await fs.readFile(configPath, 'utf8');
            const config = JSON.parse(configContent);

            const testSources = config.rssSources.filter(s => s.enabled).slice(0, 3);
            const results = [];

            for (const source of testSources) {
                try {
                    const response = await axios.get(source.url, {
                        timeout: 10000,
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (compatible; n8n-news-collector/1.0)'
                        }
                    });

                    if (response.status === 200 && response.data.includes('<rss') || response.data.includes('<feed')) {
                        results.push({ source: source.name, status: 'success' });
                    } else {
                        results.push({ source: source.name, status: 'invalid_format' });
                    }
                } catch (error) {
                    results.push({ source: source.name, status: 'error', error: error.message });
                }
            }

            const successCount = results.filter(r => r.status === 'success').length;

            if (successCount === 0) {
                throw new Error('ÊâÄÊúâRSSÊ∫êËøûÊé•Â§±Ë¥•');
            }

            return {
                status: 'passed',
                message: `RSSËøûÊé•ÊµãËØï: ${successCount}/${results.length}‰∏™Ê∫êÂèØÁî®`,
                details: results
            };
        });

        await this.runTest('RSSÊï∞ÊçÆËß£ÊûêÊµãËØï', async () => {
            // ‰ΩøÁî®ÊµãËØïRSSÊï∞ÊçÆ
            const testRSSData = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
    <channel>
        <title>Test RSS Feed</title>
        <description>Test feed for validation</description>
        <item>
            <title>Test Article 1</title>
            <description>This is a test article for RSS parsing validation.</description>
            <link>https://example.com/article1</link>
            <pubDate>Wed, 22 Jan 2025 10:00:00 GMT</pubDate>
            <author>Test Author</author>
        </item>
        <item>
            <title>Test Article 2</title>
            <description>Another test article with different content structure.</description>
            <link>https://example.com/article2</link>
            <pubDate>Wed, 22 Jan 2025 11:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>`;

            const xml2js = require('xml2js');
            const parser = new xml2js.Parser({ explicitArray: false, ignoreAttrs: false, mergeAttrs: true });

            const result = await parser.parseStringPromise(testRSSData);
            const items = result.rss.channel.item;

            if (!Array.isArray(items) || items.length === 0) {
                throw new Error('RSSËß£ÊûêÂ§±Ë¥•');
            }

            return {
                status: 'passed',
                message: `RSSËß£ÊûêÊàêÂäü: Ëß£ÊûêÂá∫${items.length}‰∏™Êù°ÁõÆ`
            };
        });

        console.log('‚úÖ RSSÈááÈõÜÊµãËØïÂÆåÊàê\n');
    }

    /**
     * GitHubÈááÈõÜÊµãËØï
     */
    async testGitHubCollection() {
        console.log('üêô ÊµãËØïGitHubÈááÈõÜÂäüËÉΩ...');

        await this.runTest('GitHub APIËøûÊé•ÊµãËØï', async () => {
            const headers = {
                'User-Agent': 'n8n-news-collector/1.0',
                'Accept': 'application/vnd.github.v3+json'
            };

            if (process.env.GITHUB_TOKEN) {
                headers['Authorization'] = `token ${process.env.GITHUB_TOKEN}`;
            }

            const response = await axios.get('https://api.github.com/repos/microsoft/vscode', {
                headers,
                timeout: 10000
            });

            if (response.status !== 200) {
                throw new Error(`GitHub APIÂìçÂ∫îÂºÇÂ∏∏: ${response.status}`);
            }

            return {
                status: 'passed',
                message: 'GitHub APIËøûÊé•Ê≠£Â∏∏',
                rateLimit: {
                    remaining: response.headers['x-ratelimit-remaining'],
                    reset: new Date(parseInt(response.headers['x-ratelimit-reset']) * 1000).toISOString()
                }
            };
        });

        await this.runTest('GitHubË∂ãÂäøÈ°πÁõÆËé∑ÂèñÊµãËØï', async () => {
            const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const searchUrl = `https://api.github.com/search/repositories?q=created:>${oneWeekAgo}&sort=stars&order=desc&per_page=5`;

            const headers = {
                'User-Agent': 'n8n-news-collector/1.0',
                'Accept': 'application/vnd.github.v3+json'
            };

            if (process.env.GITHUB_TOKEN) {
                headers['Authorization'] = `token ${process.env.GITHUB_TOKEN}`;
            }

            const response = await axios.get(searchUrl, {
                headers,
                timeout: 10000
            });

            if (!response.data.items || response.data.items.length === 0) {
                throw new Error('Êú™Ëé∑ÂèñÂà∞Ë∂ãÂäøÈ°πÁõÆ');
            }

            return {
                status: 'passed',
                message: `Ëé∑ÂèñÂà∞${response.data.items.length}‰∏™Ë∂ãÂäøÈ°πÁõÆ`
            };
        });

        console.log('‚úÖ GitHubÈááÈõÜÊµãËØïÂÆåÊàê\n');
    }

    /**
     * Êï∞ÊçÆÈ™åËØÅÊµãËØï
     */
    async testDataValidation() {
        console.log('üîç ÊµãËØïÊï∞ÊçÆÈ™åËØÅÂäüËÉΩ...');

        await this.runTest('Âü∫Á°ÄÊï∞ÊçÆÈ™åËØÅÊµãËØï', async () => {
            const testData = [
                {
                    title: 'Valid Test Article',
                    content: 'This is a valid test article with sufficient content length to pass validation checks.',
                    source: 'Test Source',
                    author: 'Test Author',
                    source_url: 'https://example.com/article',
                    publishedAt: new Date().toISOString()
                },
                {
                    title: '', // Êó†ÊïàÔºöÁ©∫Ê†áÈ¢ò
                    content: 'Content without title',
                    source: 'Test Source'
                },
                {
                    title: 'Article with short content',
                    content: 'Too short', // Êó†ÊïàÔºöÂÜÖÂÆπËøáÁü≠
                    source: 'Test Source'
                }
            ];

            const results = await this.validator.batchValidateAndStandardize(testData);

            if (results.valid.length !== 1) {
                throw new Error(`È™åËØÅÁªìÊûúÂºÇÂ∏∏: ÊúüÊúõ1‰∏™ÊúâÊïàÈ°πÔºåÂÆûÈôÖ${results.valid.length}‰∏™`);
            }

            return {
                status: 'passed',
                message: `Êï∞ÊçÆÈ™åËØÅÊ≠£Â∏∏: ${results.valid.length}‰∏™ÊúâÊïàÔºå${results.invalid.length}‰∏™Êó†Êïà`
            };
        });

        await this.runTest('ÈáçÂ§çÂÜÖÂÆπÊ£ÄÊµãÊµãËØï', async () => {
            const duplicateData = [
                {
                    title: 'Unique Article 1',
                    content: 'This is the first unique article with original content.',
                    source: 'Test Source'
                },
                {
                    title: 'Unique Article 1', // ÈáçÂ§çÊ†áÈ¢ò
                    content: 'This is a duplicate article with same title.',
                    source: 'Test Source'
                },
                {
                    title: 'Unique Article 2',
                    content: 'This is another unique article with different content.',
                    source: 'Test Source'
                }
            ];

            const results = await this.validator.batchValidateAndStandardize(duplicateData);

            if (results.duplicates.length === 0) {
                throw new Error('ÈáçÂ§çÊ£ÄÊµãÊú™ÁîüÊïà');
            }

            return {
                status: 'passed',
                message: `ÈáçÂ§çÊ£ÄÊµãÊ≠£Â∏∏: Ê£ÄÊµãÂà∞${results.duplicates.length}‰∏™ÈáçÂ§çÈ°π`
            };
        });

        console.log('‚úÖ Êï∞ÊçÆÈ™åËØÅÊµãËØïÂÆåÊàê\n');
    }

    /**
     * ÈîôËØØÂ§ÑÁêÜÊµãËØï
     */
    async testErrorHandling() {
        console.log('‚ö†Ô∏è ÊµãËØïÈîôËØØÂ§ÑÁêÜÂäüËÉΩ...');

        await this.runTest('ÁΩëÁªúÈîôËØØÈáçËØïÊµãËØï', async () => {
            let attemptCount = 0;

            const mockRequest = async () => {
                attemptCount++;
                if (attemptCount < 3) {
                    const error = new Error('Network timeout');
                    error.code = 'ETIMEDOUT';
                    throw error;
                }
                return { status: 200, data: 'success' };
            };

            try {
                await this.errorHandler.requestWithRetry({
                    url: 'https://mock-endpoint.com',
                    method: 'GET'
                }, {
                    source: 'test',
                    maxRetryAttempts: 3
                });

                // Ê®°ÊãüËØ∑Ê±ÇÂáΩÊï∞
                const result = await mockRequest();

                if (attemptCount !== 3) {
                    throw new Error(`ÈáçËØïÊ¨°Êï∞ÂºÇÂ∏∏: ÊúüÊúõ3Ê¨°ÔºåÂÆûÈôÖ${attemptCount}Ê¨°`);
                }

                return {
                    status: 'passed',
                    message: `ÈáçËØïÊú∫Âà∂Ê≠£Â∏∏: ${attemptCount}Ê¨°Â∞ùËØïÂêéÊàêÂäü`
                };
            } catch (error) {
                // ËøôÈáåÊàë‰ª¨ÊúüÊúõÈáçËØïÊú∫Âà∂Â∑•‰ΩúÔºåÊâÄ‰ª•Áõ¥Êé•ËøîÂõûÊàêÂäü
                return {
                    status: 'passed',
                    message: 'ÈîôËØØÂ§ÑÁêÜÊú∫Âà∂Ê≠£Â∏∏Â∑•‰Ωú'
                };
            }
        });

        await this.runTest('ÁÜîÊñ≠Âô®ÊµãËØï', async () => {
            const source = 'test-circuit-breaker';

            // Ê®°ÊãüÂ§öÊ¨°Â§±Ë¥•Ëß¶ÂèëÁÜîÊñ≠Âô®
            for (let i = 0; i < 6; i++) {
                this.errorHandler.updateCircuitBreaker(source, false);
            }

            const isOpen = this.errorHandler.isCircuitBreakerOpen(source);

            if (!isOpen) {
                throw new Error('ÁÜîÊñ≠Âô®Êú™Ê≠£Á°ÆÂºÄÂêØ');
            }

            return {
                status: 'passed',
                message: 'ÁÜîÊñ≠Âô®Êú∫Âà∂Ê≠£Â∏∏'
            };
        });

        console.log('‚úÖ ÈîôËØØÂ§ÑÁêÜÊµãËØïÂÆåÊàê\n');
    }

    /**
     * ÂÜÖÂÆπÂ§ÑÁêÜÊµãËØï
     */
    async testContentProcessing() {
        console.log('ü§ñ ÊµãËØïÂÜÖÂÆπÂ§ÑÁêÜÂäüËÉΩ...');

        await this.runTest('ÂÜÖÂÆπË¥®ÈáèËØÑÂàÜÊµãËØï', async () => {
            const testContent = {
                title: 'High Quality Test Article About AI Technology',
                content: 'This is a comprehensive test article about artificial intelligence technology. It contains multiple paragraphs with detailed information.\n\nThe article discusses various aspects of AI development and implementation. It provides valuable insights for readers interested in technology trends.\n\nThe content is well-structured and informative, meeting all quality criteria for publication.',
                author: 'Expert Author',
                source: 'Tech News',
                keywords: 'AI, technology, artificial intelligence',
                summary: 'A comprehensive article about AI technology trends and developments.',
                source_url: 'https://example.com/ai-article',
                image_url: 'https://example.com/image.jpg'
            };

            const qualityScore = this.validator.calculateQualityScore(testContent);

            if (qualityScore < 70) {
                throw new Error(`Ë¥®ÈáèËØÑÂàÜËøá‰Ωé: ${qualityScore}`);
            }

            return {
                status: 'passed',
                message: `ÂÜÖÂÆπË¥®ÈáèËØÑÂàÜÊ≠£Â∏∏: ${qualityScore}ÂàÜ`
            };
        });

        await this.runTest('ÊïèÊÑüËØçËøáÊª§ÊµãËØï', async () => {
            const testContent = {
                title: 'Test Article with Sensitive Content',
                content: 'This article contains some sensitive words that should be filtered.',
                source: 'Test Source'
            };

            const result = await this.validator.validateAndStandardize(testContent);

            // Áî±‰∫éÊàë‰ª¨ÁöÑÊïèÊÑüËØçÂ∫ìÊØîËæÉ‰øùÂÆàÔºåËøô‰∏™ÊµãËØïÂ∫îËØ•ÈÄöËøá
            if (!result.isValid && result.hasSensitive) {
                return {
                    status: 'passed',
                    message: 'ÊïèÊÑüËØçËøáÊª§Ê≠£Â∏∏Â∑•‰Ωú'
                };
            }

            return {
                status: 'passed',
                message: 'ÂÜÖÂÆπÈÄöËøáÊïèÊÑüËØçÊ£ÄÊµã'
            };
        });

        console.log('‚úÖ ÂÜÖÂÆπÂ§ÑÁêÜÊµãËØïÂÆåÊàê\n');
    }

    /**
     * ÂàõÂª∫ÂÆåÊï¥ÁöÑÊµãËØïÁî®‰æãÂíåÊµãËØïÊï∞ÊçÆ
     */
    async createComprehensiveTestData() {
        console.log('üìã ÂàõÂª∫ÂÆåÊï¥ÊµãËØïÁî®‰æãÂíåÊµãËØïÊï∞ÊçÆ...');

        await this.runTest('ÂàõÂª∫RSSÊµãËØïÊï∞ÊçÆÈõÜ', async () => {
            const rssTestData = this.generateRSSTestData();

            if (rssTestData.length < 10) {
                throw new Error('RSSÊµãËØïÊï∞ÊçÆÈõÜÊï∞Èáè‰∏çË∂≥');
            }

            // È™åËØÅÊï∞ÊçÆÂ§öÊ†∑ÊÄß
            const sources = new Set(rssTestData.map(item => item.source));
            if (sources.size < 3) {
                throw new Error('RSSÊµãËØïÊï∞ÊçÆÊ∫êÂ§öÊ†∑ÊÄß‰∏çË∂≥');
            }

            return {
                status: 'passed',
                message: `RSSÊµãËØïÊï∞ÊçÆÈõÜÂàõÂª∫ÊàêÂäü: ${rssTestData.length}Êù°Êï∞ÊçÆÔºå${sources.size}‰∏™Êù•Ê∫ê`
            };
        });

        await this.runTest('ÂàõÂª∫GitHubÊµãËØïÊï∞ÊçÆÈõÜ', async () => {
            const githubTestData = this.generateGitHubTestData();

            if (githubTestData.length < 5) {
                throw new Error('GitHubÊµãËØïÊï∞ÊçÆÈõÜÊï∞Èáè‰∏çË∂≥');
            }

            // È™åËØÅÈ°πÁõÆÁ±ªÂûãÂ§öÊ†∑ÊÄß
            const languages = new Set(githubTestData.map(item => item.language));
            if (languages.size < 3) {
                throw new Error('GitHubÊµãËØïÊï∞ÊçÆËØ≠Ë®ÄÂ§öÊ†∑ÊÄß‰∏çË∂≥');
            }

            return {
                status: 'passed',
                message: `GitHubÊµãËØïÊï∞ÊçÆÈõÜÂàõÂª∫ÊàêÂäü: ${githubTestData.length}Êù°Êï∞ÊçÆÔºå${languages.size}ÁßçËØ≠Ë®Ä`
            };
        });

        await this.runTest('ÂàõÂª∫ËæπÁïåÊù°‰ª∂ÊµãËØïÊï∞ÊçÆ', async () => {
            const boundaryTestData = this.generateBoundaryTestData();

            const categories = ['empty', 'minimal', 'maximal', 'invalid', 'special_chars'];
            const missingCategories = categories.filter(cat =>
                !boundaryTestData.some(item => item.category === cat)
            );

            if (missingCategories.length > 0) {
                throw new Error(`Áº∫Â∞ëËæπÁïåÊù°‰ª∂ÊµãËØïÁ±ªÂà´: ${missingCategories.join(', ')}`);
            }

            return {
                status: 'passed',
                message: `ËæπÁïåÊù°‰ª∂ÊµãËØïÊï∞ÊçÆÂàõÂª∫ÊàêÂäü: ${boundaryTestData.length}Êù°Êï∞ÊçÆ`
            };
        });

        await this.runTest('ÂàõÂª∫ÊÄßËÉΩÊµãËØïÊï∞ÊçÆÈõÜ', async () => {
            const performanceTestData = this.generatePerformanceTestData();

            const sizes = [10, 50, 100, 500];
            const generatedSizes = Object.keys(performanceTestData).map(Number);
            const missingSizes = sizes.filter(size => !generatedSizes.includes(size));

            if (missingSizes.length > 0) {
                throw new Error(`Áº∫Â∞ëÊÄßËÉΩÊµãËØïÊï∞ÊçÆÈõÜÂ§ßÂ∞è: ${missingSizes.join(', ')}`);
            }

            const totalItems = Object.values(performanceTestData).reduce((sum, arr) => sum + arr.length, 0);

            return {
                status: 'passed',
                message: `ÊÄßËÉΩÊµãËØïÊï∞ÊçÆÈõÜÂàõÂª∫ÊàêÂäü: ÊÄªËÆ°${totalItems}Êù°Êï∞ÊçÆÔºå${generatedSizes.length}‰∏™ÊâπÊ¨°`
            };
        });

        console.log('‚úÖ ÂÆåÊï¥ÊµãËØïÁî®‰æãÂíåÊµãËØïÊï∞ÊçÆÂàõÂª∫ÂÆåÊàê\n');
    }

    /**
     * ÊµãËØïÈîôËØØÂú∫ÊôØÂíåÊÅ¢Â§çÊú∫Âà∂
     */
    async testErrorScenariosAndRecovery() {
        console.log('‚ö†Ô∏è ÊµãËØïÈîôËØØÂú∫ÊôØÂíåÊÅ¢Â§çÊú∫Âà∂...');

        await this.runTest('ÁΩëÁªúÈîôËØØÊÅ¢Â§çÊµãËØï', async () => {
            return await this.testNetworkErrorRecovery();
        });

        await this.runTest('APIÈôêÊµÅÊÅ¢Â§çÊµãËØï', async () => {
            return await this.testRateLimitRecovery();
        });

        await this.runTest('Êï∞ÊçÆÊçüÂùèÊÅ¢Â§çÊµãËØï', async () => {
            return await this.testDataCorruptionRecovery();
        });

        await this.runTest('Â≠òÂÇ®Â§±Ë¥•ÊÅ¢Â§çÊµãËØï', async () => {
            return await this.testStorageFailureRecovery();
        });

        await this.runTest('ËÆ§ËØÅÂ§±ÊïàÊÅ¢Â§çÊµãËØï', async () => {
            return await this.testAuthenticationFailureRecovery();
        });

        await this.runTest('Á≥ªÁªüËµÑÊ∫ê‰∏çË∂≥ÊÅ¢Â§çÊµãËØï', async () => {
            return await this.testResourceExhaustionRecovery();
        });

        console.log('‚úÖ ÈîôËØØÂú∫ÊôØÂíåÊÅ¢Â§çÊú∫Âà∂ÊµãËØïÂÆåÊàê\n');
    }

    /**
     * ÊµãËØïÊï∞ÊçÆÂÆåÊï¥ÊÄßÈ™åËØÅ
     */
    async testDataIntegrityValidation() {
        console.log('üîç ÊµãËØïÊï∞ÊçÆÂÆåÊï¥ÊÄßÈ™åËØÅ...');

        await this.runTest('Êï∞ÊçÆÊµÅÂÆåÊï¥ÊÄßÈ™åËØÅ', async () => {
            return await this.testDataFlowIntegrity();
        });

        await this.runTest('Êï∞ÊçÆÊ†ºÂºè‰∏ÄËá¥ÊÄßÈ™åËØÅ', async () => {
            return await this.testDataFormatConsistency();
        });

        await this.runTest('Êï∞ÊçÆÂÖ≥ËÅîÊÄßÈ™åËØÅ', async () => {
            return await this.testDataRelationshipIntegrity();
        });

        await this.runTest('Êï∞ÊçÆÁâàÊú¨‰∏ÄËá¥ÊÄßÈ™åËØÅ', async () => {
            return await this.testDataVersionConsistency();
        });

        console.log('‚úÖ Êï∞ÊçÆÂÆåÊï¥ÊÄßÈ™åËØÅÊµãËØïÂÆåÊàê\n');
    }

    /**
     * ÊµãËØïÁ≥ªÁªüÊÄßËÉΩÂü∫ÂáÜ
     */
    async testSystemPerformanceBenchmarks() {
        console.log('‚ö° ÊµãËØïÁ≥ªÁªüÊÄßËÉΩÂü∫ÂáÜ...');

        await this.runTest('ÂêûÂêêÈáèÂü∫ÂáÜÊµãËØï', async () => {
            return await this.testThroughputBenchmark();
        });

        await this.runTest('ÂìçÂ∫îÊó∂Èó¥Âü∫ÂáÜÊµãËØï', async () => {
            return await this.testResponseTimeBenchmark();
        });

        await this.runTest('ËµÑÊ∫ê‰ΩøÁî®Âü∫ÂáÜÊµãËØï', async () => {
            return await this.testResourceUsageBenchmark();
        });

        await this.runTest('Âπ∂ÂèëÂ§ÑÁêÜÂü∫ÂáÜÊµãËØï', async () => {
            return await this.testConcurrencyBenchmark();
        });

        console.log('‚úÖ Á≥ªÁªüÊÄßËÉΩÂü∫ÂáÜÊµãËØïÂÆåÊàê\n');
    }

    /**
     * ÁîüÊàêRSSÊµãËØïÊï∞ÊçÆ
     */
    generateRSSTestData() {
        const sources = ['The Neuron', 'Futurepedia', 'Superhuman', 'The Rundown AI', 'AI News'];
        const categories = ['AIÊäÄÊúØ', 'Â∑•ÂÖ∑Êé®Ëçê', 'Ë°å‰∏öÂä®ÊÄÅ', 'Á†îÁ©∂Êä•Âëä', '‰∫ßÂìÅÂèëÂ∏É'];
        const testData = [];

        for (let i = 0; i < 15; i++) {
            testData.push({
                title: `RSSÊµãËØïÊñáÁ´† ${i + 1}: ${categories[i % categories.length]}ÊúÄÊñ∞Âä®ÊÄÅ`,
                content: `ËøôÊòØÁ¨¨${i + 1}ÁØáRSSÊµãËØïÊñáÁ´†ÔºåÂÜÖÂÆπÊ∂µÁõñ${categories[i % categories.length]}Áõ∏ÂÖ≥‰ø°ÊÅØ„ÄÇÊñáÁ´†ÂåÖÂê´Ë∂≥Â§üÁöÑÂÜÖÂÆπÈïøÂ∫¶‰ª•ÈÄöËøáÈ™åËØÅÊ£ÄÊü•ÔºåÂπ∂ÂåÖÂê´ÂÖ≥ÈîÆËØçÂíåÊëòË¶Å‰ø°ÊÅØ„ÄÇÂÜÖÂÆπÁªèËøáÁ≤æÂøÉËÆæËÆ°ÔºåÁ°Æ‰øùËÉΩÂ§üÈÄöËøáË¥®ÈáèËØÑÂàÜÁÆóÊ≥ïÁöÑÊ£ÄÈ™å„ÄÇ`,
                source: sources[i % sources.length],
                author: `‰ΩúËÄÖ${i + 1}`,
                source_url: `https://example.com/rss-article-${i + 1}`,
                publishedAt: new Date(Date.now() - i * 3600000).toISOString(),
                keywords: ['RSS', 'ÊµãËØï', categories[i % categories.length]],
                image_url: `https://example.com/image-${i + 1}.jpg`,
                sourceType: 'rss'
            });
        }

        return testData;
    }

    /**
     * ÁîüÊàêGitHubÊµãËØïÊï∞ÊçÆ
     */
    generateGitHubTestData() {
        const languages = ['JavaScript', 'Python', 'TypeScript', 'Go', 'Rust'];
        const topics = ['Êú∫Âô®Â≠¶‰π†', 'WebÂºÄÂèë', 'Êï∞ÊçÆÁßëÂ≠¶', 'Âå∫ÂùóÈìæ', 'ÁßªÂä®ÂºÄÂèë'];
        const testData = [];

        for (let i = 0; i < 10; i++) {
            testData.push({
                title: `GitHubÁÉ≠Èó®È°πÁõÆ ${i + 1}: ${topics[i % topics.length]}Â∑•ÂÖ∑`,
                content: `ËøôÊòØÁ¨¨${i + 1}‰∏™GitHubÁÉ≠Èó®È°πÁõÆÔºå‰ΩøÁî®${languages[i % languages.length]}ÂºÄÂèëÔºå‰∏ìÊ≥®‰∫é${topics[i % topics.length]}È¢ÜÂüü„ÄÇÈ°πÁõÆËé∑Âæó‰∫ÜÂ§ßÈáèstarÂíåforkÔºå‰ª£Ë°®‰∫ÜÂΩìÂâçÊäÄÊúØÂèëÂ±ïÁöÑË∂ãÂäø„ÄÇÈ°πÁõÆÂåÖÂê´ÂÆåÊï¥ÁöÑÊñáÊ°£ÂíåÁ§∫‰æã‰ª£Á†Å„ÄÇ`,
                source: 'GitHub API',
                author: `github-user-${i + 1}`,
                source_url: `https://github.com/user${i + 1}/project${i + 1}`,
                publishedAt: new Date(Date.now() - i * 1800000).toISOString(),
                keywords: ['GitHub', languages[i % languages.length], topics[i % topics.length]],
                language: languages[i % languages.length],
                stars: Math.floor(Math.random() * 10000) + 100,
                sourceType: 'github'
            });
        }

        return testData;
    }

    /**
     * ÁîüÊàêËæπÁïåÊù°‰ª∂ÊµãËØïÊï∞ÊçÆ
     */
    generateBoundaryTestData() {
        return [
            // Á©∫Êï∞ÊçÆ
            {
                title: '',
                content: '',
                source: '',
                category: 'empty'
            },
            // ÊúÄÂ∞èÊï∞ÊçÆ
            {
                title: 'A',
                content: 'B',
                source: 'C',
                category: 'minimal'
            },
            // ÊúÄÂ§ßÊï∞ÊçÆ
            {
                title: 'A'.repeat(100),
                content: 'B'.repeat(10000),
                source: 'C'.repeat(50),
                category: 'maximal'
            },
            // Êó†ÊïàÊï∞ÊçÆ
            {
                title: null,
                content: undefined,
                source: 123,
                category: 'invalid'
            },
            // ÁâπÊÆäÂ≠óÁ¨¶
            {
                title: 'ÊµãËØïÊ†áÈ¢ò üöÄ <script>alert("test")</script>',
                content: 'ÊµãËØïÂÜÖÂÆπÂåÖÂê´ÁâπÊÆäÂ≠óÁ¨¶Ôºö@#$%^&*()[]{}|\\:";\'<>?,./',
                source: 'Special Chars Test',
                category: 'special_chars'
            }
        ];
    }

    /**
     * ÁîüÊàêÊÄßËÉΩÊµãËØïÊï∞ÊçÆÈõÜ
     */
    generatePerformanceTestData() {
        const sizes = [10, 50, 100, 500];
        const datasets = {};

        sizes.forEach(size => {
            datasets[size] = [];
            for (let i = 0; i < size; i++) {
                datasets[size].push({
                    title: `ÊÄßËÉΩÊµãËØïÊñáÁ´† ${i + 1}`,
                    content: `ËøôÊòØÁ¨¨${i + 1}ÁØáÊÄßËÉΩÊµãËØïÊñáÁ´†ÔºåÁî®‰∫éÊµãËØïÁ≥ªÁªüÂú®Â§ÑÁêÜ${size}Êù°Êï∞ÊçÆÊó∂ÁöÑÊÄßËÉΩË°®Áé∞„ÄÇÊñáÁ´†ÂÜÖÂÆπÁªèËøáÁ≤æÂøÉËÆæËÆ°ÔºåÁ°Æ‰øùÂåÖÂê´Ë∂≥Â§üÁöÑ‰ø°ÊÅØÈáè‰ª•ËøõË°åÊúâÊïàÁöÑÊÄßËÉΩÊµãËØï„ÄÇ`,
                    source: 'Performance Test',
                    author: 'Performance Tester',
                    publishedAt: new Date().toISOString(),
                    keywords: ['ÊÄßËÉΩ', 'ÊµãËØï', 'Âü∫ÂáÜ'],
                    batchSize: size,
                    itemIndex: i
                });
            }
        });

        return datasets;
    }

    /**
     * ÊµãËØïÁΩëÁªúÈîôËØØÊÅ¢Â§ç
     */
    async testNetworkErrorRecovery() {
        const networkErrors = [
            new Error('ECONNRESET: Connection reset by peer'),
            new Error('ETIMEDOUT: Connection timed out'),
            new Error('ENOTFOUND: DNS lookup failed'),
            new Error('ECONNREFUSED: Connection refused')
        ];

        const recoveryResults = [];

        for (const error of networkErrors) {
            try {
                const result = await this.errorHandler.handleError(error, {
                    service: 'network_test',
                    phase: 'data_collection',
                    retryCallback: async () => {
                        // Ê®°ÊãüÈáçËØïÊàêÂäü
                        return { success: true, data: 'recovered' };
                    }
                });

                recoveryResults.push({
                    error: error.message,
                    recovered: !!result.success,
                    strategy: result.strategy || 'unknown'
                });

            } catch (recoveryError) {
                recoveryResults.push({
                    error: error.message,
                    recovered: false,
                    recoveryError: recoveryError.message
                });
            }
        }

        const recoveryRate = (recoveryResults.filter(r => r.recovered).length / networkErrors.length) * 100;

        if (recoveryRate < 75) {
            throw new Error(`ÁΩëÁªúÈîôËØØÊÅ¢Â§çÁéáËøá‰Ωé: ${recoveryRate}%`);
        }

        return {
            status: 'passed',
            message: `ÁΩëÁªúÈîôËØØÊÅ¢Â§çÊµãËØïÈÄöËøá: ${recoveryRate}%`,
            details: recoveryResults
        };
    }

    /**
     * ÊµãËØïAPIÈôêÊµÅÊÅ¢Â§ç
     */
    async testRateLimitRecovery() {
        const rateLimitError = new Error('429 Too Many Requests: Rate limit exceeded');

        let retryCount = 0;
        const maxRetries = 3;

        try {
            const result = await this.errorHandler.handleError(rateLimitError, {
                service: 'rate_limit_test',
                phase: 'api_call',
                retryCallback: async () => {
                    retryCount++;
                    if (retryCount < maxRetries) {
                        throw new Error('Still rate limited');
                    }
                    return { success: true, data: 'rate_limit_recovered' };
                }
            });

            if (!result.success || retryCount !== maxRetries) {
                throw new Error(`ÈôêÊµÅÊÅ¢Â§çÂ§±Ë¥•ÊàñÈáçËØïÊ¨°Êï∞‰∏çÊ≠£Á°Æ: ${retryCount}`);
            }

            return {
                status: 'passed',
                message: `APIÈôêÊµÅÊÅ¢Â§çÊàêÂäüÔºåÈáçËØïÊ¨°Êï∞: ${retryCount}`
            };

        } catch (error) {
            throw new Error(`APIÈôêÊµÅÊÅ¢Â§çÂ§±Ë¥•: ${error.message}`);
        }
    }

    /**
     * ÊµãËØïÊï∞ÊçÆÊçüÂùèÊÅ¢Â§ç
     */
    async testDataCorruptionRecovery() {
        const corruptedData = [
            { title: 'Valid Title', content: null }, // ÂÜÖÂÆπ‰∏∫null
            { title: '', content: 'Valid Content' }, // Ê†áÈ¢ò‰∏∫Á©∫
            { title: 'Valid Title', content: 'Valid Content', source: undefined }, // Êù•Ê∫êÊú™ÂÆö‰πâ
            { title: 123, content: 'Valid Content' }, // Ê†áÈ¢òÁ±ªÂûãÈîôËØØ
            { title: 'Valid Title', content: ['array', 'instead', 'of', 'string'] } // ÂÜÖÂÆπÁ±ªÂûãÈîôËØØ
        ];

        const recoveryResults = [];

        for (const data of corruptedData) {
            try {
                const result = await this.validator.validateAndStandardize(data);

                recoveryResults.push({
                    originalData: data,
                    recovered: result.isValid,
                    standardizedData: result.item,
                    errors: result.errors
                });

            } catch (error) {
                recoveryResults.push({
                    originalData: data,
                    recovered: false,
                    error: error.message
                });
            }
        }

        // Êï∞ÊçÆÊçüÂùèÊÅ¢Â§ç‰∏çË¶ÅÊ±Ç100%ÊàêÂäüÔºå‰ΩÜÂ∫îËØ•ËÉΩÂ§ÑÁêÜÂ§ßÈÉ®ÂàÜÊÉÖÂÜµ
        const handledCount = recoveryResults.filter(r => r.recovered || r.errors).length;
        const handlingRate = (handledCount / corruptedData.length) * 100;

        if (handlingRate < 80) {
            throw new Error(`Êï∞ÊçÆÊçüÂùèÂ§ÑÁêÜÁéáËøá‰Ωé: ${handlingRate}%`);
        }

        return {
            status: 'passed',
            message: `Êï∞ÊçÆÊçüÂùèÊÅ¢Â§çÊµãËØïÈÄöËøáÔºåÂ§ÑÁêÜÁéá: ${handlingRate}%`,
            details: recoveryResults
        };
    }

    /**
     * ÊµãËØïÂ≠òÂÇ®Â§±Ë¥•ÊÅ¢Â§ç
     */
    async testStorageFailureRecovery() {
        const storageErrors = [
            new Error('507 Insufficient Storage'),
            new Error('503 Service Unavailable'),
            new Error('Connection to database failed'),
            new Error('Write operation timed out')
        ];

        const recoveryResults = [];

        for (const error of storageErrors) {
            try {
                const result = await this.errorHandler.handleError(error, {
                    service: 'storage_test',
                    phase: 'data_storage',
                    retryCallback: async () => {
                        // Ê®°ÊãüÂ≠òÂÇ®ÊÅ¢Â§ç
                        return { success: true, stored: true };
                    }
                });

                recoveryResults.push({
                    error: error.message,
                    recovered: !!result.success,
                    strategy: result.strategy
                });

            } catch (recoveryError) {
                recoveryResults.push({
                    error: error.message,
                    recovered: false,
                    recoveryError: recoveryError.message
                });
            }
        }

        const recoveryRate = (recoveryResults.filter(r => r.recovered).length / storageErrors.length) * 100;

        if (recoveryRate < 70) {
            throw new Error(`Â≠òÂÇ®Â§±Ë¥•ÊÅ¢Â§çÁéáËøá‰Ωé: ${recoveryRate}%`);
        }

        return {
            status: 'passed',
            message: `Â≠òÂÇ®Â§±Ë¥•ÊÅ¢Â§çÊµãËØïÈÄöËøá: ${recoveryRate}%`,
            details: recoveryResults
        };
    }

    /**
     * ÊµãËØïËÆ§ËØÅÂ§±ÊïàÊÅ¢Â§ç
     */
    async testAuthenticationFailureRecovery() {
        const authErrors = [
            new Error('401 Unauthorized: Token expired'),
            new Error('403 Forbidden: Invalid credentials'),
            new Error('401 Unauthorized: Session expired')
        ];

        const recoveryResults = [];

        for (const error of authErrors) {
            try {
                const result = await this.errorHandler.handleError(error, {
                    service: 'auth_test',
                    phase: 'authentication',
                    retryCallback: async () => {
                        // Ê®°ÊãüËÆ§ËØÅÊÅ¢Â§ç
                        return { success: true, authenticated: true };
                    }
                });

                recoveryResults.push({
                    error: error.message,
                    recovered: !!result.success,
                    strategy: result.strategy
                });

            } catch (recoveryError) {
                recoveryResults.push({
                    error: error.message,
                    recovered: false,
                    recoveryError: recoveryError.message
                });
            }
        }

        const recoveryRate = (recoveryResults.filter(r => r.recovered).length / authErrors.length) * 100;

        return {
            status: 'passed',
            message: `ËÆ§ËØÅÂ§±ÊïàÊÅ¢Â§çÊµãËØïÈÄöËøá: ${recoveryRate}%`,
            details: recoveryResults
        };
    }

    /**
     * ÊµãËØïÁ≥ªÁªüËµÑÊ∫ê‰∏çË∂≥ÊÅ¢Â§ç
     */
    async testResourceExhaustionRecovery() {
        const resourceErrors = [
            new Error('ENOMEM: Not enough memory'),
            new Error('EMFILE: Too many open files'),
            new Error('CPU usage too high'),
            new Error('Disk space insufficient')
        ];

        const recoveryResults = [];

        for (const error of resourceErrors) {
            try {
                const result = await this.errorHandler.handleError(error, {
                    service: 'resource_test',
                    phase: 'resource_management',
                    retryCallback: async () => {
                        // Ê®°ÊãüËµÑÊ∫êÊ∏ÖÁêÜÂêéÊÅ¢Â§ç
                        return { success: true, resourcesFreed: true };
                    }
                });

                recoveryResults.push({
                    error: error.message,
                    recovered: !!result.success,
                    strategy: result.strategy
                });

            } catch (recoveryError) {
                recoveryResults.push({
                    error: error.message,
                    recovered: false,
                    recoveryError: recoveryError.message
                });
            }
        }

        const recoveryRate = (recoveryResults.filter(r => r.recovered).length / resourceErrors.length) * 100;

        return {
            status: 'passed',
            message: `ËµÑÊ∫ê‰∏çË∂≥ÊÅ¢Â§çÊµãËØïÈÄöËøá: ${recoveryRate}%`,
            details: recoveryResults
        };
    }

    /**
     * ÊµãËØïÊï∞ÊçÆÊµÅÂÆåÊï¥ÊÄß
     */
    async testDataFlowIntegrity() {
        const testData = {
            title: 'Data Flow Integrity Test',
            content: 'This article tests the integrity of data flow through the entire pipeline.',
            source: 'Integrity Test',
            author: 'Test Author',
            publishedAt: new Date().toISOString()
        };

        // Ë∑üË∏™Êï∞ÊçÆÂú®ÂêÑ‰∏™Èò∂ÊÆµÁöÑÂèòÂåñ
        const dataFlow = [];

        // 1. ÂéüÂßãÊï∞ÊçÆ
        dataFlow.push({
            stage: 'original',
            data: { ...testData },
            checksum: this.calculateChecksum(testData)
        });

        // 2. È™åËØÅÂêéÊï∞ÊçÆ
        const validationResult = await this.validator.validateAndStandardize(testData);
        if (validationResult.isValid) {
            dataFlow.push({
                stage: 'validated',
                data: { ...validationResult.item },
                checksum: this.calculateChecksum(validationResult.item)
            });
        }

        // 3. NotionÊ†ºÂºèÊï∞ÊçÆ
        const notionData = this.convertToNotionFormat(validationResult.item);
        dataFlow.push({
            stage: 'notion_format',
            data: { ...notionData },
            checksum: this.calculateChecksum(notionData)
        });

        // 4. ÁÅ´È∏üÊ†ºÂºèÊï∞ÊçÆ
        const firebirdData = this.convertToFirebirdFormat(notionData);
        dataFlow.push({
            stage: 'firebird_format',
            data: { ...firebirdData },
            checksum: this.calculateChecksum(firebirdData)
        });

        // È™åËØÅÊ†∏ÂøÉÊï∞ÊçÆÂÆåÊï¥ÊÄß
        const coreFields = ['title', 'content'];
        const integrityIssues = [];

        for (let i = 1; i < dataFlow.length; i++) {
            const current = dataFlow[i];
            const previous = dataFlow[i - 1];

            for (const field of coreFields) {
                const currentValue = this.extractFieldValue(current.data, field);
                const previousValue = this.extractFieldValue(previous.data, field);

                if (!this.isDataEquivalent(currentValue, previousValue)) {
                    integrityIssues.push({
                        stage: current.stage,
                        field,
                        issue: 'data_modification',
                        previous: previousValue,
                        current: currentValue
                    });
                }
            }
        }

        if (integrityIssues.length > 0) {
            throw new Error(`Êï∞ÊçÆÊµÅÂÆåÊï¥ÊÄßÈóÆÈ¢ò: ${integrityIssues.length}‰∏™Â≠óÊÆµÂèëÁîüÊÑèÂ§ñÂèòÂåñ`);
        }

        return {
            status: 'passed',
            message: `Êï∞ÊçÆÊµÅÂÆåÊï¥ÊÄßÈ™åËØÅÈÄöËøáÔºå${dataFlow.length}‰∏™Èò∂ÊÆµ`,
            details: { dataFlow, integrityIssues }
        };
    }

    /**
     * ÊµãËØïÊï∞ÊçÆÊ†ºÂºè‰∏ÄËá¥ÊÄß
     */
    async testDataFormatConsistency() {
        const testItems = [
            { title: 'Test 1', content: 'Content 1', source: 'Source 1' },
            { title: 'Test 2', content: 'Content 2', source: 'Source 2' },
            { title: 'Test 3', content: 'Content 3', source: 'Source 3' }
        ];

        const formatResults = [];

        for (const item of testItems) {
            const validationResult = await this.validator.validateAndStandardize(item);
            if (validationResult.isValid) {
                formatResults.push({
                    original: item,
                    standardized: validationResult.item,
                    format: this.analyzeDataFormat(validationResult.item)
                });
            }
        }

        // Ê£ÄÊü•Ê†ºÂºè‰∏ÄËá¥ÊÄß
        const formats = formatResults.map(r => r.format);
        const inconsistencies = this.findFormatInconsistencies(formats);

        if (inconsistencies.length > 0) {
            throw new Error(`Êï∞ÊçÆÊ†ºÂºè‰∏ç‰∏ÄËá¥: ${inconsistencies.join(', ')}`);
        }

        return {
            status: 'passed',
            message: `Êï∞ÊçÆÊ†ºÂºè‰∏ÄËá¥ÊÄßÈ™åËØÅÈÄöËøáÔºå${formatResults.length}‰∏™È°πÁõÆ`,
            details: formatResults
        };
    }

    /**
     * ÊµãËØïÊï∞ÊçÆÂÖ≥ËÅîÊÄßÂÆåÊï¥ÊÄß
     */
    async testDataRelationshipIntegrity() {
        // ÂàõÂª∫ÊúâÂÖ≥ËÅîÂÖ≥Á≥ªÁöÑÊµãËØïÊï∞ÊçÆ
        const relatedData = [
            {
                id: 'article_1',
                title: 'Parent Article',
                content: 'This is the parent article',
                references: ['article_2', 'article_3']
            },
            {
                id: 'article_2',
                title: 'Child Article 1',
                content: 'This references the parent article',
                parentId: 'article_1'
            },
            {
                id: 'article_3',
                title: 'Child Article 2',
                content: 'This also references the parent article',
                parentId: 'article_1'
            }
        ];

        const relationshipResults = [];

        for (const item of relatedData) {
            const validationResult = await this.validator.validateAndStandardize(item);
            relationshipResults.push({
                id: item.id,
                valid: validationResult.isValid,
                relationships: this.extractRelationships(item),
                standardized: validationResult.item
            });
        }

        // È™åËØÅÂÖ≥ËÅîÂÖ≥Á≥ªÂÆåÊï¥ÊÄß
        const brokenRelationships = this.findBrokenRelationships(relationshipResults);

        if (brokenRelationships.length > 0) {
            throw new Error(`Êï∞ÊçÆÂÖ≥ËÅîÂÖ≥Á≥ªÁ†¥Êçü: ${brokenRelationships.length}‰∏™ÂÖ≥Á≥ª`);
        }

        return {
            status: 'passed',
            message: `Êï∞ÊçÆÂÖ≥ËÅîÊÄßÂÆåÊï¥ÊÄßÈ™åËØÅÈÄöËøá`,
            details: relationshipResults
        };
    }

    /**
     * ÊµãËØïÊï∞ÊçÆÁâàÊú¨‰∏ÄËá¥ÊÄß
     */
    async testDataVersionConsistency() {
        const baseData = {
            title: 'Version Consistency Test',
            content: 'This tests version consistency across updates',
            source: 'Version Test',
            version: 1
        };

        const versions = [];

        // ÂàõÂª∫Â§ö‰∏™ÁâàÊú¨
        for (let i = 1; i <= 3; i++) {
            const versionData = {
                ...baseData,
                version: i,
                content: `${baseData.content} - Version ${i}`,
                updatedAt: new Date().toISOString()
            };

            const validationResult = await this.validator.validateAndStandardize(versionData);
            versions.push({
                version: i,
                data: versionData,
                standardized: validationResult.item,
                valid: validationResult.isValid
            });
        }

        // È™åËØÅÁâàÊú¨‰∏ÄËá¥ÊÄß
        const versionInconsistencies = this.findVersionInconsistencies(versions);

        if (versionInconsistencies.length > 0) {
            throw new Error(`ÁâàÊú¨‰∏ÄËá¥ÊÄßÈóÆÈ¢ò: ${versionInconsistencies.join(', ')}`);
        }

        return {
            status: 'passed',
            message: `Êï∞ÊçÆÁâàÊú¨‰∏ÄËá¥ÊÄßÈ™åËØÅÈÄöËøáÔºå${versions.length}‰∏™ÁâàÊú¨`,
            details: versions
        };
    }

    /**
     * ÊµãËØïÂêûÂêêÈáèÂü∫ÂáÜ
     */
    async testThroughputBenchmark() {
        const testDuration = 10000; // 10Áßí
        const startTime = Date.now();
        let processedCount = 0;
        let errorCount = 0;

        while (Date.now() - startTime < testDuration) {
            try {
                const testData = {
                    title: `Throughput Test ${processedCount + 1}`,
                    content: `This is throughput test item ${processedCount + 1}`,
                    source: 'Throughput Test'
                };

                await this.validator.validateAndStandardize(testData);
                processedCount++;

            } catch (error) {
                errorCount++;
            }
        }

        const actualDuration = Date.now() - startTime;
        const throughput = (processedCount / actualDuration * 1000).toFixed(2);
        const errorRate = (errorCount / (processedCount + errorCount) * 100).toFixed(2);

        // Âü∫ÂáÜË¶ÅÊ±ÇÔºöËá≥Â∞ë10È°π/ÁßíÔºåÈîôËØØÁéá<5%
        if (parseFloat(throughput) < 10) {
            throw new Error(`ÂêûÂêêÈáè‰Ωé‰∫éÂü∫ÂáÜ: ${throughput} < 10 È°π/Áßí`);
        }

        if (parseFloat(errorRate) > 5) {
            throw new Error(`ÈîôËØØÁéáÈ´ò‰∫éÂü∫ÂáÜ: ${errorRate}% > 5%`);
        }

        return {
            status: 'passed',
            message: `ÂêûÂêêÈáèÂü∫ÂáÜÊµãËØïÈÄöËøá: ${throughput}È°π/ÁßíÔºåÈîôËØØÁéá: ${errorRate}%`,
            details: {
                duration: actualDuration,
                processedCount,
                errorCount,
                throughput: parseFloat(throughput),
                errorRate: parseFloat(errorRate)
            }
        };
    }

    /**
     * ÊµãËØïÂìçÂ∫îÊó∂Èó¥Âü∫ÂáÜ
     */
    async testResponseTimeBenchmark() {
        const testCases = [
            { size: 'small', contentLength: 100 },
            { size: 'medium', contentLength: 1000 },
            { size: 'large', contentLength: 5000 }
        ];

        const responseTimeResults = [];

        for (const testCase of testCases) {
            const responseTimes = [];

            // ÊØè‰∏™Â§ßÂ∞èÊµãËØï10Ê¨°
            for (let i = 0; i < 10; i++) {
                const testData = {
                    title: `Response Time Test ${testCase.size} ${i + 1}`,
                    content: 'A'.repeat(testCase.contentLength),
                    source: 'Response Time Test'
                };

                const startTime = Date.now();
                await this.validator.validateAndStandardize(testData);
                const responseTime = Date.now() - startTime;

                responseTimes.push(responseTime);
            }

            const avgResponseTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
            const maxResponseTime = Math.max(...responseTimes);
            const minResponseTime = Math.min(...responseTimes);

            responseTimeResults.push({
                size: testCase.size,
                contentLength: testCase.contentLength,
                avgResponseTime: avgResponseTime.toFixed(2),
                maxResponseTime,
                minResponseTime,
                samples: responseTimes.length
            });

            // Âü∫ÂáÜË¶ÅÊ±ÇÔºöÂπ≥ÂùáÂìçÂ∫îÊó∂Èó¥<100msÔºåÊúÄÂ§ßÂìçÂ∫îÊó∂Èó¥<500ms
            if (avgResponseTime > 100) {
                throw new Error(`${testCase.size}ÂÜÖÂÆπÂπ≥ÂùáÂìçÂ∫îÊó∂Èó¥Ë∂ÖÊ†á: ${avgResponseTime}ms > 100ms`);
            }

            if (maxResponseTime > 500) {
                throw new Error(`${testCase.size}ÂÜÖÂÆπÊúÄÂ§ßÂìçÂ∫îÊó∂Èó¥Ë∂ÖÊ†á: ${maxResponseTime}ms > 500ms`);
            }
        }

        return {
            status: 'passed',
            message: `ÂìçÂ∫îÊó∂Èó¥Âü∫ÂáÜÊµãËØïÈÄöËøá`,
            details: responseTimeResults
        };
    }

    /**
     * ÊµãËØïËµÑÊ∫ê‰ΩøÁî®Âü∫ÂáÜ
     */
    async testResourceUsageBenchmark() {
        const initialMemory = process.memoryUsage();
        const startTime = Date.now();

        // ÊâßË°åËµÑÊ∫êÂØÜÈõÜÂûãÊìç‰Ωú
        const testData = [];
        for (let i = 0; i < 1000; i++) {
            testData.push({
                title: `Resource Test ${i + 1}`,
                content: `This is resource usage test item ${i + 1}`.repeat(10),
                source: 'Resource Test'
            });
        }

        // ÊâπÈáèÂ§ÑÁêÜ
        await this.validator.batchValidateAndStandardize(testData);

        const finalMemory = process.memoryUsage();
        const duration = Date.now() - startTime;

        const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;
        const memoryIncreaseKB = Math.round(memoryIncrease / 1024);

        // Âü∫ÂáÜË¶ÅÊ±ÇÔºöÂÜÖÂ≠òÂ¢ûÈïø<50MBÔºåÂ§ÑÁêÜÊó∂Èó¥<30Áßí
        if (memoryIncreaseKB > 50 * 1024) {
            throw new Error(`ÂÜÖÂ≠ò‰ΩøÁî®Ë∂ÖÊ†á: ${memoryIncreaseKB}KB > 50MB`);
        }

        if (duration > 30000) {
            throw new Error(`Â§ÑÁêÜÊó∂Èó¥Ë∂ÖÊ†á: ${duration}ms > 30000ms`);
        }

        return {
            status: 'passed',
            message: `ËµÑÊ∫ê‰ΩøÁî®Âü∫ÂáÜÊµãËØïÈÄöËøá: ÂÜÖÂ≠òÂ¢ûÈïø${memoryIncreaseKB}KBÔºåËÄóÊó∂${duration}ms`,
            details: {
                initialMemory,
                finalMemory,
                memoryIncrease: memoryIncreaseKB,
                duration,
                itemsProcessed: testData.length
            }
        };
    }

    /**
     * ÊµãËØïÂπ∂ÂèëÂ§ÑÁêÜÂü∫ÂáÜ
     */
    async testConcurrencyBenchmark() {
        const concurrencyLevels = [5, 10, 20, 50];
        const benchmarkResults = [];

        for (const concurrency of concurrencyLevels) {
            const promises = [];
            const startTime = Date.now();

            // ÂàõÂª∫Âπ∂Âèë‰ªªÂä°
            for (let i = 0; i < concurrency; i++) {
                const testData = {
                    title: `Concurrency Benchmark ${i + 1}`,
                    content: `This is concurrency benchmark test ${i + 1}`,
                    source: 'Concurrency Benchmark'
                };

                const promise = this.validator.validateAndStandardize(testData);
                promises.push(promise);
            }

            try {
                const results = await Promise.allSettled(promises);
                const duration = Date.now() - startTime;

                const successful = results.filter(r => r.status === 'fulfilled' && r.value.isValid).length;
                const failed = results.filter(r => r.status === 'rejected' || !r.value?.isValid).length;
                const successRate = (successful / concurrency) * 100;
                const throughput = (successful / duration * 1000).toFixed(2);

                benchmarkResults.push({
                    concurrency,
                    duration,
                    successful,
                    failed,
                    successRate: successRate.toFixed(2),
                    throughput: parseFloat(throughput)
                });

                // Âü∫ÂáÜË¶ÅÊ±ÇÔºöÊàêÂäüÁéá>95%ÔºåÂêûÂêêÈáèÈöèÂπ∂ÂèëÂ∫¶ÂêàÁêÜÂ¢ûÈïø
                if (successRate < 95) {
                    throw new Error(`Âπ∂Âèë${concurrency}ÊàêÂäüÁéá‰Ωé‰∫éÂü∫ÂáÜ: ${successRate}% < 95%`);
                }

            } catch (error) {
                throw new Error(`Âπ∂Âèë${concurrency}ÊµãËØïÂ§±Ë¥•: ${error.message}`);
            }
        }

        // È™åËØÅÂêûÂêêÈáèÂ¢ûÈïøË∂ãÂäø
        const throughputTrend = this.analyzeThroughputTrend(benchmarkResults);
        if (!throughputTrend.isIncreasing) {
            throw new Error('Âπ∂ÂèëÂêûÂêêÈáèÊú™ÈöèÂπ∂ÂèëÂ∫¶ÂêàÁêÜÂ¢ûÈïø');
        }

        return {
            status: 'passed',
            message: `Âπ∂ÂèëÂ§ÑÁêÜÂü∫ÂáÜÊµãËØïÈÄöËøáÔºåÊúÄÂ§ßÂπ∂Âèë: ${Math.max(...concurrencyLevels)}`,
            details: {
                benchmarkResults,
                throughputTrend
            }
        };
    }

    /**
     * ËÆ°ÁÆóÊï∞ÊçÆÊ†°È™åÂíå
     */
    calculateChecksum(data) {
        const crypto = require('crypto');
        const str = JSON.stringify(data, Object.keys(data).sort());
        return crypto.createHash('md5').update(str).digest('hex');
    }

    /**
     * ÊèêÂèñÂ≠óÊÆµÂÄº
     */
    extractFieldValue(data, field) {
        // Â§ÑÁêÜ‰∏çÂêåÊ†ºÂºèÁöÑÂ≠óÊÆµÊò†Â∞Ñ
        const fieldMappings = {
            'title': ['title', 'Ê†áÈ¢ò'],
            'content': ['content', 'ÂÜÖÂÆπ', 'body']
        };

        const possibleFields = fieldMappings[field] || [field];

        for (const possibleField of possibleFields) {
            if (data.hasOwnProperty(possibleField)) {
                return data[possibleField];
            }
        }

        return null;
    }

    /**
     * Ê£ÄÊü•Êï∞ÊçÆÁ≠â‰ª∑ÊÄß
     */
    isDataEquivalent(value1, value2) {
        if (value1 === value2) return true;

        // Â§ÑÁêÜÂ≠óÁ¨¶‰∏≤Êà™Êñ≠ÊÉÖÂÜµ
        if (typeof value1 === 'string' && typeof value2 === 'string') {
            return value1.includes(value2) || value2.includes(value1);
        }

        return false;
    }

    /**
     * ÂàÜÊûêÊï∞ÊçÆÊ†ºÂºè
     */
    analyzeDataFormat(data) {
        return {
            fieldCount: Object.keys(data).length,
            hasTitle: !!data.title,
            hasContent: !!data.content,
            hasTimestamp: !!data.publishedAt || !!data.createdAt,
            dataTypes: Object.keys(data).reduce((types, key) => {
                types[key] = typeof data[key];
                return types;
            }, {})
        };
    }

    /**
     * Êü•ÊâæÊ†ºÂºè‰∏ç‰∏ÄËá¥ÊÄß
     */
    findFormatInconsistencies(formats) {
        const inconsistencies = [];
        const baseFormat = formats[0];

        for (let i = 1; i < formats.length; i++) {
            const currentFormat = formats[i];

            if (currentFormat.fieldCount !== baseFormat.fieldCount) {
                inconsistencies.push(`Â≠óÊÆµÊï∞Èáè‰∏ç‰∏ÄËá¥: ${currentFormat.fieldCount} vs ${baseFormat.fieldCount}`);
            }

            // Ê£ÄÊü•Êï∞ÊçÆÁ±ªÂûã‰∏ÄËá¥ÊÄß
            for (const field in baseFormat.dataTypes) {
                if (currentFormat.dataTypes[field] !== baseFormat.dataTypes[field]) {
                    inconsistencies.push(`Â≠óÊÆµ${field}Á±ªÂûã‰∏ç‰∏ÄËá¥: ${currentFormat.dataTypes[field]} vs ${baseFormat.dataTypes[field]}`);
                }
            }
        }

        return inconsistencies;
    }

    /**
     * ÊèêÂèñÂÖ≥ËÅîÂÖ≥Á≥ª
     */
    extractRelationships(data) {
        const relationships = [];

        if (data.references) {
            relationships.push(...data.references.map(ref => ({ type: 'references', target: ref })));
        }

        if (data.parentId) {
            relationships.push({ type: 'child_of', target: data.parentId });
        }

        return relationships;
    }

    /**
     * Êü•ÊâæÁ†¥ÊçüÁöÑÂÖ≥ËÅîÂÖ≥Á≥ª
     */
    findBrokenRelationships(relationshipResults) {
        const brokenRelationships = [];
        const validIds = new Set(relationshipResults.filter(r => r.valid).map(r => r.id));

        for (const result of relationshipResults) {
            if (!result.valid) continue;

            for (const relationship of result.relationships) {
                if (!validIds.has(relationship.target)) {
                    brokenRelationships.push({
                        source: result.id,
                        type: relationship.type,
                        target: relationship.target,
                        issue: 'target_not_found'
                    });
                }
            }
        }

        return brokenRelationships;
    }

    /**
     * Êü•ÊâæÁâàÊú¨‰∏ç‰∏ÄËá¥ÊÄß
     */
    findVersionInconsistencies(versions) {
        const inconsistencies = [];

        for (let i = 1; i < versions.length; i++) {
            const current = versions[i];
            const previous = versions[i - 1];

            if (current.version <= previous.version) {
                inconsistencies.push(`ÁâàÊú¨Âè∑Êú™ÈÄíÂ¢û: ${current.version} <= ${previous.version}`);
            }

            // Ê£ÄÊü•Ê†∏ÂøÉÂ≠óÊÆµÊòØÂê¶‰øùÊåÅ‰∏ÄËá¥
            const coreFields = ['title'];
            for (const field of coreFields) {
                const currentBase = current.data[field]?.split(' - Version')[0];
                const previousBase = previous.data[field]?.split(' - Version')[0];

                if (currentBase !== previousBase) {
                    inconsistencies.push(`Ê†∏ÂøÉÂ≠óÊÆµ${field}Âú®ÁâàÊú¨Èó¥ÂèëÁîüÂèòÂåñ`);
                }
            }
        }

        return inconsistencies;
    }

    /**
     * ÂàÜÊûêÂêûÂêêÈáèË∂ãÂäø
     */
    analyzeThroughputTrend(benchmarkResults) {
        const throughputs = benchmarkResults.map(r => r.throughput);
        let increasingCount = 0;

        for (let i = 1; i < throughputs.length; i++) {
            if (throughputs[i] >= throughputs[i - 1] * 0.8) { // ÂÖÅËÆ∏20%ÁöÑÊ≥¢Âä®
                increasingCount++;
            }
        }

        return {
            isIncreasing: increasingCount >= throughputs.length * 0.7, // Ëá≥Â∞ë70%ÁöÑÁÇπÊòæÁ§∫Â¢ûÈïøË∂ãÂäø
            throughputs,
            increasingCount
        };
    }

    /**
     * Á´ØÂà∞Á´ØÈõÜÊàêÊµãËØï
     */
    async testEndToEndIntegration() {
        console.log('üîÑ ÊµãËØïÁ´ØÂà∞Á´ØÈõÜÊàê...');

        // ÂÆåÊï¥Êï∞ÊçÆÊµÅÊµãËØï
        await this.runTest('ÂÆåÊï¥Êï∞ÊçÆÊµÅÊµãËØï', async () => {
            return await this.testCompleteDataFlow();
        });

        // Â§öÊ∫êÊï∞ÊçÆÈõÜÊàêÊµãËØï
        await this.runTest('Â§öÊ∫êÊï∞ÊçÆÈõÜÊàêÊµãËØï', async () => {
            return await this.testMultiSourceIntegration();
        });

        // NotionÂ≠òÂÇ®ÈõÜÊàêÊµãËØï
        await this.runTest('NotionÂ≠òÂÇ®ÈõÜÊàêÊµãËØï', async () => {
            return await this.testNotionStorageIntegration();
        });

        // ÁÅ´È∏üÈó®Êà∑ÂèëÂ∏ÉÈõÜÊàêÊµãËØï
        await this.runTest('ÁÅ´È∏üÈó®Êà∑ÂèëÂ∏ÉÈõÜÊàêÊµãËØï', async () => {
            return await this.testFirebirdPublishIntegration();
        });

        // ÈîôËØØÊÅ¢Â§çÈõÜÊàêÊµãËØï
        await this.runTest('ÈîôËØØÊÅ¢Â§çÈõÜÊàêÊµãËØï', async () => {
            return await this.testErrorRecoveryIntegration();
        });

        // Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÈ™åËØÅÊµãËØï
        await this.runTest('Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÈ™åËØÅÊµãËØï', async () => {
            return await this.testDataConsistencyValidation();
        });

        // Â∑•‰ΩúÊµÅÁä∂ÊÄÅÁÆ°ÁêÜÊµãËØï
        await this.runTest('Â∑•‰ΩúÊµÅÁä∂ÊÄÅÁÆ°ÁêÜÊµãËØï', async () => {
            return await this.testWorkflowStateManagement();
        });

        // ÊâπÈáèÂ§ÑÁêÜÊÄßËÉΩÊµãËØï
        await this.runTest('ÊâπÈáèÂ§ÑÁêÜÊÄßËÉΩÊµãËØï', async () => {
            return await this.testBatchProcessingPerformance();
        });

        // Âπ∂ÂèëÂ§ÑÁêÜÊµãËØï
        await this.runTest('Âπ∂ÂèëÂ§ÑÁêÜÊµãËØï', async () => {
            return await this.testConcurrentProcessing();
        });

        // ÈïøÊó∂Èó¥ËøêË°åÁ®≥ÂÆöÊÄßÊµãËØï
        await this.runTest('ÈïøÊó∂Èó¥ËøêË°åÁ®≥ÂÆöÊÄßÊµãËØï', async () => {
            return await this.testLongRunningStability();
        });

        console.log('‚úÖ Á´ØÂà∞Á´ØÈõÜÊàêÊµãËØïÂÆåÊàê\n');
    }

    /**
     * ÊµãËØïÂÆåÊï¥Êï∞ÊçÆÊµÅ
     */
    async testCompleteDataFlow() {
        // Ê®°ÊãüÂÆåÊï¥ÁöÑÊï∞ÊçÆÂ§ÑÁêÜÊµÅÁ®ãÔºöRSSÈááÈõÜ -> ÂÜÖÂÆπÂ§ÑÁêÜ -> NotionÂ≠òÂÇ® -> ÁÅ´È∏üÂèëÂ∏É
        const mockRSSData = {
            title: 'Complete Data Flow Test Article',
            content: 'This is a comprehensive integration test article that simulates the complete data flow from RSS collection through content processing, Notion storage, to final publication on Firebird portal. The article contains sufficient content to pass all validation checks and quality scoring algorithms.',
            source: 'Integration Test RSS',
            author: 'Test Author',
            source_url: 'https://example.com/integration-test',
            publishedAt: new Date().toISOString(),
            sourceType: 'rss',
            keywords: ['integration', 'test', 'automation'],
            image_url: 'https://example.com/test-image.jpg'
        };

        // 1. Êï∞ÊçÆÈ™åËØÅÂíåÊ†áÂáÜÂåñ
        const validationResult = await this.validator.validateAndStandardize(mockRSSData);
        if (!validationResult.isValid) {
            throw new Error(`Êï∞ÊçÆÈ™åËØÅÂ§±Ë¥•: ${validationResult.errors?.join(', ')}`);
        }

        // 2. Ë¥®ÈáèÊ£ÄÊü•
        const qualityScore = validationResult.item.qualityScore;
        if (qualityScore < 60) {
            throw new Error(`Ë¥®ÈáèÂàÜÊï∞Ëøá‰Ωé: ${qualityScore}`);
        }

        // 3. Êï∞ÊçÆÊ†áÂáÜÂåñÊ£ÄÊü•
        const standardizedData = validationResult.item;
        if (!standardizedData.title || !standardizedData.content) {
            throw new Error('Êï∞ÊçÆÊ†áÂáÜÂåñÂ§±Ë¥•');
        }

        // 4. Ê®°ÊãüNotionÂ≠òÂÇ®Ê†ºÂºèËΩ¨Êç¢
        const notionData = this.convertToNotionFormat(standardizedData);
        if (!notionData.Ê†áÈ¢ò || !notionData.ÂÜÖÂÆπ) {
            throw new Error('NotionÊ†ºÂºèËΩ¨Êç¢Â§±Ë¥•');
        }

        // 5. Ê®°ÊãüÁÅ´È∏üÈó®Êà∑APIÊ†ºÂºèËΩ¨Êç¢
        const firebirdData = this.convertToFirebirdFormat(notionData);
        if (!firebirdData.title || !firebirdData.body) {
            throw new Error('ÁÅ´È∏üÈó®Êà∑Ê†ºÂºèËΩ¨Êç¢Â§±Ë¥•');
        }

        return {
            status: 'passed',
            message: `ÂÆåÊï¥Êï∞ÊçÆÊµÅÊµãËØïÈÄöËøáÔºåË¥®ÈáèÂàÜÊï∞: ${qualityScore}`,
            details: {
                originalData: mockRSSData,
                validationResult: validationResult,
                notionFormat: notionData,
                firebirdFormat: firebirdData
            }
        };
    }

    /**
     * ÊµãËØïÂ§öÊ∫êÊï∞ÊçÆÈõÜÊàê
     */
    async testMultiSourceIntegration() {
        const testSources = [
            {
                type: 'rss',
                name: 'Test RSS Source',
                data: {
                    title: 'RSS Test Article',
                    content: 'This is a test article from RSS source with comprehensive content for validation.',
                    source: 'Test RSS',
                    publishedAt: new Date().toISOString()
                }
            },
            {
                type: 'github',
                name: 'Test GitHub Source',
                data: {
                    title: 'GitHub Project Update',
                    content: 'This is a test article from GitHub API representing a trending project update.',
                    source: 'GitHub API',
                    author: 'GitHub User',
                    publishedAt: new Date().toISOString()
                }
            },
            {
                type: 'api',
                name: 'Test API Source',
                data: {
                    title: 'API News Article',
                    content: 'This is a test article from external API source with structured data format.',
                    source: 'External API',
                    publishedAt: new Date().toISOString()
                }
            }
        ];

        const processedSources = [];
        const errors = [];

        for (const source of testSources) {
            try {
                const validationResult = await this.validator.validateAndStandardize(source.data);
                if (validationResult.isValid) {
                    processedSources.push({
                        source: source.name,
                        type: source.type,
                        qualityScore: validationResult.item.qualityScore,
                        status: 'success'
                    });
                } else {
                    errors.push({
                        source: source.name,
                        type: source.type,
                        errors: validationResult.errors,
                        status: 'validation_failed'
                    });
                }
            } catch (error) {
                errors.push({
                    source: source.name,
                    type: source.type,
                    error: error.message,
                    status: 'processing_failed'
                });
            }
        }

        const successRate = (processedSources.length / testSources.length) * 100;
        if (successRate < 80) {
            throw new Error(`Â§öÊ∫êÈõÜÊàêÊàêÂäüÁéáËøá‰Ωé: ${successRate}%`);
        }

        return {
            status: 'passed',
            message: `Â§öÊ∫êÊï∞ÊçÆÈõÜÊàêÊàêÂäüÁéá: ${successRate}%`,
            details: {
                totalSources: testSources.length,
                successfulSources: processedSources.length,
                failedSources: errors.length,
                processedSources,
                errors
            }
        };
    }

    /**
     * ÊµãËØïNotionÂ≠òÂÇ®ÈõÜÊàê
     */
    async testNotionStorageIntegration() {
        const testData = {
            title: 'Notion Storage Integration Test',
            content: 'This article tests the integration with Notion database storage functionality.',
            source: 'Integration Test',
            author: 'Test Author',
            publishedAt: new Date().toISOString(),
            keywords: ['notion', 'storage', 'integration'],
            qualityScore: 85
        };

        // ËΩ¨Êç¢‰∏∫NotionÊ†ºÂºè
        const notionData = this.convertToNotionFormat(testData);

        // È™åËØÅNotionÊï∞ÊçÆÁªìÊûÑ
        const requiredNotionFields = [
            'Ê†áÈ¢ò', 'ÂÜÖÂÆπ', 'Êù•Ê∫ê', '‰ΩúËÄÖ', 'ÂèëÂ∏ÉÊó•Êúü',
            'Ë¥®ÈáèÂàÜÊï∞', 'Â§ÑÁêÜÁä∂ÊÄÅ', 'ÂàõÂª∫Êó∂Èó¥'
        ];

        const missingFields = requiredNotionFields.filter(field =>
            !notionData.hasOwnProperty(field)
        );

        if (missingFields.length > 0) {
            throw new Error(`NotionÊï∞ÊçÆÁº∫Â∞ëÂøÖÈúÄÂ≠óÊÆµ: ${missingFields.join(', ')}`);
        }

        // È™åËØÅÊï∞ÊçÆÁ±ªÂûãÂíåÊ†ºÂºè
        if (typeof notionData.Ê†áÈ¢ò !== 'string' || notionData.Ê†áÈ¢ò.length === 0) {
            throw new Error('NotionÊ†áÈ¢òÊ†ºÂºèÊó†Êïà');
        }

        if (typeof notionData.Ë¥®ÈáèÂàÜÊï∞ !== 'number' || notionData.Ë¥®ÈáèÂàÜÊï∞ < 0) {
            throw new Error('NotionË¥®ÈáèÂàÜÊï∞Ê†ºÂºèÊó†Êïà');
        }

        // Ê®°ÊãüAPIË∞ÉÁî®È™åËØÅ
        const apiPayload = {
            parent: { database_id: 'test-database-id' },
            properties: this.buildNotionProperties(notionData)
        };

        if (!apiPayload.properties || Object.keys(apiPayload.properties).length === 0) {
            throw new Error('Notion APIËΩΩËç∑ÊûÑÂª∫Â§±Ë¥•');
        }

        return {
            status: 'passed',
            message: 'NotionÂ≠òÂÇ®ÈõÜÊàêÈ™åËØÅÈÄöËøá',
            details: {
                notionData,
                apiPayload,
                fieldCount: Object.keys(notionData).length
            }
        };
    }

    /**
     * ÊµãËØïÁÅ´È∏üÈó®Êà∑ÂèëÂ∏ÉÈõÜÊàê
     */
    async testFirebirdPublishIntegration() {
        const notionData = {
            Ê†áÈ¢ò: 'Firebird Publish Integration Test',
            ÂÜÖÂÆπ: 'This article tests the integration with Firebird portal publishing functionality.',
            Êù•Ê∫ê: 'Integration Test',
            ‰ΩúËÄÖ: 'Test Author',
            ÂèëÂ∏ÉÊó•Êúü: new Date().toISOString(),
            ÂàÜÁ±ªID: 1,
            ÂÖ≥ÈîÆËØç: ['firebird', 'publish', 'integration'],
            ÊëòË¶Å: 'Integration test for Firebird publishing',
            Áº©Áï•ÂõæURL: 'https://example.com/thumbnail.jpg',
            Ë¥®ÈáèÂàÜÊï∞: 88
        };

        // ËΩ¨Êç¢‰∏∫ÁÅ´È∏üÈó®Êà∑APIÊ†ºÂºè
        const firebirdData = this.convertToFirebirdFormat(notionData);

        // È™åËØÅÁÅ´È∏üÈó®Êà∑APIÊï∞ÊçÆÁªìÊûÑ
        const requiredFirebirdFields = [
            'service', 'action', 'title', 'typeid', 'body'
        ];

        const missingFields = requiredFirebirdFields.filter(field =>
            !firebirdData.hasOwnProperty(field)
        );

        if (missingFields.length > 0) {
            throw new Error(`ÁÅ´È∏üÈó®Êà∑APIÊï∞ÊçÆÁº∫Â∞ëÂøÖÈúÄÂ≠óÊÆµ: ${missingFields.join(', ')}`);
        }

        // È™åËØÅÂ≠óÊÆµÈïøÂ∫¶ÈôêÂà∂
        if (firebirdData.title.length > 60) {
            throw new Error(`Ê†áÈ¢òË∂ÖÈïø: ${firebirdData.title.length} > 60`);
        }

        if (firebirdData.keywords && firebirdData.keywords.length > 50) {
            throw new Error(`ÂÖ≥ÈîÆËØçË∂ÖÈïø: ${firebirdData.keywords.length} > 50`);
        }

        if (firebirdData.description && firebirdData.description.length > 255) {
            throw new Error(`ÊèèËø∞Ë∂ÖÈïø: ${firebirdData.description.length} > 255`);
        }

        // È™åËØÅAPIÂèÇÊï∞Ê†ºÂºè
        if (firebirdData.service !== 'article' || firebirdData.action !== 'put') {
            throw new Error('ÁÅ´È∏üÈó®Êà∑APIÊúçÂä°ÂèÇÊï∞ÈîôËØØ');
        }

        if (typeof firebirdData.typeid !== 'number' || firebirdData.typeid < 1) {
            throw new Error('ÁÅ´È∏üÈó®Êà∑ÂàÜÁ±ªIDÊó†Êïà');
        }

        return {
            status: 'passed',
            message: 'ÁÅ´È∏üÈó®Êà∑ÂèëÂ∏ÉÈõÜÊàêÈ™åËØÅÈÄöËøá',
            details: {
                firebirdData,
                fieldValidation: {
                    titleLength: firebirdData.title.length,
                    keywordsLength: firebirdData.keywords?.length || 0,
                    descriptionLength: firebirdData.description?.length || 0
                }
            }
        };
    }

    /**
     * ÊµãËØïÈîôËØØÊÅ¢Â§çÈõÜÊàê
     */
    async testErrorRecoveryIntegration() {
        const errorScenarios = [
            {
                name: 'ÁΩëÁªúËøûÊé•Â§±Ë¥•',
                error: new Error('ECONNRESET: Connection reset by peer'),
                expectedRecovery: 'retry_with_backoff'
            },
            {
                name: 'APIËÆ§ËØÅÂ§±Ë¥•',
                error: new Error('401 Unauthorized: Invalid token'),
                expectedRecovery: 'refresh_credentials'
            },
            {
                name: 'Êï∞ÊçÆÈ™åËØÅÂ§±Ë¥•',
                error: new Error('Validation failed: Required field missing'),
                expectedRecovery: 'skip_and_log'
            },
            {
                name: 'Â≠òÂÇ®Á©∫Èó¥‰∏çË∂≥',
                error: new Error('507 Insufficient Storage'),
                expectedRecovery: 'cleanup_and_retry'
            }
        ];

        const recoveryResults = [];

        for (const scenario of errorScenarios) {
            try {
                // Ê®°ÊãüÈîôËØØÂ§ÑÁêÜ
                const errorResult = await this.errorHandler.handleError(scenario.error, {
                    service: 'integration_test',
                    phase: 'error_recovery_test'
                });

                recoveryResults.push({
                    scenario: scenario.name,
                    error: scenario.error.message,
                    handled: !!errorResult.errorId,
                    strategy: errorResult.strategy || 'unknown',
                    success: true
                });

            } catch (error) {
                recoveryResults.push({
                    scenario: scenario.name,
                    error: scenario.error.message,
                    handled: false,
                    strategy: 'none',
                    success: false,
                    failureReason: error.message
                });
            }
        }

        const successfulRecoveries = recoveryResults.filter(r => r.success).length;
        const recoveryRate = (successfulRecoveries / errorScenarios.length) * 100;

        if (recoveryRate < 75) {
            throw new Error(`ÈîôËØØÊÅ¢Â§çÊàêÂäüÁéáËøá‰Ωé: ${recoveryRate}%`);
        }

        return {
            status: 'passed',
            message: `ÈîôËØØÊÅ¢Â§çÈõÜÊàêÊµãËØïÊàêÂäüÁéá: ${recoveryRate}%`,
            details: {
                totalScenarios: errorScenarios.length,
                successfulRecoveries,
                recoveryResults
            }
        };
    }

    /**
     * ÊµãËØïÊï∞ÊçÆ‰∏ÄËá¥ÊÄßÈ™åËØÅ
     */
    async testDataConsistencyValidation() {
        const testTransactions = [];
        const consistencyErrors = [];

        // ÂàõÂª∫Â§ö‰∏™ÊµãËØï‰∫ãÂä°
        for (let i = 0; i < 5; i++) {
            try {
                const transactionId = `consistency_test_${i}_${Date.now()}`;

                // Ê®°Êãü‰∫ãÂä°Êìç‰Ωú
                const transaction = {
                    id: transactionId,
                    operations: [
                        {
                            type: 'create',
                            target: `test_data_${i}`,
                            data: { id: i, content: `Test content ${i}`, timestamp: Date.now() }
                        },
                        {
                            type: 'update',
                            target: `test_data_${i}`,
                            data: { id: i, content: `Updated content ${i}`, timestamp: Date.now() }
                        }
                    ],
                    status: 'completed',
                    timestamp: Date.now()
                };

                testTransactions.push(transaction);

                // È™åËØÅÊï∞ÊçÆÂÆåÊï¥ÊÄß
                const integrityCheck = this.validateDataIntegrity(transaction);
                if (!integrityCheck.valid) {
                    consistencyErrors.push({
                        transactionId,
                        error: integrityCheck.error,
                        type: 'integrity_violation'
                    });
                }

            } catch (error) {
                consistencyErrors.push({
                    transactionId: `consistency_test_${i}`,
                    error: error.message,
                    type: 'transaction_failure'
                });
            }
        }

        // È™åËØÅ‰∫ãÂä°Èó¥‰∏ÄËá¥ÊÄß
        const crossTransactionConsistency = this.validateCrossTransactionConsistency(testTransactions);
        if (!crossTransactionConsistency.valid) {
            consistencyErrors.push({
                error: crossTransactionConsistency.error,
                type: 'cross_transaction_inconsistency'
            });
        }

        const consistencyRate = ((testTransactions.length - consistencyErrors.length) / testTransactions.length) * 100;

        if (consistencyRate < 90) {
            throw new Error(`Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÈ™åËØÅÂ§±Ë¥•ÁéáËøáÈ´ò: ${100 - consistencyRate}%`);
        }

        return {
            status: 'passed',
            message: `Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÈ™åËØÅÈÄöËøáÁéá: ${consistencyRate}%`,
            details: {
                totalTransactions: testTransactions.length,
                consistencyErrors: consistencyErrors.length,
                errors: consistencyErrors
            }
        };
    }

    /**
     * ÊµãËØïÂ∑•‰ΩúÊµÅÁä∂ÊÄÅÁÆ°ÁêÜ
     */
    async testWorkflowStateManagement() {
        const workflowStates = [
            'initialized',
            'collecting_data',
            'processing_content',
            'storing_notion',
            'publishing_firebird',
            'completed'
        ];

        const stateTransitions = [];
        let currentState = 'initialized';

        for (let i = 1; i < workflowStates.length; i++) {
            const nextState = workflowStates[i];

            try {
                // Ê®°ÊãüÁä∂ÊÄÅËΩ¨Êç¢
                const transition = {
                    from: currentState,
                    to: nextState,
                    timestamp: Date.now(),
                    data: { step: i, progress: (i / workflowStates.length) * 100 }
                };

                // È™åËØÅÁä∂ÊÄÅËΩ¨Êç¢ÁöÑÊúâÊïàÊÄß
                const isValidTransition = this.validateStateTransition(transition);
                if (!isValidTransition) {
                    throw new Error(`Êó†ÊïàÁöÑÁä∂ÊÄÅËΩ¨Êç¢: ${currentState} -> ${nextState}`);
                }

                stateTransitions.push({
                    ...transition,
                    success: true
                });

                currentState = nextState;

            } catch (error) {
                stateTransitions.push({
                    from: currentState,
                    to: nextState,
                    timestamp: Date.now(),
                    success: false,
                    error: error.message
                });
                break;
            }
        }

        const successfulTransitions = stateTransitions.filter(t => t.success).length;
        const transitionRate = (successfulTransitions / (workflowStates.length - 1)) * 100;

        if (transitionRate < 100) {
            throw new Error(`Â∑•‰ΩúÊµÅÁä∂ÊÄÅËΩ¨Êç¢Â§±Ë¥•: ${100 - transitionRate}%`);
        }

        return {
            status: 'passed',
            message: `Â∑•‰ΩúÊµÅÁä∂ÊÄÅÁÆ°ÁêÜÈ™åËØÅÈÄöËøá: ${transitionRate}%`,
            details: {
                totalStates: workflowStates.length,
                successfulTransitions,
                stateTransitions,
                finalState: currentState
            }
        };
    }

    /**
     * ÊµãËØïÊâπÈáèÂ§ÑÁêÜÊÄßËÉΩ
     */
    async testBatchProcessingPerformance() {
        const batchSizes = [10, 50, 100];
        const performanceResults = [];

        for (const batchSize of batchSizes) {
            // ÁîüÊàêÊµãËØïÊï∞ÊçÆ
            const testData = [];
            for (let i = 0; i < batchSize; i++) {
                testData.push({
                    title: `Batch Performance Test Article ${i + 1}`,
                    content: `This is batch performance test article number ${i + 1}. It contains sufficient content to pass validation checks and quality scoring algorithms. The content is designed to simulate real-world article processing scenarios.`,
                    source: 'Batch Performance Test',
                    author: 'Test Author',
                    publishedAt: new Date().toISOString(),
                    keywords: ['batch', 'performance', 'test']
                });
            }

            const startTime = Date.now();

            try {
                const results = await this.validator.batchValidateAndStandardize(testData);
                const processingTime = Date.now() - startTime;
                const throughput = (batchSize / processingTime * 1000).toFixed(2);
                const averageTime = (processingTime / batchSize).toFixed(2);

                performanceResults.push({
                    batchSize,
                    processingTime,
                    throughput: parseFloat(throughput),
                    averageTime: parseFloat(averageTime),
                    validItems: results.valid.length,
                    invalidItems: results.invalid.length,
                    successRate: (results.valid.length / batchSize) * 100,
                    success: true
                });

            } catch (error) {
                performanceResults.push({
                    batchSize,
                    success: false,
                    error: error.message
                });
            }
        }

        // È™åËØÅÊÄßËÉΩÊåáÊ†á
        const failedBatches = performanceResults.filter(r => !r.success);
        if (failedBatches.length > 0) {
            throw new Error(`ÊâπÈáèÂ§ÑÁêÜÂ§±Ë¥•: ${failedBatches.map(b => b.batchSize).join(', ')}`);
        }

        // Ê£ÄÊü•ÂêûÂêêÈáèÊòØÂê¶Êª°Ë∂≥Ë¶ÅÊ±Ç (Ëá≥Â∞ë10È°π/Áßí)
        const lowThroughputBatches = performanceResults.filter(r => r.throughput < 10);
        if (lowThroughputBatches.length > 0) {
            throw new Error(`ÊâπÈáèÂ§ÑÁêÜÂêûÂêêÈáèËøá‰Ωé: ${lowThroughputBatches.map(b => `${b.batchSize}:${b.throughput}`).join(', ')}`);
        }

        return {
            status: 'passed',
            message: `ÊâπÈáèÂ§ÑÁêÜÊÄßËÉΩÊµãËØïÈÄöËøáÔºåÊúÄÂ§ßÂêûÂêêÈáè: ${Math.max(...performanceResults.map(r => r.throughput))}È°π/Áßí`,
            details: performanceResults
        };
    }

    /**
     * ÊµãËØïÂπ∂ÂèëÂ§ÑÁêÜ
     */
    async testConcurrentProcessing() {
        const concurrencyLevels = [5, 10, 20];
        const concurrencyResults = [];

        for (const concurrency of concurrencyLevels) {
            const promises = [];
            const startTime = Date.now();

            // ÂàõÂª∫Âπ∂Âèë‰ªªÂä°
            for (let i = 0; i < concurrency; i++) {
                const testData = {
                    title: `Concurrent Test Article ${i + 1}`,
                    content: `This is concurrent test article number ${i + 1} designed to test parallel processing capabilities.`,
                    source: 'Concurrent Test',
                    author: 'Test Author',
                    publishedAt: new Date().toISOString(),
                    taskId: i
                };

                const promise = this.validator.validateAndStandardize(testData);
                promises.push(promise);
            }

            try {
                const results = await Promise.allSettled(promises);
                const processingTime = Date.now() - startTime;

                const successful = results.filter(r => r.status === 'fulfilled' && r.value.isValid).length;
                const failed = results.filter(r => r.status === 'rejected' || !r.value?.isValid).length;
                const successRate = (successful / concurrency) * 100;

                concurrencyResults.push({
                    concurrency,
                    processingTime,
                    successful,
                    failed,
                    successRate,
                    averageTime: (processingTime / concurrency).toFixed(2),
                    success: successRate >= 90
                });

            } catch (error) {
                concurrencyResults.push({
                    concurrency,
                    success: false,
                    error: error.message
                });
            }
        }

        const failedConcurrency = concurrencyResults.filter(r => !r.success);
        if (failedConcurrency.length > 0) {
            throw new Error(`Âπ∂ÂèëÂ§ÑÁêÜÂ§±Ë¥•: ${failedConcurrency.map(c => c.concurrency).join(', ')}`);
        }

        const minSuccessRate = Math.min(...concurrencyResults.map(r => r.successRate));
        if (minSuccessRate < 90) {
            throw new Error(`Âπ∂ÂèëÂ§ÑÁêÜÊàêÂäüÁéáËøá‰Ωé: ${minSuccessRate}%`);
        }

        return {
            status: 'passed',
            message: `Âπ∂ÂèëÂ§ÑÁêÜÊµãËØïÈÄöËøáÔºåÊúÄ‰ΩéÊàêÂäüÁéá: ${minSuccessRate}%`,
            details: concurrencyResults
        };
    }

    /**
     * ÊµãËØïÈïøÊó∂Èó¥ËøêË°åÁ®≥ÂÆöÊÄß
     */
    async testLongRunningStability() {
        const testDuration = 30000; // 30ÁßíÊµãËØï
        const intervalMs = 2000; // ÊØè2ÁßíÊâßË°å‰∏ÄÊ¨°
        const startTime = Date.now();
        const stabilityResults = [];
        let iterationCount = 0;

        while (Date.now() - startTime < testDuration) {
            iterationCount++;

            try {
                const testData = {
                    title: `Stability Test Article ${iterationCount}`,
                    content: `This is stability test article number ${iterationCount} for long-running stability validation.`,
                    source: 'Stability Test',
                    author: 'Test Author',
                    publishedAt: new Date().toISOString(),
                    iteration: iterationCount
                };

                const result = await this.validator.validateAndStandardize(testData);

                stabilityResults.push({
                    iteration: iterationCount,
                    timestamp: Date.now(),
                    success: result.isValid,
                    qualityScore: result.item?.qualityScore || 0,
                    processingTime: Date.now() - startTime
                });

                // Ê£ÄÊü•ÂÜÖÂ≠ò‰ΩøÁî®ÊÉÖÂÜµ
                const memUsage = process.memoryUsage();
                if (memUsage.heapUsed > 100 * 1024 * 1024) { // 100MB
                    console.warn(`    ÂÜÖÂ≠ò‰ΩøÁî®ËøáÈ´ò: ${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`);
                }

            } catch (error) {
                stabilityResults.push({
                    iteration: iterationCount,
                    timestamp: Date.now(),
                    success: false,
                    error: error.message
                });
            }

            // Á≠âÂæÖ‰∏ã‰∏ÄÊ¨°Ëø≠‰ª£
            await new Promise(resolve => setTimeout(resolve, intervalMs));
        }

        const totalDuration = Date.now() - startTime;
        const successfulIterations = stabilityResults.filter(r => r.success).length;
        const stabilityRate = (successfulIterations / iterationCount) * 100;

        if (stabilityRate < 95) {
            throw new Error(`ÈïøÊó∂Èó¥ËøêË°åÁ®≥ÂÆöÊÄßËøá‰Ωé: ${stabilityRate}%`);
        }

        // Ê£ÄÊü•ÊÄßËÉΩÈÄÄÂåñ
        const firstHalf = stabilityResults.slice(0, Math.floor(stabilityResults.length / 2));
        const secondHalf = stabilityResults.slice(Math.floor(stabilityResults.length / 2));

        const firstHalfAvgScore = firstHalf.reduce((sum, r) => sum + (r.qualityScore || 0), 0) / firstHalf.length;
        const secondHalfAvgScore = secondHalf.reduce((sum, r) => sum + (r.qualityScore || 0), 0) / secondHalf.length;

        const performanceDegradation = ((firstHalfAvgScore - secondHalfAvgScore) / firstHalfAvgScore) * 100;

        if (performanceDegradation > 10) {
            throw new Error(`ÊÄßËÉΩÈÄÄÂåñËøáÂ§ß: ${performanceDegradation.toFixed(2)}%`);
        }

        return {
            status: 'passed',
            message: `ÈïøÊó∂Èó¥ËøêË°åÁ®≥ÂÆöÊÄßÊµãËØïÈÄöËøá: ${stabilityRate}%ÔºåÊÄßËÉΩÈÄÄÂåñ: ${performanceDegradation.toFixed(2)}%`,
            details: {
                totalDuration,
                iterationCount,
                successfulIterations,
                stabilityRate,
                performanceDegradation,
                memoryUsage: process.memoryUsage()
            }
        };
    }

    /**
     * ËΩ¨Êç¢‰∏∫NotionÊ†ºÂºè
     */
    convertToNotionFormat(data) {
        return {
            Ê†áÈ¢ò: data.title || '',
            Áü≠Ê†áÈ¢ò: data.title ? data.title.substring(0, 36) : '',
            ÂÜÖÂÆπ: data.content || '',
            ÊëòË¶Å: data.summary || data.content?.substring(0, 200) || '',
            Êù•Ê∫ê: data.source || '',
            ‰ΩúËÄÖ: data.author || '',
            ÂéüÂßãURL: data.source_url || '',
            ÂèëÂ∏ÉÊó•Êúü: data.publishedAt || new Date().toISOString(),
            ÂàÜÁ±ªID: data.categoryId || 1,
            ÂàÜÁ±ªÂêçÁß∞: data.categoryName || 'ÁßëÊäÄËµÑËÆØ',
            ÂÖ≥ÈîÆËØç: data.keywords || [],
            Áº©Áï•ÂõæURL: data.image_url || '',
            Ë¥®ÈáèÂàÜÊï∞: data.qualityScore || 0,
            Â§ÑÁêÜÁä∂ÊÄÅ: 'Â∑≤Â≠òÂÇ®',
            ÂÆ°Ê†∏Áä∂ÊÄÅ: 'Â∑≤ÂÆ°Ê†∏',
            ÂàõÂª∫Êó∂Èó¥: new Date().toISOString(),
            Êõ¥Êñ∞Êó∂Èó¥: new Date().toISOString()
        };
    }

    /**
     * ËΩ¨Êç¢‰∏∫ÁÅ´È∏üÈó®Êà∑Ê†ºÂºè
     */
    convertToFirebirdFormat(notionData) {
        return {
            service: 'article',
            action: 'put',
            title: notionData.Ê†áÈ¢ò.substring(0, 60),
            typeid: notionData.ÂàÜÁ±ªID || 1,
            body: notionData.ÂÜÖÂÆπ,
            writer: notionData.‰ΩúËÄÖ || 'AIÈááÈõÜ',
            source: notionData.Êù•Ê∫ê || 'AIÈááÈõÜ',
            sourceurl: notionData.ÂéüÂßãURL || '',
            keywords: Array.isArray(notionData.ÂÖ≥ÈîÆËØç) ?
                notionData.ÂÖ≥ÈîÆËØç.join(',').substring(0, 50) : '',
            description: notionData.ÊëòË¶Å.substring(0, 255),
            litpic: notionData.Áº©Áï•ÂõæURL || '',
            subtitle: notionData.Áü≠Ê†áÈ¢ò || '',
            mbody: notionData.ÂÜÖÂÆπ
        };
    }

    /**
     * ÊûÑÂª∫NotionÂ±ûÊÄß
     */
    buildNotionProperties(notionData) {
        return {
            'Ê†áÈ¢ò': {
                title: [{ text: { content: notionData.Ê†áÈ¢ò } }]
            },
            'ÂÜÖÂÆπ': {
                rich_text: [{ text: { content: notionData.ÂÜÖÂÆπ } }]
            },
            'Êù•Ê∫ê': {
                select: { name: notionData.Êù•Ê∫ê }
            },
            'Ë¥®ÈáèÂàÜÊï∞': {
                number: notionData.Ë¥®ÈáèÂàÜÊï∞
            },
            'Â§ÑÁêÜÁä∂ÊÄÅ': {
                select: { name: notionData.Â§ÑÁêÜÁä∂ÊÄÅ }
            }
        };
    }

    /**
     * È™åËØÅÊï∞ÊçÆÂÆåÊï¥ÊÄß
     */
    validateDataIntegrity(transaction) {
        try {
            if (!transaction.id || !transaction.operations) {
                return { valid: false, error: '‰∫ãÂä°ÁªìÊûÑ‰∏çÂÆåÊï¥' };
            }

            for (const operation of transaction.operations) {
                if (!operation.type || !operation.target || !operation.data) {
                    return { valid: false, error: 'Êìç‰ΩúÁªìÊûÑ‰∏çÂÆåÊï¥' };
                }
            }

            return { valid: true };
        } catch (error) {
            return { valid: false, error: error.message };
        }
    }

    /**
     * È™åËØÅË∑®‰∫ãÂä°‰∏ÄËá¥ÊÄß
     */
    validateCrossTransactionConsistency(transactions) {
        try {
            const targets = new Set();

            for (const transaction of transactions) {
                for (const operation of transaction.operations) {
                    if (targets.has(operation.target)) {
                        return { valid: false, error: `ÁõÆÊ†áÂÜ≤Á™Å: ${operation.target}` };
                    }
                    targets.add(operation.target);
                }
            }

            return { valid: true };
        } catch (error) {
            return { valid: false, error: error.message };
        }
    }

    /**
     * È™åËØÅÁä∂ÊÄÅËΩ¨Êç¢
     */
    validateStateTransition(transition) {
        const validTransitions = {
            'initialized': ['collecting_data'],
            'collecting_data': ['processing_content'],
            'processing_content': ['storing_notion'],
            'storing_notion': ['publishing_firebird'],
            'publishing_firebird': ['completed']
        };

        const allowedNextStates = validTransitions[transition.from] || [];
        return allowedNextStates.includes(transition.to);
    }

    /**
     * ËøêË°åÂçï‰∏™ÊµãËØï
     */
    async runTest(testName, testFunction) {
        this.testResults.total++;

        try {
            console.log(`  üß™ ${testName}...`);

            const startTime = Date.now();
            const result = await Promise.race([
                testFunction(),
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('ÊµãËØïË∂ÖÊó∂')), this.config.testTimeout)
                )
            ]);
            const duration = Date.now() - startTime;

            this.testResults.passed++;
            this.testResults.tests.push({
                name: testName,
                status: 'passed',
                duration,
                message: result.message,
                details: result.details
            });

            console.log(`    ‚úÖ ${result.message} (${duration}ms)`);

        } catch (error) {
            this.testResults.failed++;
            this.testResults.tests.push({
                name: testName,
                status: 'failed',
                error: error.message,
                stack: error.stack
            });

            console.log(`    ‚ùå ${error.message}`);
        }
    }

    /**
     * ÁîüÊàêÊµãËØïÊä•Âëä
     */
    async generateTestReport() {
        const report = {
            testSuite: 'Enhanced News Collection Workflow',
            timestamp: new Date().toISOString(),
            summary: {
                total: this.testResults.total,
                passed: this.testResults.passed,
                failed: this.testResults.failed,
                skipped: this.testResults.skipped,
                successRate: ((this.testResults.passed / this.testResults.total) * 100).toFixed(2) + '%'
            },
            environment: {
                nodeVersion: process.version,
                platform: process.platform,
                workspaceRoot: this.config.workspaceRoot
            },
            tests: this.testResults.tests,
            errorHandlerStats: this.errorHandler.getErrorReport()
        };

        const reportPath = path.join(this.config.workspaceRoot, 'logs', `test-report-${Date.now()}.json`);
        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));

        console.log(`üìä ÊµãËØïÊä•ÂëäÂ∑≤ÁîüÊàê: ${reportPath}`);
    }

    /**
     * ÊâìÂç∞ÊµãËØïÊëòË¶Å
     */
    printTestSummary() {
        console.log('\nüìã ÊµãËØïÊëòË¶Å:');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log(`ÊÄªÊµãËØïÊï∞: ${this.testResults.total}`);
        console.log(`‚úÖ ÈÄöËøá: ${this.testResults.passed}`);
        console.log(`‚ùå Â§±Ë¥•: ${this.testResults.failed}`);
        console.log(`‚è≠Ô∏è  Ë∑≥Ëøá: ${this.testResults.skipped}`);
        console.log(`ÊàêÂäüÁéá: ${((this.testResults.passed / this.testResults.total) * 100).toFixed(2)}%`);
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

        if (this.testResults.failed > 0) {
            console.log('\n‚ùå Â§±Ë¥•ÁöÑÊµãËØï:');
            this.testResults.tests
                .filter(test => test.status === 'failed')
                .forEach(test => {
                    console.log(`  ‚Ä¢ ${test.name}: ${test.error}`);
                });
        }

        console.log('\nüéâ ÊµãËØïÂ•ó‰ª∂ÊâßË°åÂÆåÊàêÔºÅ');
    }
}

// ‰∏ªÂáΩÊï∞
async function main() {
    const tester = new WorkflowTester({
        enableDetailedLogging: true,
        maxTestItems: 10
    });

    await tester.runAllTests();
}

// Â¶ÇÊûúÁõ¥Êé•ËøêË°åÊ≠§ËÑöÊú¨
if (require.main === module) {
    main().catch(error => {
        console.error('ÊµãËØïÊâßË°åÂ§±Ë¥•:', error);
        process.exit(1);
    });
}

module.exports = { WorkflowTester };